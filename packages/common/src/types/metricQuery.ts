import { type AnyType } from './any';
import { type DateZoom } from './api/paginatedQuery';
import {
    BinType,
    friendlyName,
    isCustomBinDimension,
    isCustomDimension,
    isCustomSqlDimension,
    type CompactOrAlias,
    type CompiledCustomDimension,
    type CompiledDimension,
    type CompiledMetric,
    type CompiledTableCalculation,
    type CustomDimension,
    type CustomFormat,
    type Dimension,
    type FieldId,
    type Format,
    type Metric,
    type MetricType,
    type TableCalculation,
} from './field';
import { type Filters, type MetricFilterRule } from './filter';
import { type TimeFrames } from './timeFrames';

export interface AdditionalMetric {
    /** Display label for the metric */
    label?: string;
    /** Aggregation type */
    type: MetricType;
    /** Description of what the metric measures */
    description?: string;
    /** SQL expression (e.g., ${TABLE}.column_name) */
    sql: string;
    /** Whether the metric is hidden from users */
    hidden?: boolean;
    /** Number of decimal places */
    // @deprecated Use format expression instead
    round?: number;
    /** Compact format for large numbers */
    // @deprecated Use format expression instead
    compact?: CompactOrAlias;
    /** Format string (legacy format specification) */
    format?: Format | string; // // Format type is deprecated, use format expression(string) instead
    /** Table name the metric belongs to */
    table: string;
    /** Internal name of the metric */
    name: string;
    /** Display order index */
    index?: number;
    /** Filters to apply to this metric */
    filters?: MetricFilterRule[];
    /** Name of the base dimension/column this metric aggregates */
    baseDimensionName?: string;
    /** Unique identifier for the metric */
    uuid?: string | null;
    /** Percentile value for percentile metrics */
    percentile?: number;
    /** Formatting configuration */
    formatOptions?: CustomFormat;
    /**
     * Optional marker for metrics generated by the system.
     * Currently used for Period-over-Period (PoP) previous-period metrics.
     */
    generationType?: 'periodOverPeriod';
    /**
     * For PoP-generated metrics, the base metric id that this metric is derived from.
     */
    baseMetricId?: FieldId;
    /**
     * For PoP-generated metrics, the time dimension id used for the comparison.
     */
    timeDimensionId?: FieldId;
    /**
     * For PoP-generated metrics, the granularity used for the comparison.
     */
    granularity?: TimeFrames;
    /**
     * For PoP-generated metrics, the number of periods to offset by (>= 1).
     */
    periodOffset?: number;
}

export const isAdditionalMetric = (value: AnyType): value is AdditionalMetric =>
    value?.table &&
    value?.name &&
    !value?.fieldType &&
    !isCustomDimension(value);

export interface PeriodOverPeriodAdditionalMetric extends AdditionalMetric {
    generationType: 'periodOverPeriod';
    /**
     * The base metric id that this metric is the previous-period version of.
     * This avoids relying on suffix parsing to establish the relationship.
     */
    baseMetricId: FieldId;
    /**
     * The time dimension field id used for the comparison.
     */
    timeDimensionId: FieldId;
    /**
     * Granularity for the comparison (derived from the chosen time dimension).
     */
    granularity: TimeFrames;
    /**
     * Number of periods to offset by (>= 1).
     */
    periodOffset: number;
}

type PeriodOverPeriodGeneratedMetricMetadata = {
    generationType: 'periodOverPeriod';
    baseMetricId: FieldId;
    timeDimensionId: FieldId;
    granularity: TimeFrames;
    periodOffset: number;
};

/**
 * Type guard for Period-over-Period generated metric metadata.
 *
 * Note: This metadata can exist on both `AdditionalMetric` objects (query-time)
 * and the converted `Metric` objects in `ItemsMap` (render-time), since we
 * preserve these fields during conversion.
 */
export const hasPeriodOverPeriodGeneratedMetricMetadata = (
    value: AnyType,
): value is PeriodOverPeriodGeneratedMetricMetadata => {
    if (!value || typeof value !== 'object') return false;
    if (
        !('generationType' in value) ||
        !('baseMetricId' in value) ||
        !('timeDimensionId' in value) ||
        !('granularity' in value) ||
        !('periodOffset' in value)
    )
        return false;

    const record = value as Record<string, unknown>;
    return (
        record.generationType === 'periodOverPeriod' &&
        typeof record.baseMetricId === 'string' &&
        typeof record.timeDimensionId === 'string' &&
        typeof record.granularity === 'string' &&
        typeof record.periodOffset === 'number'
    );
};

export const isPeriodOverPeriodAdditionalMetric = (
    value: AnyType,
): value is PeriodOverPeriodAdditionalMetric =>
    isAdditionalMetric(value) &&
    hasPeriodOverPeriodGeneratedMetricMetadata(value);

export const hasFormatOptions = (
    value: AnyType,
): value is { formatOptions: CustomFormat } => !!value.formatOptions;

export const getCustomMetricDimensionId = (metric: AdditionalMetric) =>
    `${metric.table}_${metric.baseDimensionName}`;

export type MetricOverrides = { [key: string]: Pick<Metric, 'formatOptions'> }; // Don't use Record to avoid issues in TSOA

export type DimensionOverrides = {
    [key: string]: Pick<Dimension, 'formatOptions'>;
};

// Object used to query an explore. Queries only happen within a single explore
export type MetricQuery = {
    /** The name of the explore to query */
    exploreName: string;
    /** List of dimension field IDs to include */
    dimensions: FieldId[];
    /** List of metric field IDs to include */
    metrics: FieldId[];
    /** Filter rules to apply to the query */
    filters: Filters;
    /** Sort configuration for query results */
    sorts: SortField[];
    /** Maximum number of rows to return */
    limit: number;
    /** Custom calculations to perform on query results */
    tableCalculations: TableCalculation[];
    /** Custom metrics defined inline (ad-hoc metrics not in the dbt model) */
    additionalMetrics?: AdditionalMetric[];
    /** Custom dimensions defined inline */
    customDimensions?: CustomDimension[];
    /** Override formatting options for existing metrics */
    metricOverrides?: MetricOverrides;
    /** Override formatting options for existing dimensions */
    dimensionOverrides?: DimensionOverrides;
    /** Timezone for date/time values (e.g., 'America/Los_Angeles', 'UTC') */
    timezone?: string;
    metadata?: {
        hasADateDimension: Pick<CompiledDimension, 'label' | 'name' | 'table'>;
    };
};
export type CompiledMetricQuery = Omit<MetricQuery, 'customDimensions'> & {
    compiledTableCalculations: CompiledTableCalculation[];
    compiledAdditionalMetrics: CompiledMetric[];
    compiledCustomDimensions: CompiledCustomDimension[];
};
// Sort by
export type SortField = {
    /** Field ID to sort by */
    fieldId: string;
    /** Sort in descending order */
    descending: boolean;
    /** Sort null values first */
    nullsFirst?: boolean;
};

export const getAdditionalMetricLabel = (item: AdditionalMetric) =>
    `${friendlyName(item.table)} ${item.label}`;

type FilterGroupResponse =
    | {
          id: string;
          or: AnyType[];
      }
    | {
          id: string;
          and: AnyType[];
      };
export type FiltersResponse = {
    dimensions?: FilterGroupResponse;
    metrics?: FilterGroupResponse;
    tableCalculations?: FilterGroupResponse;
};
export type MetricQueryResponse = {
    exploreName: string;
    dimensions: FieldId[]; // Dimensions to group by in the explore
    metrics: FieldId[]; // Metrics to compute in the explore
    filters: FiltersResponse;
    sorts: SortField[]; // Sorts for the data
    limit: number; // Max number of rows to return from query
    tableCalculations: TableCalculation[]; // calculations to append to results
    additionalMetrics?: AdditionalMetric[]; // existing metric type
    customDimensions?: CustomDimension[];
    metadata?: {
        hasADateDimension: Pick<CompiledDimension, 'label' | 'name' | 'table'>;
    };
};

export const countCustomDimensionsInMetricQuery = (
    metricQuery: MetricQuery,
) => ({
    numFixedWidthBinCustomDimensions:
        metricQuery.customDimensions?.filter(
            (dimension) =>
                isCustomBinDimension(dimension) &&
                dimension.binType === BinType.FIXED_NUMBER,
        ).length || 0,
    numFixedBinsBinCustomDimensions:
        metricQuery.customDimensions?.filter(
            (dimension) =>
                isCustomBinDimension(dimension) &&
                dimension.binType === BinType.FIXED_WIDTH,
        ).length || 0,
    numCustomRangeBinCustomDimensions:
        metricQuery.customDimensions?.filter(
            (dimension) =>
                isCustomBinDimension(dimension) &&
                dimension.binType === BinType.CUSTOM_RANGE,
        ).length || 0,
    numCustomSqlDimensions:
        metricQuery.customDimensions?.filter((dimension) =>
            isCustomSqlDimension(dimension),
        ).length || 0,
});

export const hasCustomBinDimension = (metricQuery: MetricQuery | undefined) =>
    metricQuery?.customDimensions &&
    metricQuery.customDimensions.some((dimension) =>
        isCustomBinDimension(dimension),
    );

export type MetricQueryRequest = {
    // tsoa doesn't support complex types like MetricQuery, so we simplified it
    exploreName: string;
    dimensions: FieldId[]; // Dimensions to group by in the explore
    metrics: FieldId[]; // Metrics to compute in the explore
    filters: {
        dimensions?: AnyType;
        metrics?: AnyType;
        tableCalculations?: AnyType;
    };
    sorts: SortField[]; // Sorts for the data
    limit: number; // Max number of rows to return from query
    tableCalculations: TableCalculation[]; // calculations to append to results
    additionalMetrics?: AdditionalMetric[]; // existing metric type
    csvLimit?: number;
    customDimensions?: CustomDimension[];
    dateZoom?: DateZoom;
    metadata?: MetricQuery['metadata'];
    timezone?: string;
    metricOverrides?: MetricOverrides;
    dimensionOverrides?: DimensionOverrides;
};

export type QueryWarning = {
    message: string; // message, in markdown, to be shown to the user
    fields?: string[]; // fields that relate to this message
    tables?: string[]; // tables that relate to this message
};
