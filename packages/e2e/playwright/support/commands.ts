// Playwright custom commands for E2E tests
// Migrated from Cypress commands to async functions that work with Playwright's APIRequestContext

import type { APIRequestContext, Page } from '@playwright/test';
import { expect } from '@playwright/test';
import {
    AnyType,
    ApiChartSummaryListResponse,
    CreateChartInSpace,
    CreateDashboard,
    CreateEmbedJwt,
    CreatePersonalAccessToken,
    CreateSavedChart,
    CreateWarehouseCredentials,
    Dashboard,
    DashboardBasicDetails,
    DashboardTileTypes,
    OrganizationProject,
    SavedChart,
    SEED_PROJECT,
} from '@lightdash/common';
import { login, logout } from './auth';

type ProjectPermission = {
    role: string;
    projectUuid: string;
};

export const selectMantine = async (
    page: Page,
    inputName: string,
    optionLabel: string,
): Promise<void> => {
    await page.locator(`input[name="${inputName}"]`).click();
    await page.locator('.mantine-Select-root').getByText(optionLabel).click();
};

export const registerNewUser = async (request: APIRequestContext): Promise<string> => {
    const email = `demo+${new Date().getTime()}@lightdash.com`;
    const response = await request.post('api/v1/user', {
        data: {
            firstName: 'Test',
            lastName: 'e2e',
            email,
            password: 'demo_password!',
        },
    });
    expect(response.status()).toBe(200);
    return email;
};

export const registerWithCode = async (
    request: APIRequestContext,
    inviteCode: string,
): Promise<void> => {
    const response = await request.post('api/v1/user', {
        data: {
            inviteCode,
            firstName: 'test',
            lastName: 'test',
            password: 'test1234',
        },
    });
    expect(response.status()).toBe(200);
};

export const verifyEmail = async (request: APIRequestContext): Promise<void> => {
    const response = await request.get('api/v1/user/me/email/status?passcode=000000');
    expect(response.status()).toBe(200);
};

export const invite = async (
    request: APIRequestContext,
    email: string,
    role: string,
): Promise<string> => {
    const expiresAt = new Date(Date.now() + 24 * 60 * 60 * 1000); // in 1 day

    const response = await request.post('api/v1/invite-links', {
        data: {
            role,
            email,
            expiresAt,
        },
    });
    expect(response.status()).toBe(201);
    const body = await response.json();
    return body.results.inviteCode;
};

export const addProjectPermission = async (
    request: APIRequestContext,
    email: string,
    role: string,
    projectUuid: string,
): Promise<void> => {
    const response = await request.post(`api/v1/projects/${projectUuid}/access`, {
        data: {
            role,
            email,
            sendEmail: false,
        },
    });
    expect(response.status()).toBe(200);
};



export const loginWithPermissions = async (
    request: APIRequestContext,
    orgRole: string,
    projectPermissions: ProjectPermission[],
): Promise<string> => {
    await login(request);

    const email = `demo+${orgRole}-${new Date().getTime()}@lightdash.com`;

    const inviteCode = await invite(request, email, orgRole);
    
    await Promise.all(
        projectPermissions.map((projectPermission) =>
            addProjectPermission(
                request,
                email,
                projectPermission.role,
                projectPermission.projectUuid,
            )
        )
    );

    await registerWithCode(request, inviteCode);
    await verifyEmail(request);
    return email;
};

export const loginWithEmail = async (
    request: APIRequestContext,
    email: string,
): Promise<void> => {
    const response = await request.post('api/v1/login', {
        data: {
            email,
            password: 'test1234',
        },
    });
    expect(response.status()).toBe(200);
};

export const getApiToken = async (request: APIRequestContext): Promise<string> => {
    const createToken: CreatePersonalAccessToken = {
        description: 'e2e',
        autoGenerated: true,
        expiresAt: null,
    };
    
    const response = await request.post('api/v1/user/me/personal-access-tokens', {
        data: createToken,
    });
    expect(response.status()).toBe(200);
    const body = await response.json();
    return body.results.token;
};

export const deleteProjectsByName = async (
    request: APIRequestContext,
    names: string[],
): Promise<void> => {
    const response = await request.get('api/v1/org/projects');
    expect(response.status()).toBe(200);
    const body = await response.json();
    
    const deletePromises = (body.results as OrganizationProject[])
        .filter(({ name }) => names.includes(name))
        .map(async ({ projectUuid }) => {
            const deleteResponse = await request.delete(`api/v1/org/projects/${projectUuid}`);
            expect(deleteResponse.status()).toBe(200);
        });
    
    await Promise.all(deletePromises);
};

export const deleteDashboardsByName = async (
    request: APIRequestContext,
    names: string[],
): Promise<void> => {
    const response = await request.get(`api/v1/projects/${SEED_PROJECT.project_uuid}/dashboards`);
    expect(response.status()).toBe(200);
    const body = await response.json();
    
    const deletePromises = (body.results as DashboardBasicDetails[])
        .filter(({ name }) => names.includes(name))
        .map(async ({ uuid }) => {
            const deleteResponse = await request.delete(`api/v1/dashboards/${uuid}`);
            expect(deleteResponse.status()).toBe(200);
        });
    
    await Promise.all(deletePromises);
};

export const deleteChartsByName = async (
    request: APIRequestContext,
    names: string[],
): Promise<void> => {
    const response = await request.get(`api/v1/projects/${SEED_PROJECT.project_uuid}/charts`);
    expect(response.status()).toBe(200);
    const body: ApiChartSummaryListResponse = await response.json();
    
    const deletePromises = body.results
        .filter(({ name }) => names.includes(name))
        .map(async ({ uuid }) => {
            const deleteResponse = await request.delete(`api/v1/saved/${uuid}`);
            expect(deleteResponse.status()).toBe(200);
        });
    
    await Promise.all(deletePromises);
};

export const createProject = async (
    request: APIRequestContext,
    projectName: string,
    warehouseConfig?: CreateWarehouseCredentials,
): Promise<string> => {
    const defaultWarehouseConfig = {
        host: process.env.PGHOST || 'localhost',
        user: 'postgres',
        password: process.env.PGPASSWORD || 'password',
        dbname: 'postgres',
        searchPath: '',
        role: '',
        sshTunnelHost: '',
        sshTunnelUser: '',
        schema: 'jaffle',
        port: 5432,
        keepalivesIdle: 0,
        sslmode: 'disable' as const,
        sshTunnelPort: 22,
        requireUserCredentials: false,
        type: 'postgres' as const,
    };

    const response = await request.post('api/v1/org/projects', {
        data: {
            name: projectName,
            type: 'DEFAULT',
            dbtConnection: {
                target: '',
                environment: [],
                type: 'dbt',
                project_dir: process.env.DBT_PROJECT_DIR,
            },
            dbtVersion: 'v1.7',
            warehouseConnection: warehouseConfig || defaultWarehouseConfig,
        },
    });
    expect(response.status()).toBe(200);
    const body = await response.json();
    return body.results.project.projectUuid;
};

export const createSpace = async (
    request: APIRequestContext,
    projectUuid: string,
    spaceName: string,
): Promise<string> => {
    const response = await request.post(`api/v1/projects/${projectUuid}/spaces/`, {
        data: {
            name: spaceName,
            isPrivate: false,
        },
    });
    expect(response.status()).toBe(200);
    const body = await response.json();
    return body.results.uuid;
};

export const createChartInSpace = async (
    request: APIRequestContext,
    projectUuid: string,
    chartData: CreateChartInSpace,
): Promise<SavedChart> => {
    const response = await request.post(`api/v1/projects/${projectUuid}/saved`, {
        data: chartData,
    });
    expect(response.status()).toBe(200);
    const body = await response.json();
    return body.results;
};

export const dragAndDrop = async (
    page: Page,
    dragSelector: string,
    dropSelector: string,
): Promise<void> => {
    const draggable = await page.locator(dragSelector);
    const droppable = await page.locator(dropSelector);
    
    await draggable.dragTo(droppable);
};

export const getJwtToken = async (
    request: APIRequestContext,
    projectUuid: string,
    options: {
        userEmail?: string;
        userExternalId?: string | null;
        canExportCsv?: boolean;
        canExportImages?: boolean;
        canExportPagePdf?: boolean;
        canDateZoom?: boolean;
        canExplore?: boolean;
    } = {},
): Promise<string> => {
    const {
        userEmail = 'test@example.com',
        userExternalId = 'test-user-123',
        canExportCsv = false,
        canExportImages = false,
        canExportPagePdf = false,
        canDateZoom = false,
        canExplore = false,
    } = options;

    // First login to get embed configuration and dashboard UUID
    await login(request);

    // Get a dashboard UUID from the project
    const dashboardsResponse = await request.get(`api/v1/projects/${projectUuid}/dashboards`);
    expect(dashboardsResponse.status()).toBe(200);
    const dashboardsBody = await dashboardsResponse.json();
    expect(dashboardsBody.results.length).toBeGreaterThan(0);
    const dashboardUuid = dashboardsBody.results[0].uuid;

    // Get embed configuration to get the encoded secret
    const configResponse = await request.get(`api/v1/embed/${projectUuid}/config`);
    expect(configResponse.status()).toBe(200);

    // Create JWT data structure
    const jwtData: CreateEmbedJwt = {
        content: {
            type: 'dashboard',
            projectUuid,
            dashboardUuid,
            canExportCsv,
            canExportImages,
            canExportPagePdf,
            canDateZoom,
            canExplore,
        },
        userAttributes: {
            email: userEmail,
            externalId: userExternalId || '',
        },
        user: {
            email: userEmail,
            externalId: userExternalId || undefined,
        },
        expiresIn: '1h',
    };

    // Create embed URL to get the JWT token
    const embedUrlResponse = await request.post(`api/v1/embed/${projectUuid}/get-embed-url`, {
        data: jwtData,
    });
    expect(embedUrlResponse.status()).toBe(200);
    const embedBody = await embedUrlResponse.json();

    // Extract JWT token from the URL (it's in the hash fragment)
    const { url } = embedBody.results;
    const jwtToken = url.split('#')[1];

    // Logout to clear session
    await logout(request);

    return jwtToken;
};

export const getMonacoEditorText = async (page: Page): Promise<string> => {
    await page.waitForTimeout(200); // wait for new SQL to load
    await page.locator('.monaco-editor').waitFor();
    
    // Get the Monaco editor text from the window
    const normalizedText = await page.evaluate(() => {
        const win = window as AnyType;
        if (!win.monaco) throw new Error('Monaco editor not found');
        
        const editor = win.monaco.editor.getModels()[0];
        const sqlRunnerText = editor.getValue();
        
        // Normalize the text by removing new lines and converting multiple white spaces to single white space
        return sqlRunnerText
            .replace(/\n/g, ' ')
            .replace(/\s+/g, ' ')
            .trim();
    });
    
    return normalizedText;
};

export const createDashboard = async (
    request: APIRequestContext,
    projectUuid: string,
    dashboardData: CreateDashboard,
): Promise<Dashboard> => {
    const response = await request.post(`api/v1/projects/${projectUuid}/dashboards`, {
        data: dashboardData,
    });
    expect(response.status()).toBe(201);
    const body = await response.json();
    return body.results;
};

export const createChartAndUpdateDashboard = async (
    request: APIRequestContext,
    projectUuid: string,
    chartData: CreateSavedChart,
    dashboard: Dashboard,
): Promise<{ chart: SavedChart; dashboard: Dashboard }> => {
    const chartResponse = await request.post(`api/v1/projects/${projectUuid}/saved`, {
        data: chartData,
    });
    expect(chartResponse.status()).toBe(200);
    const chartBody = await chartResponse.json();
    const newChart = chartBody.results;

    const updatedDashboard = await request.patch(`api/v1/dashboards/${dashboard.uuid}`, {
        data: {
            ...dashboard,
            tiles: [
                ...dashboard.tiles,
                {
                    tabUuid: undefined,
                    type: DashboardTileTypes.SAVED_CHART,
                    x: 0,
                    y: 0,
                    h: 5,
                    w: 5,
                    properties: {
                        savedChartUuid: newChart.uuid,
                    },
                },
            ],
        },
    });
    expect(updatedDashboard.status()).toBe(200);
    const updatedDashboardBody = await updatedDashboard.json();

    return {
        chart: newChart,
        dashboard: updatedDashboardBody.results,
    };
};