{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as Classes from \"./common/classes\";\nimport { Utils } from \"./common/utils\";\n/**\n * `Region`s contain sets of cells. Additionally, a distinction is drawn, for\n * example, between all cells within a column and the whole column itself.\n * The `RegionCardinality` enum represents these distinct types of `Region`s.\n */\n\nexport var RegionCardinality;\n\n(function (RegionCardinality) {\n  /**\n   * A region that contains a finite rectangular group of table cells\n   */\n  RegionCardinality[\"CELLS\"] = \"cells\";\n  /**\n   * A region that represents all cells within 1 or more rows.\n   */\n\n  RegionCardinality[\"FULL_ROWS\"] = \"full-rows\";\n  /**\n   * A region that represents all cells within 1 or more columns.\n   */\n\n  RegionCardinality[\"FULL_COLUMNS\"] = \"full-columns\";\n  /**\n   * A region that represents all cells in the table.\n   */\n\n  RegionCardinality[\"FULL_TABLE\"] = \"full-table\";\n})(RegionCardinality || (RegionCardinality = {}));\n/**\n * A convenience object for subsets of `RegionCardinality` that are commonly\n * used as the `selectionMode` prop of the `<Table>`.\n */\n\n\nexport var SelectionModes = {\n  ALL: [RegionCardinality.FULL_TABLE, RegionCardinality.FULL_COLUMNS, RegionCardinality.FULL_ROWS, RegionCardinality.CELLS],\n  COLUMNS_AND_CELLS: [RegionCardinality.FULL_COLUMNS, RegionCardinality.CELLS],\n  COLUMNS_ONLY: [RegionCardinality.FULL_COLUMNS],\n  NONE: [],\n  ROWS_AND_CELLS: [RegionCardinality.FULL_ROWS, RegionCardinality.CELLS],\n  ROWS_ONLY: [RegionCardinality.FULL_ROWS]\n};\nexport var ColumnLoadingOption;\n\n(function (ColumnLoadingOption) {\n  ColumnLoadingOption[\"CELLS\"] = \"cells\";\n  ColumnLoadingOption[\"HEADER\"] = \"column-header\";\n})(ColumnLoadingOption || (ColumnLoadingOption = {}));\n\nexport var RowLoadingOption;\n\n(function (RowLoadingOption) {\n  RowLoadingOption[\"CELLS\"] = \"cells\";\n  RowLoadingOption[\"HEADER\"] = \"row-header\";\n})(RowLoadingOption || (RowLoadingOption = {}));\n\nexport var TableLoadingOption;\n\n(function (TableLoadingOption) {\n  TableLoadingOption[\"CELLS\"] = \"cells\";\n  TableLoadingOption[\"COLUMN_HEADERS\"] = \"column-header\";\n  TableLoadingOption[\"ROW_HEADERS\"] = \"row-header\";\n})(TableLoadingOption || (TableLoadingOption = {}));\n\nvar Regions =\n/** @class */\nfunction () {\n  function Regions() {}\n  /**\n   * Determines the cardinality of a region. We use null values to indicate\n   * an unbounded interval. Therefore, an example of a region containing the\n   * second and third columns would be:\n   *\n   * ```js\n   * { rows: null, cols: [1, 2] }\n   * ```\n   *\n   * In this case, this method would return `RegionCardinality.FULL_COLUMNS`.\n   *\n   * If both rows and columns are unbounded, then the region covers the\n   * entire table. Therefore, a region like this:\n   *\n   * ```js\n   * { rows: null, cols: null }\n   * ```\n   *\n   * will return `RegionCardinality.FULL_TABLE`.\n   *\n   * An example of a region containing a single cell in the table would be:\n   *\n   * ```js\n   * { rows: [5, 5], cols: [2, 2] }\n   * ```\n   *\n   * In this case, this method would return `RegionCardinality.CELLS`.\n   */\n\n\n  Regions.getRegionCardinality = function (region) {\n    if (region.cols != null && region.rows != null) {\n      return RegionCardinality.CELLS;\n    } else if (region.cols != null) {\n      return RegionCardinality.FULL_COLUMNS;\n    } else if (region.rows != null) {\n      return RegionCardinality.FULL_ROWS;\n    } else {\n      return RegionCardinality.FULL_TABLE;\n    }\n  };\n\n  Regions.getFocusCellCoordinatesFromRegion = function (region) {\n    var regionCardinality = Regions.getRegionCardinality(region);\n\n    switch (regionCardinality) {\n      case RegionCardinality.FULL_TABLE:\n        return {\n          col: 0,\n          row: 0\n        };\n\n      case RegionCardinality.FULL_COLUMNS:\n        return {\n          col: region.cols[0],\n          row: 0\n        };\n\n      case RegionCardinality.FULL_ROWS:\n        return {\n          col: 0,\n          row: region.rows[0]\n        };\n\n      case RegionCardinality.CELLS:\n        return {\n          col: region.cols[0],\n          row: region.rows[0]\n        };\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Returns a deep copy of the provided region.\n   */\n\n\n  Regions.copy = function (region) {\n    var cardinality = Regions.getRegionCardinality(region); // we need to be careful not to explicitly spell out `rows: undefined`\n    // (e.g.) if the \"rows\" key is completely absent, otherwise\n    // deep-equality checks will fail.\n\n    if (cardinality === RegionCardinality.CELLS) {\n      return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);\n    } else if (cardinality === RegionCardinality.FULL_COLUMNS) {\n      return Regions.column(region.cols[0], region.cols[1]);\n    } else if (cardinality === RegionCardinality.FULL_ROWS) {\n      return Regions.row(region.rows[0], region.rows[1]);\n    } else {\n      return Regions.table();\n    }\n  };\n  /**\n   * Returns a region containing one or more cells.\n   */\n\n\n  Regions.cell = function (row, col, row2, col2) {\n    return {\n      cols: this.normalizeInterval(col, col2),\n      rows: this.normalizeInterval(row, row2)\n    };\n  };\n  /**\n   * Returns a region containing one or more full rows.\n   */\n\n\n  Regions.row = function (row, row2) {\n    return {\n      rows: this.normalizeInterval(row, row2)\n    };\n  };\n  /**\n   * Returns a region containing one or more full columns.\n   */\n\n\n  Regions.column = function (col, col2) {\n    return {\n      cols: this.normalizeInterval(col, col2)\n    };\n  };\n  /**\n   * Returns a region containing the entire table.\n   */\n\n\n  Regions.table = function () {\n    return {};\n  };\n  /**\n   * Adds the region to the end of a cloned copy of the supplied region\n   * array.\n   */\n\n\n  Regions.add = function (regions, region) {\n    var copy = regions.slice();\n    copy.push(region);\n    return copy;\n  };\n  /**\n   * Replaces the region at the end of a cloned copy of the supplied region\n   * array, or at the specific index if one is provided.\n   */\n\n\n  Regions.update = function (regions, region, index) {\n    var copy = regions.slice();\n\n    if (index != null) {\n      copy.splice(index, 1, region);\n    } else {\n      copy.pop();\n      copy.push(region);\n    }\n\n    return copy;\n  };\n  /**\n   * Clamps the region's start and end indices between 0 and the provided\n   * maximum values.\n   */\n\n\n  Regions.clampRegion = function (region, maxRowIndex, maxColumnIndex) {\n    var nextRegion = Regions.copy(region);\n\n    if (region.rows != null) {\n      nextRegion.rows[0] = Utils.clamp(region.rows[0], 0, maxRowIndex);\n      nextRegion.rows[1] = Utils.clamp(region.rows[1], 0, maxRowIndex);\n    }\n\n    if (region.cols != null) {\n      nextRegion.cols[0] = Utils.clamp(region.cols[0], 0, maxColumnIndex);\n      nextRegion.cols[1] = Utils.clamp(region.cols[1], 0, maxColumnIndex);\n    }\n\n    return nextRegion;\n  };\n  /**\n   * Returns true iff the specified region is equal to the last region in\n   * the region list. This allows us to avoid immediate additive re-selection.\n   */\n\n\n  Regions.lastRegionIsEqual = function (regions, region) {\n    if (regions == null || regions.length === 0) {\n      return false;\n    }\n\n    var lastRegion = regions[regions.length - 1];\n    return Regions.regionsEqual(lastRegion, region);\n  };\n  /**\n   * Returns the index of the region that is equal to the supplied\n   * parameter. Returns -1 if no such region is found.\n   */\n\n\n  Regions.findMatchingRegion = function (regions, region) {\n    if (regions == null) {\n      return -1;\n    }\n\n    for (var i = 0; i < regions.length; i++) {\n      if (Regions.regionsEqual(regions[i], region)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Returns the index of the region that wholly contains the supplied\n   * parameter. Returns -1 if no such region is found.\n   */\n\n\n  Regions.findContainingRegion = function (regions, region) {\n    if (regions == null) {\n      return -1;\n    }\n\n    for (var i = 0; i < regions.length; i++) {\n      if (Regions.regionContains(regions[i], region)) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Returns true if the regions contain a region that has FULL_COLUMNS\n   * cardinality and contains the specified column index.\n   */\n\n\n  Regions.hasFullColumn = function (regions, col) {\n    if (regions == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n      var region = regions_1[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      if (cardinality === RegionCardinality.FULL_TABLE) {\n        return true;\n      }\n\n      if (cardinality === RegionCardinality.FULL_COLUMNS && Regions.intervalContainsIndex(region.cols, col)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the regions contain a region that has FULL_ROWS\n   * cardinality and contains the specified row index.\n   */\n\n\n  Regions.hasFullRow = function (regions, row) {\n    if (regions == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_2 = regions; _i < regions_2.length; _i++) {\n      var region = regions_2[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      if (cardinality === RegionCardinality.FULL_TABLE) {\n        return true;\n      }\n\n      if (cardinality === RegionCardinality.FULL_ROWS && Regions.intervalContainsIndex(region.rows, row)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the regions contain a region that has FULL_TABLE cardinality\n   */\n\n\n  Regions.hasFullTable = function (regions) {\n    if (regions == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_3 = regions; _i < regions_3.length; _i++) {\n      var region = regions_3[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      if (cardinality === RegionCardinality.FULL_TABLE) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if the regions fully contain the query region.\n   */\n\n\n  Regions.containsRegion = function (regions, query) {\n    return Regions.overlapsRegion(regions, query, false);\n  };\n  /**\n   * Returns true if the regions at least partially overlap the query region.\n   */\n\n\n  Regions.overlapsRegion = function (regions, query, allowPartialOverlap) {\n    if (allowPartialOverlap === void 0) {\n      allowPartialOverlap = false;\n    }\n\n    var intervalCompareFn = allowPartialOverlap ? Regions.intervalOverlaps : Regions.intervalContains;\n\n    if (regions == null || query == null) {\n      return false;\n    }\n\n    for (var _i = 0, regions_4 = regions; _i < regions_4.length; _i++) {\n      var region = regions_4[_i];\n      var cardinality = Regions.getRegionCardinality(region);\n\n      switch (cardinality) {\n        case RegionCardinality.FULL_TABLE:\n          return true;\n\n        case RegionCardinality.FULL_COLUMNS:\n          if (intervalCompareFn(region.cols, query.cols)) {\n            return true;\n          }\n\n          continue;\n\n        case RegionCardinality.FULL_ROWS:\n          if (intervalCompareFn(region.rows, query.rows)) {\n            return true;\n          }\n\n          continue;\n\n        case RegionCardinality.CELLS:\n          if (intervalCompareFn(region.cols, query.cols) && intervalCompareFn(region.rows, query.rows)) {\n            return true;\n          }\n\n          continue;\n\n        default:\n          break;\n      }\n    }\n\n    return false;\n  };\n\n  Regions.eachUniqueFullColumn = function (regions, iteratee) {\n    if (regions == null || regions.length === 0 || iteratee == null) {\n      return;\n    }\n\n    var seen = {};\n    regions.forEach(function (region) {\n      if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_COLUMNS) {\n        var _a = region.cols,\n            start = _a[0],\n            end = _a[1];\n\n        for (var col = start; col <= end; col++) {\n          if (!seen[col]) {\n            seen[col] = true;\n            iteratee(col);\n          }\n        }\n      }\n    });\n  };\n\n  Regions.eachUniqueFullRow = function (regions, iteratee) {\n    if (regions == null || regions.length === 0 || iteratee == null) {\n      return;\n    }\n\n    var seen = {};\n    regions.forEach(function (region) {\n      if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_ROWS) {\n        var _a = region.rows,\n            start = _a[0],\n            end = _a[1];\n\n        for (var row = start; row <= end; row++) {\n          if (!seen[row]) {\n            seen[row] = true;\n            iteratee(row);\n          }\n        }\n      }\n    });\n  };\n  /**\n   * Using the supplied array of non-contiguous `IRegion`s, this method\n   * returns an ordered array of every unique cell that exists in those\n   * regions.\n   */\n\n\n  Regions.enumerateUniqueCells = function (regions, numRows, numCols) {\n    if (regions == null || regions.length === 0) {\n      return [];\n    }\n\n    var seen = {};\n    var list = [];\n\n    for (var _i = 0, regions_5 = regions; _i < regions_5.length; _i++) {\n      var region = regions_5[_i];\n      Regions.eachCellInRegion(region, numRows, numCols, function (row, col) {\n        // add to list if not seen\n        var key = row + \"-\" + col;\n\n        if (seen[key] !== true) {\n          seen[key] = true;\n          list.push([row, col]);\n        }\n      });\n    } // sort list by rows then columns\n\n\n    list.sort(Regions.rowFirstComparator);\n    return list;\n  };\n  /**\n   * Using the supplied region, returns an \"equivalent\" region of\n   * type CELLS that define the bounds of the given region\n   */\n\n\n  Regions.getCellRegionFromRegion = function (region, numRows, numCols) {\n    var regionCardinality = Regions.getRegionCardinality(region);\n\n    switch (regionCardinality) {\n      case RegionCardinality.FULL_TABLE:\n        return Regions.cell(0, 0, numRows - 1, numCols - 1);\n\n      case RegionCardinality.FULL_COLUMNS:\n        return Regions.cell(0, region.cols[0], numRows - 1, region.cols[1]);\n\n      case RegionCardinality.FULL_ROWS:\n        return Regions.cell(region.rows[0], 0, region.rows[1], numCols - 1);\n\n      case RegionCardinality.CELLS:\n        return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);\n\n      default:\n        return null;\n    }\n  };\n  /**\n   * Maps a dense array of cell coordinates to a sparse 2-dimensional array\n   * of cell values.\n   *\n   * We create a new 2-dimensional array representing the smallest single\n   * contiguous `IRegion` that contains all cells in the supplied array. We\n   * invoke the mapper callback only on the cells in the supplied coordinate\n   * array and store the result. Returns the resulting 2-dimensional array.\n   */\n\n\n  Regions.sparseMapCells = function (cells, mapper) {\n    var bounds = Regions.getBoundingRegion(cells);\n\n    if (bounds == null) {\n      return null;\n    }\n\n    var numRows = bounds.rows[1] + 1 - bounds.rows[0];\n    var numCols = bounds.cols[1] + 1 - bounds.cols[0];\n    var result = Utils.times(numRows, function () {\n      return new Array(numCols);\n    });\n    cells.forEach(function (_a) {\n      var row = _a[0],\n          col = _a[1];\n      result[row - bounds.rows[0]][col - bounds.cols[0]] = mapper(row, col);\n    });\n    return result;\n  };\n  /**\n   * Returns the smallest single contiguous `IRegion` that contains all cells in the\n   * supplied array.\n   */\n\n\n  Regions.getBoundingRegion = function (cells) {\n    var minRow;\n    var maxRow;\n    var minCol;\n    var maxCol;\n\n    for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {\n      var _a = cells_1[_i],\n          row = _a[0],\n          col = _a[1];\n      minRow = minRow == null || row < minRow ? row : minRow;\n      maxRow = maxRow == null || row > maxRow ? row : maxRow;\n      minCol = minCol == null || col < minCol ? col : minCol;\n      maxCol = maxCol == null || col > maxCol ? col : maxCol;\n    }\n\n    if (minRow == null) {\n      return null;\n    }\n\n    return {\n      cols: [minCol, maxCol],\n      rows: [minRow, maxRow]\n    };\n  };\n\n  Regions.isValid = function (region) {\n    if (region == null) {\n      return false;\n    }\n\n    if (region.rows != null && (region.rows[0] < 0 || region.rows[1] < 0)) {\n      return false;\n    }\n\n    if (region.cols != null && (region.cols[0] < 0 || region.cols[1] < 0)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Regions.isRegionValidForTable = function (region, numRows, numCols) {\n    if (numRows === 0 || numCols === 0) {\n      return false;\n    } else if (region.rows != null && !intervalInRangeInclusive(region.rows, 0, numRows - 1)) {\n      return false;\n    } else if (region.cols != null && !intervalInRangeInclusive(region.cols, 0, numCols - 1)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Regions.joinStyledRegionGroups = function (selectedRegions, otherRegions, focusedCell) {\n    var regionGroups = [];\n\n    if (otherRegions != null) {\n      regionGroups = regionGroups.concat(otherRegions);\n    }\n\n    if (selectedRegions != null && selectedRegions.length > 0) {\n      regionGroups.push({\n        className: Classes.TABLE_SELECTION_REGION,\n        regions: selectedRegions\n      });\n    }\n\n    if (focusedCell != null) {\n      regionGroups.push({\n        className: Classes.TABLE_FOCUS_REGION,\n        regions: [Regions.cell(focusedCell.row, focusedCell.col)]\n      });\n    }\n\n    return regionGroups;\n  };\n\n  Regions.regionsEqual = function (regionA, regionB) {\n    return Regions.intervalsEqual(regionA.rows, regionB.rows) && Regions.intervalsEqual(regionA.cols, regionB.cols);\n  };\n  /**\n   * Expands an old region to the minimal bounding region that also contains\n   * the new region. If the regions have different cardinalities, then the new\n   * region is returned. Useful for expanding a selected region on\n   * shift+click, for instance.\n   */\n\n\n  Regions.expandRegion = function (oldRegion, newRegion) {\n    var oldRegionCardinality = Regions.getRegionCardinality(oldRegion);\n    var newRegionCardinality = Regions.getRegionCardinality(newRegion);\n\n    if (newRegionCardinality !== oldRegionCardinality) {\n      return newRegion;\n    }\n\n    switch (newRegionCardinality) {\n      case RegionCardinality.FULL_ROWS:\n        {\n          var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);\n          var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);\n          return Regions.row(rowStart, rowEnd);\n        }\n\n      case RegionCardinality.FULL_COLUMNS:\n        {\n          var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);\n          var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);\n          return Regions.column(colStart, colEnd);\n        }\n\n      case RegionCardinality.CELLS:\n        {\n          var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);\n          var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);\n          var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);\n          var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);\n          return Regions.cell(rowStart, colStart, rowEnd, colEnd);\n        }\n\n      default:\n        return Regions.table();\n    }\n  };\n  /**\n   * Iterates over the cells within an `IRegion`, invoking the callback with\n   * each cell's coordinates.\n   */\n\n\n  Regions.eachCellInRegion = function (region, numRows, numCols, iteratee) {\n    var cardinality = Regions.getRegionCardinality(region);\n\n    switch (cardinality) {\n      case RegionCardinality.FULL_TABLE:\n        for (var row = 0; row < numRows; row++) {\n          for (var col = 0; col < numCols; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      case RegionCardinality.FULL_COLUMNS:\n        for (var row = 0; row < numRows; row++) {\n          for (var col = region.cols[0]; col <= region.cols[1]; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      case RegionCardinality.FULL_ROWS:\n        for (var row = region.rows[0]; row <= region.rows[1]; row++) {\n          for (var col = 0; col < numCols; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      case RegionCardinality.CELLS:\n        for (var row = region.rows[0]; row <= region.rows[1]; row++) {\n          for (var col = region.cols[0]; col <= region.cols[1]; col++) {\n            iteratee(row, col);\n          }\n        }\n\n        break;\n\n      default:\n        break;\n    }\n  };\n\n  Regions.regionContains = function (regionA, regionB) {\n    // containsRegion expects an array of regions as the first param\n    return Regions.overlapsRegion([regionA], regionB, false);\n  };\n\n  Regions.intervalsEqual = function (ivalA, ivalB) {\n    if (ivalA == null) {\n      return ivalB == null;\n    } else if (ivalB == null) {\n      return false;\n    } else {\n      return ivalA[0] === ivalB[0] && ivalA[1] === ivalB[1];\n    }\n  };\n\n  Regions.intervalContainsIndex = function (interval, index) {\n    if (interval == null) {\n      return false;\n    }\n\n    return interval[0] <= index && interval[1] >= index;\n  };\n\n  Regions.intervalContains = function (ivalA, ivalB) {\n    if (ivalA == null || ivalB == null) {\n      return false;\n    }\n\n    return ivalA[0] <= ivalB[0] && ivalB[1] <= ivalA[1];\n  };\n\n  Regions.intervalOverlaps = function (ivalA, ivalB) {\n    if (ivalA == null || ivalB == null) {\n      return false;\n    }\n\n    if (ivalA[1] < ivalB[0] || ivalA[0] > ivalB[1]) {\n      return false;\n    }\n\n    return true;\n  };\n\n  Regions.rowFirstComparator = function (a, b) {\n    var rowDiff = a[0] - b[0];\n    return rowDiff === 0 ? a[1] - b[1] : rowDiff;\n  };\n\n  Regions.numericalComparator = function (a, b) {\n    return a - b;\n  };\n\n  Regions.normalizeInterval = function (coord, coord2) {\n    if (coord2 == null) {\n      coord2 = coord;\n    }\n\n    var interval = [coord, coord2];\n    interval.sort(Regions.numericalComparator);\n    return interval;\n  };\n\n  return Regions;\n}();\n\nexport { Regions };\n\nfunction intervalInRangeInclusive(interval, minInclusive, maxInclusive) {\n  return inRangeInclusive(interval[0], minInclusive, maxInclusive) && inRangeInclusive(interval[1], minInclusive, maxInclusive);\n}\n\nfunction inRangeInclusive(value, minInclusive, maxInclusive) {\n  return value >= minInclusive && value <= maxInclusive;\n}","map":{"version":3,"sources":["../../src/regions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as Classes from \"./common/classes\";\nimport { Utils } from \"./common/utils\";\n/**\n * `Region`s contain sets of cells. Additionally, a distinction is drawn, for\n * example, between all cells within a column and the whole column itself.\n * The `RegionCardinality` enum represents these distinct types of `Region`s.\n */\nexport var RegionCardinality;\n(function (RegionCardinality) {\n    /**\n     * A region that contains a finite rectangular group of table cells\n     */\n    RegionCardinality[\"CELLS\"] = \"cells\";\n    /**\n     * A region that represents all cells within 1 or more rows.\n     */\n    RegionCardinality[\"FULL_ROWS\"] = \"full-rows\";\n    /**\n     * A region that represents all cells within 1 or more columns.\n     */\n    RegionCardinality[\"FULL_COLUMNS\"] = \"full-columns\";\n    /**\n     * A region that represents all cells in the table.\n     */\n    RegionCardinality[\"FULL_TABLE\"] = \"full-table\";\n})(RegionCardinality || (RegionCardinality = {}));\n/**\n * A convenience object for subsets of `RegionCardinality` that are commonly\n * used as the `selectionMode` prop of the `<Table>`.\n */\nexport var SelectionModes = {\n    ALL: [\n        RegionCardinality.FULL_TABLE,\n        RegionCardinality.FULL_COLUMNS,\n        RegionCardinality.FULL_ROWS,\n        RegionCardinality.CELLS,\n    ],\n    COLUMNS_AND_CELLS: [RegionCardinality.FULL_COLUMNS, RegionCardinality.CELLS],\n    COLUMNS_ONLY: [RegionCardinality.FULL_COLUMNS],\n    NONE: [],\n    ROWS_AND_CELLS: [RegionCardinality.FULL_ROWS, RegionCardinality.CELLS],\n    ROWS_ONLY: [RegionCardinality.FULL_ROWS],\n};\nexport var ColumnLoadingOption;\n(function (ColumnLoadingOption) {\n    ColumnLoadingOption[\"CELLS\"] = \"cells\";\n    ColumnLoadingOption[\"HEADER\"] = \"column-header\";\n})(ColumnLoadingOption || (ColumnLoadingOption = {}));\nexport var RowLoadingOption;\n(function (RowLoadingOption) {\n    RowLoadingOption[\"CELLS\"] = \"cells\";\n    RowLoadingOption[\"HEADER\"] = \"row-header\";\n})(RowLoadingOption || (RowLoadingOption = {}));\nexport var TableLoadingOption;\n(function (TableLoadingOption) {\n    TableLoadingOption[\"CELLS\"] = \"cells\";\n    TableLoadingOption[\"COLUMN_HEADERS\"] = \"column-header\";\n    TableLoadingOption[\"ROW_HEADERS\"] = \"row-header\";\n})(TableLoadingOption || (TableLoadingOption = {}));\nvar Regions = /** @class */ (function () {\n    function Regions() {\n    }\n    /**\n     * Determines the cardinality of a region. We use null values to indicate\n     * an unbounded interval. Therefore, an example of a region containing the\n     * second and third columns would be:\n     *\n     * ```js\n     * { rows: null, cols: [1, 2] }\n     * ```\n     *\n     * In this case, this method would return `RegionCardinality.FULL_COLUMNS`.\n     *\n     * If both rows and columns are unbounded, then the region covers the\n     * entire table. Therefore, a region like this:\n     *\n     * ```js\n     * { rows: null, cols: null }\n     * ```\n     *\n     * will return `RegionCardinality.FULL_TABLE`.\n     *\n     * An example of a region containing a single cell in the table would be:\n     *\n     * ```js\n     * { rows: [5, 5], cols: [2, 2] }\n     * ```\n     *\n     * In this case, this method would return `RegionCardinality.CELLS`.\n     */\n    Regions.getRegionCardinality = function (region) {\n        if (region.cols != null && region.rows != null) {\n            return RegionCardinality.CELLS;\n        }\n        else if (region.cols != null) {\n            return RegionCardinality.FULL_COLUMNS;\n        }\n        else if (region.rows != null) {\n            return RegionCardinality.FULL_ROWS;\n        }\n        else {\n            return RegionCardinality.FULL_TABLE;\n        }\n    };\n    Regions.getFocusCellCoordinatesFromRegion = function (region) {\n        var regionCardinality = Regions.getRegionCardinality(region);\n        switch (regionCardinality) {\n            case RegionCardinality.FULL_TABLE:\n                return { col: 0, row: 0 };\n            case RegionCardinality.FULL_COLUMNS:\n                return { col: region.cols[0], row: 0 };\n            case RegionCardinality.FULL_ROWS:\n                return { col: 0, row: region.rows[0] };\n            case RegionCardinality.CELLS:\n                return { col: region.cols[0], row: region.rows[0] };\n            default:\n                return null;\n        }\n    };\n    /**\n     * Returns a deep copy of the provided region.\n     */\n    Regions.copy = function (region) {\n        var cardinality = Regions.getRegionCardinality(region);\n        // we need to be careful not to explicitly spell out `rows: undefined`\n        // (e.g.) if the \"rows\" key is completely absent, otherwise\n        // deep-equality checks will fail.\n        if (cardinality === RegionCardinality.CELLS) {\n            return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);\n        }\n        else if (cardinality === RegionCardinality.FULL_COLUMNS) {\n            return Regions.column(region.cols[0], region.cols[1]);\n        }\n        else if (cardinality === RegionCardinality.FULL_ROWS) {\n            return Regions.row(region.rows[0], region.rows[1]);\n        }\n        else {\n            return Regions.table();\n        }\n    };\n    /**\n     * Returns a region containing one or more cells.\n     */\n    Regions.cell = function (row, col, row2, col2) {\n        return {\n            cols: this.normalizeInterval(col, col2),\n            rows: this.normalizeInterval(row, row2),\n        };\n    };\n    /**\n     * Returns a region containing one or more full rows.\n     */\n    Regions.row = function (row, row2) {\n        return { rows: this.normalizeInterval(row, row2) };\n    };\n    /**\n     * Returns a region containing one or more full columns.\n     */\n    Regions.column = function (col, col2) {\n        return { cols: this.normalizeInterval(col, col2) };\n    };\n    /**\n     * Returns a region containing the entire table.\n     */\n    Regions.table = function () {\n        return {};\n    };\n    /**\n     * Adds the region to the end of a cloned copy of the supplied region\n     * array.\n     */\n    Regions.add = function (regions, region) {\n        var copy = regions.slice();\n        copy.push(region);\n        return copy;\n    };\n    /**\n     * Replaces the region at the end of a cloned copy of the supplied region\n     * array, or at the specific index if one is provided.\n     */\n    Regions.update = function (regions, region, index) {\n        var copy = regions.slice();\n        if (index != null) {\n            copy.splice(index, 1, region);\n        }\n        else {\n            copy.pop();\n            copy.push(region);\n        }\n        return copy;\n    };\n    /**\n     * Clamps the region's start and end indices between 0 and the provided\n     * maximum values.\n     */\n    Regions.clampRegion = function (region, maxRowIndex, maxColumnIndex) {\n        var nextRegion = Regions.copy(region);\n        if (region.rows != null) {\n            nextRegion.rows[0] = Utils.clamp(region.rows[0], 0, maxRowIndex);\n            nextRegion.rows[1] = Utils.clamp(region.rows[1], 0, maxRowIndex);\n        }\n        if (region.cols != null) {\n            nextRegion.cols[0] = Utils.clamp(region.cols[0], 0, maxColumnIndex);\n            nextRegion.cols[1] = Utils.clamp(region.cols[1], 0, maxColumnIndex);\n        }\n        return nextRegion;\n    };\n    /**\n     * Returns true iff the specified region is equal to the last region in\n     * the region list. This allows us to avoid immediate additive re-selection.\n     */\n    Regions.lastRegionIsEqual = function (regions, region) {\n        if (regions == null || regions.length === 0) {\n            return false;\n        }\n        var lastRegion = regions[regions.length - 1];\n        return Regions.regionsEqual(lastRegion, region);\n    };\n    /**\n     * Returns the index of the region that is equal to the supplied\n     * parameter. Returns -1 if no such region is found.\n     */\n    Regions.findMatchingRegion = function (regions, region) {\n        if (regions == null) {\n            return -1;\n        }\n        for (var i = 0; i < regions.length; i++) {\n            if (Regions.regionsEqual(regions[i], region)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Returns the index of the region that wholly contains the supplied\n     * parameter. Returns -1 if no such region is found.\n     */\n    Regions.findContainingRegion = function (regions, region) {\n        if (regions == null) {\n            return -1;\n        }\n        for (var i = 0; i < regions.length; i++) {\n            if (Regions.regionContains(regions[i], region)) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    /**\n     * Returns true if the regions contain a region that has FULL_COLUMNS\n     * cardinality and contains the specified column index.\n     */\n    Regions.hasFullColumn = function (regions, col) {\n        if (regions == null) {\n            return false;\n        }\n        for (var _i = 0, regions_1 = regions; _i < regions_1.length; _i++) {\n            var region = regions_1[_i];\n            var cardinality = Regions.getRegionCardinality(region);\n            if (cardinality === RegionCardinality.FULL_TABLE) {\n                return true;\n            }\n            if (cardinality === RegionCardinality.FULL_COLUMNS && Regions.intervalContainsIndex(region.cols, col)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Returns true if the regions contain a region that has FULL_ROWS\n     * cardinality and contains the specified row index.\n     */\n    Regions.hasFullRow = function (regions, row) {\n        if (regions == null) {\n            return false;\n        }\n        for (var _i = 0, regions_2 = regions; _i < regions_2.length; _i++) {\n            var region = regions_2[_i];\n            var cardinality = Regions.getRegionCardinality(region);\n            if (cardinality === RegionCardinality.FULL_TABLE) {\n                return true;\n            }\n            if (cardinality === RegionCardinality.FULL_ROWS && Regions.intervalContainsIndex(region.rows, row)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Returns true if the regions contain a region that has FULL_TABLE cardinality\n     */\n    Regions.hasFullTable = function (regions) {\n        if (regions == null) {\n            return false;\n        }\n        for (var _i = 0, regions_3 = regions; _i < regions_3.length; _i++) {\n            var region = regions_3[_i];\n            var cardinality = Regions.getRegionCardinality(region);\n            if (cardinality === RegionCardinality.FULL_TABLE) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Returns true if the regions fully contain the query region.\n     */\n    Regions.containsRegion = function (regions, query) {\n        return Regions.overlapsRegion(regions, query, false);\n    };\n    /**\n     * Returns true if the regions at least partially overlap the query region.\n     */\n    Regions.overlapsRegion = function (regions, query, allowPartialOverlap) {\n        if (allowPartialOverlap === void 0) { allowPartialOverlap = false; }\n        var intervalCompareFn = allowPartialOverlap ? Regions.intervalOverlaps : Regions.intervalContains;\n        if (regions == null || query == null) {\n            return false;\n        }\n        for (var _i = 0, regions_4 = regions; _i < regions_4.length; _i++) {\n            var region = regions_4[_i];\n            var cardinality = Regions.getRegionCardinality(region);\n            switch (cardinality) {\n                case RegionCardinality.FULL_TABLE:\n                    return true;\n                case RegionCardinality.FULL_COLUMNS:\n                    if (intervalCompareFn(region.cols, query.cols)) {\n                        return true;\n                    }\n                    continue;\n                case RegionCardinality.FULL_ROWS:\n                    if (intervalCompareFn(region.rows, query.rows)) {\n                        return true;\n                    }\n                    continue;\n                case RegionCardinality.CELLS:\n                    if (intervalCompareFn(region.cols, query.cols) && intervalCompareFn(region.rows, query.rows)) {\n                        return true;\n                    }\n                    continue;\n                default:\n                    break;\n            }\n        }\n        return false;\n    };\n    Regions.eachUniqueFullColumn = function (regions, iteratee) {\n        if (regions == null || regions.length === 0 || iteratee == null) {\n            return;\n        }\n        var seen = {};\n        regions.forEach(function (region) {\n            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_COLUMNS) {\n                var _a = region.cols, start = _a[0], end = _a[1];\n                for (var col = start; col <= end; col++) {\n                    if (!seen[col]) {\n                        seen[col] = true;\n                        iteratee(col);\n                    }\n                }\n            }\n        });\n    };\n    Regions.eachUniqueFullRow = function (regions, iteratee) {\n        if (regions == null || regions.length === 0 || iteratee == null) {\n            return;\n        }\n        var seen = {};\n        regions.forEach(function (region) {\n            if (Regions.getRegionCardinality(region) === RegionCardinality.FULL_ROWS) {\n                var _a = region.rows, start = _a[0], end = _a[1];\n                for (var row = start; row <= end; row++) {\n                    if (!seen[row]) {\n                        seen[row] = true;\n                        iteratee(row);\n                    }\n                }\n            }\n        });\n    };\n    /**\n     * Using the supplied array of non-contiguous `IRegion`s, this method\n     * returns an ordered array of every unique cell that exists in those\n     * regions.\n     */\n    Regions.enumerateUniqueCells = function (regions, numRows, numCols) {\n        if (regions == null || regions.length === 0) {\n            return [];\n        }\n        var seen = {};\n        var list = [];\n        for (var _i = 0, regions_5 = regions; _i < regions_5.length; _i++) {\n            var region = regions_5[_i];\n            Regions.eachCellInRegion(region, numRows, numCols, function (row, col) {\n                // add to list if not seen\n                var key = row + \"-\" + col;\n                if (seen[key] !== true) {\n                    seen[key] = true;\n                    list.push([row, col]);\n                }\n            });\n        }\n        // sort list by rows then columns\n        list.sort(Regions.rowFirstComparator);\n        return list;\n    };\n    /**\n     * Using the supplied region, returns an \"equivalent\" region of\n     * type CELLS that define the bounds of the given region\n     */\n    Regions.getCellRegionFromRegion = function (region, numRows, numCols) {\n        var regionCardinality = Regions.getRegionCardinality(region);\n        switch (regionCardinality) {\n            case RegionCardinality.FULL_TABLE:\n                return Regions.cell(0, 0, numRows - 1, numCols - 1);\n            case RegionCardinality.FULL_COLUMNS:\n                return Regions.cell(0, region.cols[0], numRows - 1, region.cols[1]);\n            case RegionCardinality.FULL_ROWS:\n                return Regions.cell(region.rows[0], 0, region.rows[1], numCols - 1);\n            case RegionCardinality.CELLS:\n                return Regions.cell(region.rows[0], region.cols[0], region.rows[1], region.cols[1]);\n            default:\n                return null;\n        }\n    };\n    /**\n     * Maps a dense array of cell coordinates to a sparse 2-dimensional array\n     * of cell values.\n     *\n     * We create a new 2-dimensional array representing the smallest single\n     * contiguous `IRegion` that contains all cells in the supplied array. We\n     * invoke the mapper callback only on the cells in the supplied coordinate\n     * array and store the result. Returns the resulting 2-dimensional array.\n     */\n    Regions.sparseMapCells = function (cells, mapper) {\n        var bounds = Regions.getBoundingRegion(cells);\n        if (bounds == null) {\n            return null;\n        }\n        var numRows = bounds.rows[1] + 1 - bounds.rows[0];\n        var numCols = bounds.cols[1] + 1 - bounds.cols[0];\n        var result = Utils.times(numRows, function () { return new Array(numCols); });\n        cells.forEach(function (_a) {\n            var row = _a[0], col = _a[1];\n            result[row - bounds.rows[0]][col - bounds.cols[0]] = mapper(row, col);\n        });\n        return result;\n    };\n    /**\n     * Returns the smallest single contiguous `IRegion` that contains all cells in the\n     * supplied array.\n     */\n    Regions.getBoundingRegion = function (cells) {\n        var minRow;\n        var maxRow;\n        var minCol;\n        var maxCol;\n        for (var _i = 0, cells_1 = cells; _i < cells_1.length; _i++) {\n            var _a = cells_1[_i], row = _a[0], col = _a[1];\n            minRow = minRow == null || row < minRow ? row : minRow;\n            maxRow = maxRow == null || row > maxRow ? row : maxRow;\n            minCol = minCol == null || col < minCol ? col : minCol;\n            maxCol = maxCol == null || col > maxCol ? col : maxCol;\n        }\n        if (minRow == null) {\n            return null;\n        }\n        return {\n            cols: [minCol, maxCol],\n            rows: [minRow, maxRow],\n        };\n    };\n    Regions.isValid = function (region) {\n        if (region == null) {\n            return false;\n        }\n        if (region.rows != null && (region.rows[0] < 0 || region.rows[1] < 0)) {\n            return false;\n        }\n        if (region.cols != null && (region.cols[0] < 0 || region.cols[1] < 0)) {\n            return false;\n        }\n        return true;\n    };\n    Regions.isRegionValidForTable = function (region, numRows, numCols) {\n        if (numRows === 0 || numCols === 0) {\n            return false;\n        }\n        else if (region.rows != null && !intervalInRangeInclusive(region.rows, 0, numRows - 1)) {\n            return false;\n        }\n        else if (region.cols != null && !intervalInRangeInclusive(region.cols, 0, numCols - 1)) {\n            return false;\n        }\n        return true;\n    };\n    Regions.joinStyledRegionGroups = function (selectedRegions, otherRegions, focusedCell) {\n        var regionGroups = [];\n        if (otherRegions != null) {\n            regionGroups = regionGroups.concat(otherRegions);\n        }\n        if (selectedRegions != null && selectedRegions.length > 0) {\n            regionGroups.push({\n                className: Classes.TABLE_SELECTION_REGION,\n                regions: selectedRegions,\n            });\n        }\n        if (focusedCell != null) {\n            regionGroups.push({\n                className: Classes.TABLE_FOCUS_REGION,\n                regions: [Regions.cell(focusedCell.row, focusedCell.col)],\n            });\n        }\n        return regionGroups;\n    };\n    Regions.regionsEqual = function (regionA, regionB) {\n        return Regions.intervalsEqual(regionA.rows, regionB.rows) && Regions.intervalsEqual(regionA.cols, regionB.cols);\n    };\n    /**\n     * Expands an old region to the minimal bounding region that also contains\n     * the new region. If the regions have different cardinalities, then the new\n     * region is returned. Useful for expanding a selected region on\n     * shift+click, for instance.\n     */\n    Regions.expandRegion = function (oldRegion, newRegion) {\n        var oldRegionCardinality = Regions.getRegionCardinality(oldRegion);\n        var newRegionCardinality = Regions.getRegionCardinality(newRegion);\n        if (newRegionCardinality !== oldRegionCardinality) {\n            return newRegion;\n        }\n        switch (newRegionCardinality) {\n            case RegionCardinality.FULL_ROWS: {\n                var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);\n                var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);\n                return Regions.row(rowStart, rowEnd);\n            }\n            case RegionCardinality.FULL_COLUMNS: {\n                var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);\n                var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);\n                return Regions.column(colStart, colEnd);\n            }\n            case RegionCardinality.CELLS: {\n                var rowStart = Math.min(oldRegion.rows[0], newRegion.rows[0]);\n                var colStart = Math.min(oldRegion.cols[0], newRegion.cols[0]);\n                var rowEnd = Math.max(oldRegion.rows[1], newRegion.rows[1]);\n                var colEnd = Math.max(oldRegion.cols[1], newRegion.cols[1]);\n                return Regions.cell(rowStart, colStart, rowEnd, colEnd);\n            }\n            default:\n                return Regions.table();\n        }\n    };\n    /**\n     * Iterates over the cells within an `IRegion`, invoking the callback with\n     * each cell's coordinates.\n     */\n    Regions.eachCellInRegion = function (region, numRows, numCols, iteratee) {\n        var cardinality = Regions.getRegionCardinality(region);\n        switch (cardinality) {\n            case RegionCardinality.FULL_TABLE:\n                for (var row = 0; row < numRows; row++) {\n                    for (var col = 0; col < numCols; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            case RegionCardinality.FULL_COLUMNS:\n                for (var row = 0; row < numRows; row++) {\n                    for (var col = region.cols[0]; col <= region.cols[1]; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            case RegionCardinality.FULL_ROWS:\n                for (var row = region.rows[0]; row <= region.rows[1]; row++) {\n                    for (var col = 0; col < numCols; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            case RegionCardinality.CELLS:\n                for (var row = region.rows[0]; row <= region.rows[1]; row++) {\n                    for (var col = region.cols[0]; col <= region.cols[1]; col++) {\n                        iteratee(row, col);\n                    }\n                }\n                break;\n            default:\n                break;\n        }\n    };\n    Regions.regionContains = function (regionA, regionB) {\n        // containsRegion expects an array of regions as the first param\n        return Regions.overlapsRegion([regionA], regionB, false);\n    };\n    Regions.intervalsEqual = function (ivalA, ivalB) {\n        if (ivalA == null) {\n            return ivalB == null;\n        }\n        else if (ivalB == null) {\n            return false;\n        }\n        else {\n            return ivalA[0] === ivalB[0] && ivalA[1] === ivalB[1];\n        }\n    };\n    Regions.intervalContainsIndex = function (interval, index) {\n        if (interval == null) {\n            return false;\n        }\n        return interval[0] <= index && interval[1] >= index;\n    };\n    Regions.intervalContains = function (ivalA, ivalB) {\n        if (ivalA == null || ivalB == null) {\n            return false;\n        }\n        return ivalA[0] <= ivalB[0] && ivalB[1] <= ivalA[1];\n    };\n    Regions.intervalOverlaps = function (ivalA, ivalB) {\n        if (ivalA == null || ivalB == null) {\n            return false;\n        }\n        if (ivalA[1] < ivalB[0] || ivalA[0] > ivalB[1]) {\n            return false;\n        }\n        return true;\n    };\n    Regions.rowFirstComparator = function (a, b) {\n        var rowDiff = a[0] - b[0];\n        return rowDiff === 0 ? a[1] - b[1] : rowDiff;\n    };\n    Regions.numericalComparator = function (a, b) {\n        return a - b;\n    };\n    Regions.normalizeInterval = function (coord, coord2) {\n        if (coord2 == null) {\n            coord2 = coord;\n        }\n        var interval = [coord, coord2];\n        interval.sort(Regions.numericalComparator);\n        return interval;\n    };\n    return Regions;\n}());\nexport { Regions };\nfunction intervalInRangeInclusive(interval, minInclusive, maxInclusive) {\n    return (inRangeInclusive(interval[0], minInclusive, maxInclusive) &&\n        inRangeInclusive(interval[1], minInclusive, maxInclusive));\n}\nfunction inRangeInclusive(value, minInclusive, maxInclusive) {\n    return value >= minInclusive && value <= maxInclusive;\n}\n//# sourceMappingURL=regions.js.map"]},"metadata":{},"sourceType":"module"}