{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { DISPLAYNAME_PREFIX, EditableText, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as Classes from \"../common/classes\";\nimport { Draggable } from \"../interactions/draggable\";\nimport { Cell } from \"./cell\"; // HACKHACK(adahiya): fix for Blueprint 4.0\n// eslint-disable-next-line deprecation/deprecation\n\nvar EditableCell =\n/** @class */\nfunction (_super) {\n  __extends(EditableCell, _super);\n\n  function EditableCell(props, context) {\n    var _this = _super.call(this, props, context) || this;\n\n    _this.refHandlers = {\n      cell: function (ref) {\n        _this.cellRef = ref;\n      }\n    };\n\n    _this.handleKeyPress = function () {\n      if (_this.state.isEditing || !_this.props.isFocused) {\n        return;\n      } // setting dirty value to empty string because apparently the text field will pick up the key and write it in there\n\n\n      _this.setState({\n        isEditing: true,\n        dirtyValue: \"\",\n        savedValue: _this.state.savedValue\n      });\n    };\n\n    _this.handleEdit = function () {\n      _this.setState({\n        isEditing: true,\n        dirtyValue: _this.state.savedValue\n      });\n    };\n\n    _this.handleCancel = function (value) {\n      // don't strictly need to clear the dirtyValue, but it's better hygiene\n      _this.setState({\n        isEditing: false,\n        dirtyValue: undefined\n      });\n\n      _this.invokeCallback(_this.props.onCancel, value);\n    };\n\n    _this.handleChange = function (value) {\n      _this.setState({\n        dirtyValue: value\n      });\n\n      _this.invokeCallback(_this.props.onChange, value);\n    };\n\n    _this.handleConfirm = function (value) {\n      _this.setState({\n        isEditing: false,\n        savedValue: value,\n        dirtyValue: undefined\n      });\n\n      _this.invokeCallback(_this.props.onConfirm, value);\n    };\n\n    _this.handleCellActivate = function (_event) {\n      return true;\n    };\n\n    _this.handleCellDoubleClick = function (_event) {\n      _this.handleEdit();\n    };\n\n    _this.state = {\n      isEditing: false,\n      savedValue: props.value\n    };\n    return _this;\n  }\n\n  EditableCell.prototype.componentDidMount = function () {\n    this.checkShouldFocus();\n  };\n\n  EditableCell.prototype.componentDidUpdate = function (prevProps) {\n    var didPropsChange = !CoreUtils.shallowCompareKeys(this.props, prevProps, {\n      exclude: [\"style\"]\n    }) || !CoreUtils.deepCompareKeys(this.props, prevProps, [\"style\"]);\n    var value = this.props.value;\n\n    if (didPropsChange && value != null) {\n      this.setState({\n        savedValue: value,\n        dirtyValue: value\n      });\n    }\n\n    this.checkShouldFocus();\n  };\n\n  EditableCell.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n    return !CoreUtils.shallowCompareKeys(this.props, nextProps, {\n      exclude: [\"style\"]\n    }) || !CoreUtils.shallowCompareKeys(this.state, nextState) || !CoreUtils.deepCompareKeys(this.props, nextProps, [\"style\"]);\n  };\n\n  EditableCell.prototype.render = function () {\n    var _a;\n\n    var _b = this.props,\n        onCancel = _b.onCancel,\n        onChange = _b.onChange,\n        onConfirm = _b.onConfirm,\n        truncated = _b.truncated,\n        wrapText = _b.wrapText,\n        editableTextProps = _b.editableTextProps,\n        spreadableProps = __rest(_b, [\"onCancel\", \"onChange\", \"onConfirm\", \"truncated\", \"wrapText\", \"editableTextProps\"]);\n\n    var _c = this.state,\n        isEditing = _c.isEditing,\n        dirtyValue = _c.dirtyValue,\n        savedValue = _c.savedValue;\n    var interactive = spreadableProps.interactive || isEditing;\n    var cellContents = null;\n\n    if (isEditing) {\n      var className = editableTextProps ? editableTextProps.className : null;\n      cellContents = React.createElement(EditableText, __assign({}, editableTextProps, {\n        isEditing: true,\n        className: classNames(Classes.TABLE_EDITABLE_TEXT, Classes.TABLE_EDITABLE_NAME, className),\n        intent: spreadableProps.intent,\n        minWidth: null,\n        onCancel: this.handleCancel,\n        onChange: this.handleChange,\n        onConfirm: this.handleConfirm,\n        onEdit: this.handleEdit,\n        placeholder: \"\",\n        selectAllOnFocus: false,\n        value: dirtyValue\n      }));\n    } else {\n      var textClasses = classNames(Classes.TABLE_EDITABLE_TEXT, (_a = {}, _a[Classes.TABLE_TRUNCATED_TEXT] = truncated, _a[Classes.TABLE_NO_WRAP_TEXT] = !wrapText, _a));\n      cellContents = React.createElement(\"div\", {\n        className: textClasses\n      }, savedValue);\n    }\n\n    return React.createElement(Cell, __assign({}, spreadableProps, {\n      wrapText: wrapText,\n      truncated: false,\n      interactive: interactive,\n      cellRef: this.refHandlers.cell,\n      onKeyPress: this.handleKeyPress\n    }), React.createElement(Draggable, {\n      onActivate: this.handleCellActivate,\n      onDoubleClick: this.handleCellDoubleClick,\n      preventDefault: false,\n      stopPropagation: interactive\n    }, cellContents));\n  };\n\n  EditableCell.prototype.renderHotkeys = function () {\n    var tabIndex = this.props.tabIndex;\n    return React.createElement(Hotkeys, {\n      tabIndex: tabIndex\n    }, React.createElement(Hotkey, {\n      key: \"edit-cell\",\n      label: \"Edit the currently focused cell\",\n      group: \"Table\",\n      combo: \"f2\",\n      onKeyDown: this.handleEdit\n    }));\n  };\n\n  EditableCell.prototype.checkShouldFocus = function () {\n    if (this.props.isFocused && !this.state.isEditing) {\n      // don't focus if we're editing -- we'll lose the fact that we're editing\n      this.cellRef.focus();\n    }\n  };\n\n  EditableCell.prototype.invokeCallback = function (callback, value) {\n    // pass through the row and column indices if they were provided as props by the consumer\n    var _a = this.props,\n        rowIndex = _a.rowIndex,\n        columnIndex = _a.columnIndex;\n    callback === null || callback === void 0 ? void 0 : callback(value, rowIndex, columnIndex);\n  };\n\n  EditableCell.displayName = DISPLAYNAME_PREFIX + \".EditableCell\";\n  EditableCell.defaultProps = {\n    truncated: true,\n    wrapText: false\n  };\n  EditableCell = __decorate([HotkeysTarget], EditableCell);\n  return EditableCell;\n}(React.Component);\n\nexport { EditableCell };","map":{"version":3,"sources":["../../../src/cell/editableCell.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends, __rest } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { DISPLAYNAME_PREFIX, EditableText, Hotkey, Hotkeys, HotkeysTarget, Utils as CoreUtils, } from \"@blueprintjs/core\";\nimport * as Classes from \"../common/classes\";\nimport { Draggable } from \"../interactions/draggable\";\nimport { Cell } from \"./cell\";\n// HACKHACK(adahiya): fix for Blueprint 4.0\n// eslint-disable-next-line deprecation/deprecation\nvar EditableCell = /** @class */ (function (_super) {\n    __extends(EditableCell, _super);\n    function EditableCell(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.refHandlers = {\n            cell: function (ref) {\n                _this.cellRef = ref;\n            },\n        };\n        _this.handleKeyPress = function () {\n            if (_this.state.isEditing || !_this.props.isFocused) {\n                return;\n            }\n            // setting dirty value to empty string because apparently the text field will pick up the key and write it in there\n            _this.setState({ isEditing: true, dirtyValue: \"\", savedValue: _this.state.savedValue });\n        };\n        _this.handleEdit = function () {\n            _this.setState({ isEditing: true, dirtyValue: _this.state.savedValue });\n        };\n        _this.handleCancel = function (value) {\n            // don't strictly need to clear the dirtyValue, but it's better hygiene\n            _this.setState({ isEditing: false, dirtyValue: undefined });\n            _this.invokeCallback(_this.props.onCancel, value);\n        };\n        _this.handleChange = function (value) {\n            _this.setState({ dirtyValue: value });\n            _this.invokeCallback(_this.props.onChange, value);\n        };\n        _this.handleConfirm = function (value) {\n            _this.setState({ isEditing: false, savedValue: value, dirtyValue: undefined });\n            _this.invokeCallback(_this.props.onConfirm, value);\n        };\n        _this.handleCellActivate = function (_event) {\n            return true;\n        };\n        _this.handleCellDoubleClick = function (_event) {\n            _this.handleEdit();\n        };\n        _this.state = {\n            isEditing: false,\n            savedValue: props.value,\n        };\n        return _this;\n    }\n    EditableCell.prototype.componentDidMount = function () {\n        this.checkShouldFocus();\n    };\n    EditableCell.prototype.componentDidUpdate = function (prevProps) {\n        var didPropsChange = !CoreUtils.shallowCompareKeys(this.props, prevProps, { exclude: [\"style\"] }) ||\n            !CoreUtils.deepCompareKeys(this.props, prevProps, [\"style\"]);\n        var value = this.props.value;\n        if (didPropsChange && value != null) {\n            this.setState({ savedValue: value, dirtyValue: value });\n        }\n        this.checkShouldFocus();\n    };\n    EditableCell.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n        return (!CoreUtils.shallowCompareKeys(this.props, nextProps, { exclude: [\"style\"] }) ||\n            !CoreUtils.shallowCompareKeys(this.state, nextState) ||\n            !CoreUtils.deepCompareKeys(this.props, nextProps, [\"style\"]));\n    };\n    EditableCell.prototype.render = function () {\n        var _a;\n        var _b = this.props, onCancel = _b.onCancel, onChange = _b.onChange, onConfirm = _b.onConfirm, truncated = _b.truncated, wrapText = _b.wrapText, editableTextProps = _b.editableTextProps, spreadableProps = __rest(_b, [\"onCancel\", \"onChange\", \"onConfirm\", \"truncated\", \"wrapText\", \"editableTextProps\"]);\n        var _c = this.state, isEditing = _c.isEditing, dirtyValue = _c.dirtyValue, savedValue = _c.savedValue;\n        var interactive = spreadableProps.interactive || isEditing;\n        var cellContents = null;\n        if (isEditing) {\n            var className = editableTextProps ? editableTextProps.className : null;\n            cellContents = (React.createElement(EditableText, __assign({}, editableTextProps, { isEditing: true, className: classNames(Classes.TABLE_EDITABLE_TEXT, Classes.TABLE_EDITABLE_NAME, className), intent: spreadableProps.intent, minWidth: null, onCancel: this.handleCancel, onChange: this.handleChange, onConfirm: this.handleConfirm, onEdit: this.handleEdit, placeholder: \"\", selectAllOnFocus: false, value: dirtyValue })));\n        }\n        else {\n            var textClasses = classNames(Classes.TABLE_EDITABLE_TEXT, (_a = {},\n                _a[Classes.TABLE_TRUNCATED_TEXT] = truncated,\n                _a[Classes.TABLE_NO_WRAP_TEXT] = !wrapText,\n                _a));\n            cellContents = React.createElement(\"div\", { className: textClasses }, savedValue);\n        }\n        return (React.createElement(Cell, __assign({}, spreadableProps, { wrapText: wrapText, truncated: false, interactive: interactive, cellRef: this.refHandlers.cell, onKeyPress: this.handleKeyPress }),\n            React.createElement(Draggable, { onActivate: this.handleCellActivate, onDoubleClick: this.handleCellDoubleClick, preventDefault: false, stopPropagation: interactive }, cellContents)));\n    };\n    EditableCell.prototype.renderHotkeys = function () {\n        var tabIndex = this.props.tabIndex;\n        return (React.createElement(Hotkeys, { tabIndex: tabIndex },\n            React.createElement(Hotkey, { key: \"edit-cell\", label: \"Edit the currently focused cell\", group: \"Table\", combo: \"f2\", onKeyDown: this.handleEdit })));\n    };\n    EditableCell.prototype.checkShouldFocus = function () {\n        if (this.props.isFocused && !this.state.isEditing) {\n            // don't focus if we're editing -- we'll lose the fact that we're editing\n            this.cellRef.focus();\n        }\n    };\n    EditableCell.prototype.invokeCallback = function (callback, value) {\n        // pass through the row and column indices if they were provided as props by the consumer\n        var _a = this.props, rowIndex = _a.rowIndex, columnIndex = _a.columnIndex;\n        callback === null || callback === void 0 ? void 0 : callback(value, rowIndex, columnIndex);\n    };\n    EditableCell.displayName = DISPLAYNAME_PREFIX + \".EditableCell\";\n    EditableCell.defaultProps = {\n        truncated: true,\n        wrapText: false,\n    };\n    EditableCell = __decorate([\n        HotkeysTarget\n    ], EditableCell);\n    return EditableCell;\n}(React.Component));\nexport { EditableCell };\n//# sourceMappingURL=editableCell.js.map"]},"metadata":{},"sourceType":"module"}