{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes, refHandler } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\n\nvar Popover =\n/** @class */\nfunction (_super) {\n  __extends(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.popoverRef = Utils.createReactRef();\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props),\n      transformOrigin: \"\"\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n    _this.handlePopoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n\n    _this.handleTargetRef = function (ref) {\n      return _this.targetElement = ref;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b = _this.props,\n          usePortal = _b.usePortal,\n          interactionKind = _b.interactionKind;\n      var transformOrigin = _this.state.transformOrigin; // Need to update our reference to this on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.scheduleUpdate;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick\n      };\n\n      if (interactionKind === PopoverInteractionKind.HOVER || !usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var popoverClasses = classNames(Classes.POPOVER, (_a = {}, _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[Classes.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss, _a), _this.props.popoverClassName);\n      return React.createElement(\"div\", {\n        className: Classes.TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(PopoverArrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER_CONTENT\n      }, _this.understandChildren().content))));\n    };\n\n    _this.renderTarget = function (referenceProps) {\n      var _a, _b;\n\n      var _c = _this.props,\n          fill = _c.fill,\n          openOnTargetFocus = _c.openOnTargetFocus,\n          targetClassName = _c.targetClassName,\n          _d = _c.targetProps,\n          targetProps = _d === void 0 ? {} : _d;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      var finalTargetProps = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick\n      };\n      finalTargetProps.className = classNames(Classes.POPOVER_TARGET, (_a = {}, _a[Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\n      finalTargetProps.ref = referenceProps.ref;\n      var rawTarget = Utils.ensureElement(_this.understandChildren().target);\n\n      if (rawTarget === undefined) {\n        return null;\n      }\n\n      var rawTabIndex = rawTarget.props.tabIndex; // ensure target is focusable if relevant prop enabled\n\n      var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n      var clonedTarget = React.cloneElement(rawTarget, {\n        className: classNames(rawTarget.props.className, (_b = {}, // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n        // when they are opened by a user interaction\n        _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, _b)),\n        // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n\n        /* eslint-disable-next-line deprecation/deprecation */\n        disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n        tabIndex: tabIndex\n      });\n      var target = React.createElement(targetTagName, __assign(__assign({}, targetProps), finalTargetProps), clonedTarget);\n      return React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    };\n\n    _this.handleTargetFocus = function (e) {\n      var _a, _b;\n\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleTargetBlur = function (e) {\n      var _a, _b;\n\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        // if the next element to receive focus is within the popover, we'll want to leave the\n        // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n        // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n        // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n        // close the popover if necessary.\n        if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n          _this.handleMouseLeave(e);\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleMouseEnter = function (e) {\n      var _a, _b;\n\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handleMouseLeave = function (e) {\n      var _a, _b;\n\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\" + Classes.POPOVER);\n      var isEventFromSelf = eventPopover === _this.popoverRef.current;\n      var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS); // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\" + Classes.POPOVER_DISMISS + \", .\" + Classes.POPOVER_DISMISS_OVERRIDE);\n      var shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n      var isDisabled = eventTarget.closest(\":disabled, .\" + Classes.DISABLED) != null;\n\n      if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      var _a, _b; // ensure click did not originate from within inline popover before closing\n\n\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n\n      (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n    };\n    /** Popper modifier that updates React state (for style properties) based on latest data. */\n\n\n    _this.updatePopoverState = function (data) {\n      // always set string; let shouldComponentUpdate determine if update is necessary\n      _this.setState({\n        transformOrigin: getTransformOrigin(data)\n      });\n\n      return data;\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var _a; // rename wrapper tag to begin with uppercase letter so it's recognized\n    // as JSX component instead of intrinsic element. but because of its\n    // type, tsc actually recognizes that it is _any_ intrinsic element, so\n    // it can typecheck the HTML props!!\n\n\n    var _b = this.props,\n        className = _b.className,\n        disabled = _b.disabled,\n        fill = _b.fill,\n        placement = _b.placement;\n    var isOpen = this.state.isOpen;\n    var wrapperTagName = this.props.wrapperTagName;\n\n    if (fill) {\n      wrapperTagName = \"div\";\n    }\n\n    var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null; // need to do this check in render(), because `isOpen` is derived from\n    // state, and state can't necessarily be accessed in validateProps.\n\n    if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n      console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n    }\n\n    var wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, (_a = {}, _a[Classes.FILL] = fill, _a));\n    var wrapper = React.createElement(wrapperTagName, {\n      className: wrapperClasses\n    }, React.createElement(Reference, {\n      innerRef: this.handleTargetRef\n    }, this.renderTarget), React.createElement(Overlay, {\n      autoFocus: this.props.autoFocus,\n      backdropClassName: Classes.POPOVER_BACKDROP,\n      backdropProps: this.props.backdropProps,\n      canEscapeKeyClose: this.props.canEscapeKeyClose,\n      canOutsideClickClose: this.props.interactionKind === PopoverInteractionKind.CLICK,\n      className: this.props.portalClassName,\n      enforceFocus: this.props.enforceFocus,\n      hasBackdrop: this.props.hasBackdrop,\n      isOpen: isOpen && !isContentEmpty,\n      onClose: this.handleOverlayClose,\n      onClosed: this.props.onClosed,\n      onClosing: this.props.onClosing,\n      onOpened: this.props.onOpened,\n      onOpening: this.props.onOpening,\n      transitionDuration: this.props.transitionDuration,\n      transitionName: Classes.POPOVER,\n      usePortal: this.props.usePortal,\n      portalContainer: this.props.portalContainer\n    }, React.createElement(Popper, {\n      innerRef: this.handlePopoverRef,\n      // eslint-disable-next-line deprecation/deprecation\n      placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(this.props.position),\n      modifiers: this.getPopperModifiers()\n    }, this.renderPopover)));\n    return React.createElement(Manager, null, wrapper);\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n      console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasContentProp = props.content !== undefined;\n    var hasTargetProp = props.target !== undefined;\n\n    if (childrenCount === 0 && !hasTargetProp) {\n      console.error(Errors.POPOVER_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 2) {\n      console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasTargetProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n    }\n\n    if (childrenCount === 2 && hasContentProp) {\n      console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n    }\n  };\n\n  Popover.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + Classes.DARK) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  }; // content and target can be specified as props or as children. this method\n  // normalizes the two approaches, preferring child over prop.\n\n\n  Popover.prototype.understandChildren = function () {\n    var _a = this.props,\n        children = _a.children,\n        contentProp = _a.content,\n        targetProp = _a.target; // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n\n    var _b = React.Children.toArray(children),\n        targetChild = _b[0],\n        contentChild = _b[1];\n\n    return {\n      content: contentChild == null ? contentProp : contentChild,\n      target: targetChild == null ? targetProp : targetChild\n    };\n  };\n\n  Popover.prototype.getIsOpen = function (props) {\n    // disabled popovers should never be allowed to open.\n    if (props.disabled) {\n      return false;\n    } else if (props.isOpen != null) {\n      return props.isOpen;\n    } else {\n      return props.defaultIsOpen;\n    }\n  };\n\n  Popover.prototype.getPopperModifiers = function () {\n    var _a = this.props,\n        boundary = _a.boundary,\n        modifiers = _a.modifiers;\n    var _b = modifiers,\n        _c = _b.flip,\n        flip = _c === void 0 ? {} : _c,\n        _d = _b.preventOverflow,\n        preventOverflow = _d === void 0 ? {} : _d;\n    return __assign(__assign({}, modifiers), {\n      arrowOffset: {\n        enabled: this.isArrowEnabled(),\n        fn: arrowOffsetModifier,\n        order: 510\n      },\n      flip: __assign({\n        boundariesElement: boundary\n      }, flip),\n      preventOverflow: __assign({\n        boundariesElement: boundary\n      }, preventOverflow),\n      updatePopoverState: {\n        enabled: true,\n        fn: this.updatePopoverState,\n        order: 900\n      }\n    });\n  }; // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover.prototype.isArrowEnabled = function () {\n    var _a = this.props,\n        minimal = _a.minimal,\n        modifiers = _a.modifiers; // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n\n    return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\n  };\n\n  Popover.prototype.isElementInPopover = function (element) {\n    return this.popoverElement != null && this.popoverElement.contains(element);\n  };\n\n  Popover.prototype.isHoverInteractionKind = function () {\n    return this.props.interactionKind === PopoverInteractionKind.HOVER || this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY;\n  };\n\n  Popover.displayName = DISPLAYNAME_PREFIX + \".Popover\";\n  Popover.defaultProps = {\n    boundary: \"scrollParent\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: PopoverInteractionKind.CLICK,\n    minimal: false,\n    modifiers: {},\n    openOnTargetFocus: true,\n    // N.B. we don't set a default for `placement` here because that would override\n    // the deprecated `position` prop\n    position: \"auto\",\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true,\n    wrapperTagName: \"span\"\n  };\n  Popover = __decorate([polyfill], Popover);\n  return Popover;\n}(AbstractPureComponent2);\n\nexport { Popover };","map":{"version":3,"sources":["../../../../src/components/popover/popover.tsx"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;AAEH,OAAO,UAAP,MAAuB,YAAvB;AAEA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,QAAT,QAAyB,yBAAzB;AACA,SAAS,OAAT,EAAkB,MAAlB,EAA+C,SAA/C,QAAwF,cAAxF;AAEA,SAAS,sBAAT,EAAiC,OAAjC,EAAgD,UAAhD,QAAkE,cAAlE;AACA,OAAO,KAAK,MAAZ,MAAwB,qBAAxB;AACA,SAAS,kBAAT,QAAiD,oBAAjD;AACA,OAAO,KAAK,KAAZ,MAAuB,oBAAvB;AACA,SAAS,OAAT,QAAwB,oBAAxB;AACA,SAAS,YAAT,QAA6B,+BAA7B,C,CACA;;AACA,SAAS,OAAT,QAAwB,oBAAxB;AACA,SAAS,YAAT,QAA6B,gBAA7B;AACA,SAAS,mBAAT,QAAoC,yBAApC;AAEA,SAAS,mBAAT,EAA8B,kBAA9B,QAAwD,eAAxD;AAEA,OAAO,IAAM,sBAAsB,GAAG;AAClC,EAAA,KAAK,EAAE,OAD2B;AAElC,EAAA,iBAAiB,EAAE,cAFe;AAGlC,EAAA,KAAK,EAAE,OAH2B;AAIlC,EAAA,iBAAiB,EAAE;AAJe,CAA/B;AA8DP;;AAEA,IAAA,OAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA6B,EAAA,SAAA,CAAA,OAAA,EAAA,MAAA,CAAA;;AAA7B,WAAA,OAAA,GAAA;AAAA,QAAA,KAAA,GAAA,MAAA,KAAA,IAAA,IAAA,MAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,IAAA,IAAA;;AAGY,IAAA,KAAA,CAAA,UAAA,GAAa,KAAK,CAAC,cAAN,EAAb;AAyBR;;;;AAIG;;AACI,IAAA,KAAA,CAAA,cAAA,GAAqC,IAArC;AAEP;;AACO,IAAA,KAAA,CAAA,aAAA,GAAoC,IAApC;AAEA,IAAA,KAAA,CAAA,KAAA,GAAuB;AAC1B,MAAA,aAAa,EAAE,KADW;AAE1B,MAAA,MAAM,EAAE,KAAI,CAAC,SAAL,CAAe,KAAI,CAAC,KAApB,CAFkB;AAG1B,MAAA,eAAe,EAAE;AAHS,KAAvB,CAtCX,CA8CI;AACA;;AACQ,IAAA,KAAA,CAAA,wBAAA,GAA2B,KAA3B,CAhDZ,CAkDI;AACA;;AACQ,IAAA,KAAA,CAAA,mBAAA,GAAsB,IAAtB;AAKA,IAAA,KAAA,CAAA,gBAAA,GAAsC,UAAU,CAAC,KAAD,EAAO,gBAAP,EAAyB,KAAI,CAAC,KAAL,CAAW,UAApC,CAAhD;;AAEA,IAAA,KAAA,CAAA,eAAA,GAAkB,UAAC,GAAD,EAAwB;AAAK,aAAC,KAAI,CAAC,aAAL,GAAD,GAAA;AAA0B,KAAzE;AAoFR;;;;;;;AAOG;;;AACI,IAAA,KAAA,CAAA,UAAA,GAAa,YAAA;AAAA,UAAA,EAAA;;AAAA,aAAA,CAAA,EAAA,GAAM,KAAI,CAAC,oBAAX,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,KAAA,CAA/B,GAA+B,EAAA,CAAA,IAAA,CAAzB,KAAyB,CAA/B;AAAmC,KAAhD;;AAsCC,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,WAAD,EAAiC;;;AAC/C,UAAA,EAAA,GAAiC,KAAI,CAAC,KAAtC;AAAA,UAAE,SAAS,GAAA,EAAA,CAAA,SAAX;AAAA,UAAa,eAAe,GAAA,EAAA,CAAA,eAA5B;AACE,UAAA,eAAe,GAAK,KAAI,CAAC,KAAL,CAAL,eAAf,CAF6C,CAIrD;;AACA,MAAA,KAAI,CAAC,oBAAL,GAA4B,WAAW,CAAC,cAAxC;AAEA,UAAM,eAAe,GAAiB;AAClC;AACA,QAAA,OAAO,EAAE,KAAI,CAAC;AAFoB,OAAtC;;AAIA,UACI,eAAe,KAAK,sBAAsB,CAAC,KAA3C,IACC,CAAC,SAAD,IAAc,eAAe,KAAK,sBAAsB,CAAC,iBAF9D,EAGE;AACE,QAAA,eAAe,CAAC,YAAhB,GAA+B,KAAI,CAAC,gBAApC;AACA,QAAA,eAAe,CAAC,YAAhB,GAA+B,KAAI,CAAC,gBAApC;AACH;;AAED,UAAM,cAAc,GAAG,UAAU,CAC7B,OAAO,CAAC,OADqB,GACd,EAAA,GAAA,EAAA,EAEX,EAAA,CAAC,OAAO,CAAC,IAAT,CAAA,GAAgB,KAAI,CAAC,KAAL,CAAW,gBAAX,IAA+B,KAAI,CAAC,KAAL,CAAW,aAF/C,EAGX,EAAA,CAAC,OAAO,CAAC,OAAT,CAAA,GAAmB,KAAI,CAAC,KAAL,CAAW,OAHnB,EAIX,EAAA,CAAC,OAAO,CAAC,yBAAT,CAAA,GAAqC,KAAI,CAAC,KAAL,CAAW,cAJrC,E,EADc,GAO7B,KAAI,CAAC,KAAL,CAAW,gBAPkB,CAAjC;AAUA,aACI,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,QAAA,SAAS,EAAE,OAAO,CAAC,oBAAxB;AAA8C,QAAA,GAAG,EAAE,WAAW,CAAC,GAA/D;AAAoE,QAAA,KAAK,EAAE,WAAW,CAAC;AAAvF,OAAA,EACI,KAAA,CAAA,aAAA,CAAC,YAAD,EAAa;AAAC,QAAA,QAAQ,EAAE,KAAI,CAAC;AAAhB,OAAb,EACI,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA;AACI,QAAA,SAAS,EAAE,cADf;AAEI,QAAA,KAAK,EAAE;AAAE,UAAA,eAAe,EAAA;AAAjB,SAFX;AAGI,QAAA,GAAG,EAAE,KAAI,CAAC;AAHd,OAAA,EAIQ,eAJR,CAAA,EAMK,KAAI,CAAC,cAAL,MACG,KAAA,CAAA,aAAA,CAAC,YAAD,EAAa;AAAC,QAAA,UAAU,EAAE,WAAW,CAAC,UAAzB;AAAqC,QAAA,SAAS,EAAE,WAAW,CAAC;AAA5D,OAAb,CAPR,EASI,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAK,QAAA,SAAS,EAAE,OAAO,CAAC;AAAxB,OAAA,EAA0C,KAAI,CAAC,kBAAL,GAA0B,OAApE,CATJ,CADJ,CADJ,CADJ;AAiBH,KA9CO;;AAgDA,IAAA,KAAA,CAAA,YAAA,GAAe,UAAC,cAAD,EAAuC;;;AACpD,UAAA,EAAA,GAAiE,KAAI,CAAC,KAAtE;AAAA,UAAE,IAAI,GAAA,EAAA,CAAA,IAAN;AAAA,UAAQ,iBAAiB,GAAA,EAAA,CAAA,iBAAzB;AAAA,UAA2B,eAAe,GAAA,EAAA,CAAA,eAA1C;AAAA,UAA4C,EAAA,GAAA,EAAA,CAAA,WAA5C;AAAA,UAA4C,WAAW,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAA5D;AACE,UAAA,MAAM,GAAK,KAAI,CAAC,KAAL,CAAL,MAAN;;AACR,UAAM,YAAY,GAAG,KAAI,CAAC,YAAL,EAArB;;AACA,UAAM,sBAAsB,GAAG,KAAI,CAAC,sBAAL,EAA/B;;AACM,UAAA,aAAa,GAAK,KAAI,CAAC,KAAL,CAAL,aAAb;;AACN,UAAI,IAAJ,EAAU;AACN,QAAA,aAAa,GAAG,KAAhB;AACH;;AAED,UAAM,gBAAgB,GAAiC,sBAAsB,GACvE;AACI;AACA,QAAA,MAAM,EAAE,KAAI,CAAC,gBAFjB;AAGI,QAAA,OAAO,EAAE,KAAI,CAAC,iBAHlB;AAII,QAAA,YAAY,EAAE,KAAI,CAAC,gBAJvB;AAKI,QAAA,YAAY,EAAE,KAAI,CAAC;AALvB,OADuE,GAQvE;AACI;AACA,QAAA,OAAO,EAAE,KAAI,CAAC;AAFlB,OARN;AAYA,MAAA,gBAAgB,CAAC,SAAjB,GAA6B,UAAU,CACnC,OAAO,CAAC,cAD2B,GACb,EAAA,GAAA,EAAA,EACpB,EAAA,CAAC,OAAO,CAAC,YAAT,CAAA,GAAwB,MADJ,EACU,EAFG,GAGnC,WAAW,CAAC,SAHuB,EAInC,eAJmC,CAAvC;AAMA,MAAA,gBAAgB,CAAC,GAAjB,GAAuB,cAAc,CAAC,GAAtC;AAEA,UAAM,SAAS,GAAG,KAAK,CAAC,aAAN,CAAoB,KAAI,CAAC,kBAAL,GAA0B,MAA9C,CAAlB;;AAEA,UAAI,SAAS,KAAK,SAAlB,EAA6B;AACzB,eAAO,IAAP;AACH;;AAED,UAAM,WAAW,GAAG,SAAS,CAAC,KAAV,CAAgB,QAApC,CApC0D,CAqC1D;;AACA,UAAM,QAAQ,GAAG,WAAW,IAAI,IAAf,IAAuB,iBAAvB,IAA4C,sBAA5C,GAAqE,CAArE,GAAyE,WAA1F;AACA,UAAM,YAAY,GAAgB,KAAK,CAAC,YAAN,CAAmB,SAAnB,EAA8B;AAC5D,QAAA,SAAS,EAAE,UAAU,CAAC,SAAS,CAAC,KAAV,CAAgB,SAAjB,GAA0B,EAAA,GAAA,EAAA,EAC3C;AACA;AACA,QAAA,EAAA,CAAC,OAAO,CAAC,MAAT,CAAA,GAAkB,MAAM,IAAI,CAAC,YAAX,IAA2B,CAAC,sBAHH,EAI7C,EAJmB,EADuC;AAM5D;;AACA;AACA,QAAA,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,eAAN,CAAsB,SAAtB,EAAiC,OAAjC,CAAV,GAAsD,IAAtD,GAA6D,SAAS,CAAC,KAAV,CAAgB,QAR3B;AAS5D,QAAA,QAAQ,EAAA;AAToD,OAA9B,CAAlC;AAWA,UAAM,MAAM,GAAG,KAAK,CAAC,aAAN,CACX,aADW,EACG,QAAA,CAAA,QAAA,CAAA,EAAA,EAEP,WAFO,CAAA,EAGP,gBAHO,CADH,EAMX,YANW,CAAf;AASA,aAAO,KAAA,CAAA,aAAA,CAAC,YAAD,EAAa;AAAC,QAAA,QAAQ,EAAE,KAAI,CAAC;AAAhB,OAAb,EAA0C,MAA1C,CAAP;AACH,KA5DO;;AA0EA,IAAA,KAAA,CAAA,YAAA,GAAe,YAAA;AAAM,aAAA,KAAI,CAAC,KAAL,CAAW,MAAX,KAAA,SAAA;AAA+B,KAApD;;AAiCA,IAAA,KAAA,CAAA,iBAAA,GAAoB,UAAC,CAAD,EAAiC;;;AACzD,UAAI,KAAI,CAAC,KAAL,CAAW,iBAAX,IAAgC,KAAI,CAAC,sBAAL,EAApC,EAAmE;AAC/D,YAAI,CAAC,CAAC,aAAF,IAAmB,IAAnB,IAA2B,CAAC,KAAI,CAAC,mBAArC,EAA0D;AACtD;AACA;AACA;AACH;;AACD,QAAA,KAAI,CAAC,gBAAL,CAAuB,CAAvB;AACH;;AACD,OAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAI,CAAC,KAAL,CAAW,WAAX,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,OAAxB,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,KAAA,CAA/B,GAA+B,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,CAAH,CAA/B;AACH,KAVO;;AAYA,IAAA,KAAA,CAAA,gBAAA,GAAmB,UAAC,CAAD,EAAiC;;;AACxD,UAAI,KAAI,CAAC,KAAL,CAAW,iBAAX,IAAgC,KAAI,CAAC,sBAAL,EAApC,EAAmE;AAC/D;AACA;AACA;AACA;AACA;AACA,YAAI,CAAC,CAAC,aAAF,IAAmB,IAAnB,IAA2B,CAAC,KAAI,CAAC,kBAAL,CAAwB,CAAC,CAAC,aAA1B,CAAhC,EAAyF;AACrF,UAAA,KAAI,CAAC,gBAAL,CAAuB,CAAvB;AACH;AACJ;;AACD,MAAA,KAAI,CAAC,mBAAL,GAA2B,CAAC,CAAC,aAAF,IAAmB,IAA9C;AACA,OAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAI,CAAC,KAAL,CAAW,WAAX,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,MAAxB,MAA8B,IAA9B,IAA8B,EAAA,KAAA,KAAA,CAA9B,GAA8B,KAAA,CAA9B,GAA8B,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,CAAH,CAA9B;AACH,KAbO;;AAeA,IAAA,KAAA,CAAA,gBAAA,GAAmB,UAAC,CAAD,EAAiC;;;AACxD,MAAA,KAAI,CAAC,wBAAL,GAAgC,IAAhC,CADwD,CAGxD;AACA;;AACA,UACI,CAAC,KAAI,CAAC,KAAL,CAAW,SAAZ,IACA,KAAI,CAAC,kBAAL,CAAwB,CAAC,CAAC,MAA1B,CADA,IAEA,KAAI,CAAC,KAAL,CAAW,eAAX,KAA+B,sBAAsB,CAAC,iBAFtD,IAGA,CAAC,KAAI,CAAC,KAAL,CAAW,iBAJhB,EAKE;AACE,QAAA,KAAI,CAAC,gBAAL,CAAsB,CAAtB;AACH,OAPD,MAOO,IAAI,CAAC,KAAI,CAAC,KAAL,CAAW,QAAhB,EAA0B;AAC7B;AACA,QAAA,KAAI,CAAC,YAAL,CAAkB,IAAlB,EAAwB,CAAxB,EAA2B,KAAI,CAAC,KAAL,CAAW,cAAtC;AACH;;AACD,OAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAI,CAAC,KAAL,CAAW,WAAX,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,YAAxB,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,CAAH,CAApC;AACH,KAjBO;;AAmBA,IAAA,KAAA,CAAA,gBAAA,GAAmB,UAAC,CAAD,EAAiC;;;AACxD,MAAA,KAAI,CAAC,wBAAL,GAAgC,KAAhC,CADwD,CAGxD;AACA;AACA;;AACA,MAAA,KAAI,CAAC,UAAL,CAAgB,YAAA;AACZ,YAAI,KAAI,CAAC,wBAAT,EAAmC;AAC/B;AACH,SAHW,CAIZ;;;AACA,QAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAAyB,CAAzB,EAA4B,KAAI,CAAC,KAAL,CAAW,eAAvC;AACH,OAND;;AAOA,OAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAI,CAAC,KAAL,CAAW,WAAX,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,YAAxB,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,CAAH,CAApC;AACH,KAdO;;AAgBA,IAAA,KAAA,CAAA,kBAAA,GAAqB,UAAC,CAAD,EAAiC;AAC1D,UAAM,WAAW,GAAG,CAAC,CAAC,MAAtB;AACA,UAAM,YAAY,GAAG,WAAW,CAAC,OAAZ,CAAoB,MAAI,OAAO,CAAC,OAAhC,CAArB;AACA,UAAM,eAAe,GAAG,YAAY,KAAK,KAAI,CAAC,UAAL,CAAgB,OAAzD;AACA,UAAM,uBAAuB,GAAG,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAE,SAAd,CAAwB,QAAxB,CAAiC,OAAO,CAAC,yBAAzC,CAAhC,CAJ0D,CAK1D;;AACA,UAAM,cAAc,GAAG,WAAW,CAAC,OAAZ,CAAoB,MAAI,OAAO,CAAC,eAAZ,GAA2B,KAA3B,GAAiC,OAAO,CAAC,wBAA7D,CAAvB;AACA,UAAM,aAAa,GAAG,cAAc,IAAI,IAAlB,IAA0B,cAAc,CAAC,SAAf,CAAyB,QAAzB,CAAkC,OAAO,CAAC,eAA1C,CAAhD;AACA,UAAM,UAAU,GAAG,WAAW,CAAC,OAAZ,CAAoB,iBAAe,OAAO,CAAC,QAA3C,KAA0D,IAA7E;;AACA,UAAI,aAAa,IAAI,CAAC,UAAlB,KAAiC,CAAC,uBAAD,IAA4B,eAA7D,CAAJ,EAAmF;AAC/E,QAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAAyB,CAAzB;AACH;AACJ,KAZO;;AAcA,IAAA,KAAA,CAAA,kBAAA,GAAqB,UAAC,CAAD,EAAsC;AAC/D,UAAI,KAAI,CAAC,aAAL,KAAuB,IAAvB,IAA+B,CAAC,KAAK,SAAzC,EAAoD;AAChD;AACH;;AAED,UAAM,WAAW,GAAG,CAAC,CAAC,MAAtB,CAL+D,CAM/D;;AACA,UAAI,CAAC,KAAK,CAAC,mBAAN,CAA0B,KAAI,CAAC,aAA/B,EAA8C,WAA9C,CAAD,IAA+D,CAAC,CAAC,WAAF,YAAyB,aAA5F,EAA2G;AACvG,QAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAAyB,CAAzB;AACH;AACJ,KAVO;;AAYA,IAAA,KAAA,CAAA,iBAAA,GAAoB,UAAC,CAAD,EAAiC;iBAAA,CACzD;;;AACA,UAAI,CAAC,KAAI,CAAC,KAAL,CAAW,QAAZ,IAAwB,CAAC,KAAI,CAAC,kBAAL,CAAwB,CAAC,CAAC,MAA1B,CAA7B,EAA+E;AAC3E,YAAI,KAAI,CAAC,KAAL,CAAW,MAAX,IAAqB,IAAzB,EAA+B;AAC3B,UAAA,KAAI,CAAC,QAAL,CAAc,UAAA,SAAA,EAAS;AAAI,mBAAC;AAAE,cAAA,MAAM,EAAE,CAAC,SAAS,CAArB;AAAC,aAAD;AAA+B,WAA1D;AACH,SAFD,MAEO;AACH,UAAA,KAAI,CAAC,YAAL,CAAkB,CAAC,KAAI,CAAC,KAAL,CAAW,MAA9B,EAAsC,CAAtC;AACH;AACJ;;AACD,OAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAI,CAAC,KAAL,CAAW,WAAX,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAE,OAAxB,MAA+B,IAA/B,IAA+B,EAAA,KAAA,KAAA,CAA/B,GAA+B,KAAA,CAA/B,GAA+B,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,CAAH,CAA/B;AACH,KAVO;AAkDR;;;AACQ,IAAA,KAAA,CAAA,kBAAA,GAAiC,UAAA,IAAA,EAAI;AACzC;AACA,MAAA,KAAI,CAAC,QAAL,CAAc;AAAE,QAAA,eAAe,EAAE,kBAAkB,CAAC,IAAD;AAArC,OAAd;;AACA,aAAO,IAAP;AACH,KAJO;;;AAKX;;AA3aU,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;WAAA,CACI;AACA;AACA;AACA;;;AACM,QAAA,EAAA,GAA2C,KAAK,KAAhD;AAAA,QAAE,SAAS,GAAA,EAAA,CAAA,SAAX;AAAA,QAAa,QAAQ,GAAA,EAAA,CAAA,QAArB;AAAA,QAAuB,IAAI,GAAA,EAAA,CAAA,IAA3B;AAAA,QAA6B,SAAS,GAAA,EAAA,CAAA,SAAtC;AACE,QAAA,MAAM,GAAK,KAAK,KAAL,CAAL,MAAN;AACF,QAAA,cAAc,GAAK,KAAK,KAAL,CAAL,cAAd;;AACN,QAAI,IAAJ,EAAU;AACN,MAAA,cAAc,GAAG,KAAjB;AACH;;AAED,QAAM,cAAc,GAAG,KAAK,CAAC,aAAN,CAAoB,KAAK,kBAAL,GAA0B,OAA9C,KAA0D,IAAjF,CAZJ,CAaI;AACA;;AACA,QAAI,cAAc,IAAI,CAAC,QAAnB,IAA+B,MAAM,KAAK,KAA1C,IAAmD,CAAC,KAAK,CAAC,SAAN,CAAgB,YAAhB,CAAxD,EAAuF;AACnF,MAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,0BAApB;AACH;;AAED,QAAM,cAAc,GAAG,UAAU,CAAC,OAAO,CAAC,eAAT,EAA0B,SAA1B,GAAmC,EAAA,GAAA,EAAA,EAChE,EAAA,CAAC,OAAO,CAAC,IAAT,CAAA,GAAgB,IADgD,EAElE,EAF+B,EAAjC;AAIA,QAAM,OAAO,GAAG,KAAK,CAAC,aAAN,CACZ,cADY,EAEZ;AAAE,MAAA,SAAS,EAAE;AAAb,KAFY,EAGZ,KAAA,CAAA,aAAA,CAAC,SAAD,EAAU;AAAC,MAAA,QAAQ,EAAE,KAAK;AAAhB,KAAV,EAA4C,KAAK,YAAjD,CAHY,EAIZ,KAAA,CAAA,aAAA,CAAC,OAAD,EAAQ;AACJ,MAAA,SAAS,EAAE,KAAK,KAAL,CAAW,SADlB;AAEJ,MAAA,iBAAiB,EAAE,OAAO,CAAC,gBAFvB;AAGJ,MAAA,aAAa,EAAE,KAAK,KAAL,CAAW,aAHtB;AAIJ,MAAA,iBAAiB,EAAE,KAAK,KAAL,CAAW,iBAJ1B;AAKJ,MAAA,oBAAoB,EAAE,KAAK,KAAL,CAAW,eAAX,KAA+B,sBAAsB,CAAC,KALxE;AAMJ,MAAA,SAAS,EAAE,KAAK,KAAL,CAAW,eANlB;AAOJ,MAAA,YAAY,EAAE,KAAK,KAAL,CAAW,YAPrB;AAQJ,MAAA,WAAW,EAAE,KAAK,KAAL,CAAW,WARpB;AASJ,MAAA,MAAM,EAAE,MAAM,IAAI,CAAC,cATf;AAUJ,MAAA,OAAO,EAAE,KAAK,kBAVV;AAWJ,MAAA,QAAQ,EAAE,KAAK,KAAL,CAAW,QAXjB;AAYJ,MAAA,SAAS,EAAE,KAAK,KAAL,CAAW,SAZlB;AAaJ,MAAA,QAAQ,EAAE,KAAK,KAAL,CAAW,QAbjB;AAcJ,MAAA,SAAS,EAAE,KAAK,KAAL,CAAW,SAdlB;AAeJ,MAAA,kBAAkB,EAAE,KAAK,KAAL,CAAW,kBAf3B;AAgBJ,MAAA,cAAc,EAAE,OAAO,CAAC,OAhBpB;AAiBJ,MAAA,SAAS,EAAE,KAAK,KAAL,CAAW,SAjBlB;AAkBJ,MAAA,eAAe,EAAE,KAAK,KAAL,CAAW;AAlBxB,KAAR,EAoBI,KAAA,CAAA,aAAA,CAAC,MAAD,EAAO;AACH,MAAA,QAAQ,EAAE,KAAK,gBADZ;AAEH;AACA,MAAA,SAAS,EAAE,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAA,SAAA,GAAa,mBAAmB,CAAC,KAAK,KAAL,CAAW,QAAZ,CAHxC;AAIH,MAAA,SAAS,EAAE,KAAK,kBAAL;AAJR,KAAP,EAMK,KAAK,aANV,CApBJ,CAJY,CAAhB;AAmCA,WAAO,KAAA,CAAA,aAAA,CAAC,OAAD,EAAQ,IAAR,EAAU,OAAV,CAAP;AACH,GA3DM;;AA6DA,EAAA,OAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,YAAA;AACI,SAAK,gBAAL;AACH,GAFM;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,kBAAA,GAAP,UAA0B,KAA1B,EAAgD,KAAhD,EAAoE;AAChE,IAAA,MAAA,CAAA,SAAA,CAAM,kBAAN,CAAwB,IAAxB,CAAwB,IAAxB,EAAyB,KAAzB,EAAgC,KAAhC;;AACA,SAAK,gBAAL;AAEA,QAAM,UAAU,GAAG,KAAK,SAAL,CAAe,KAAK,KAApB,CAAnB;;AAEA,QAAI,KAAK,KAAL,CAAW,MAAX,IAAqB,IAArB,IAA6B,UAAU,KAAK,KAAK,KAAL,CAAW,MAA3D,EAAmE;AAC/D,WAAK,YAAL,CAAkB,UAAlB,EAD+D,CAE/D;AACA;;AACA,WAAK,QAAL,CAAc;AAAE,QAAA,MAAM,EAAE;AAAV,OAAd;AACH,KALD,MAKO,IAAI,KAAK,KAAL,CAAW,QAAX,IAAuB,KAAK,KAAL,CAAW,MAAlC,IAA4C,KAAK,KAAL,CAAW,MAAX,IAAqB,IAArE,EAA2E;AAC9E;AACA,WAAK,YAAL,CAAkB,KAAlB;AACH;AACJ,GAfM;;AA2BG,EAAA,OAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,KAAxB,EAA6E;AACzE,QAAI,KAAK,CAAC,MAAN,IAAgB,IAAhB,IAAwB,KAAK,CAAC,aAAN,IAAuB,IAAnD,EAAyD;AACrD,MAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,uCAApB;AACH;;AACD,QAAI,KAAK,CAAC,WAAN,IAAqB,CAAC,KAAK,CAAC,SAAhC,EAA2C;AACvC,MAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,gCAApB;AACH;;AACD,QAAI,KAAK,CAAC,WAAN,IAAqB,KAAK,CAAC,eAAN,KAA0B,sBAAsB,CAAC,KAA1E,EAAiF;AAC7E,MAAA,OAAO,CAAC,KAAR,CAAc,MAAM,CAAC,gCAArB;AACH;;AAED,QAAM,aAAa,GAAG,KAAK,CAAC,QAAN,CAAe,KAAf,CAAqB,KAAK,CAAC,QAA3B,CAAtB;AACA,QAAM,cAAc,GAAG,KAAK,CAAC,OAAN,KAAkB,SAAzC;AACA,QAAM,aAAa,GAAG,KAAK,CAAC,MAAN,KAAiB,SAAvC;;AAEA,QAAI,aAAa,KAAK,CAAlB,IAAuB,CAAC,aAA5B,EAA2C;AACvC,MAAA,OAAO,CAAC,KAAR,CAAc,MAAM,CAAC,uBAArB;AACH;;AACD,QAAI,aAAa,GAAG,CAApB,EAAuB;AACnB,MAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,8BAApB;AACH;;AACD,QAAI,aAAa,GAAG,CAAhB,IAAqB,aAAzB,EAAwC;AACpC,MAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,0BAApB;AACH;;AACD,QAAI,aAAa,KAAK,CAAlB,IAAuB,cAA3B,EAA2C;AACvC,MAAA,OAAO,CAAC,IAAR,CAAa,MAAM,CAAC,2BAApB;AACH;AACJ,GA3BS;;AA6BF,EAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,YAAA;AACI,QAAI,KAAK,KAAL,CAAW,SAAX,IAAwB,KAAK,KAAL,CAAW,MAAvC,EAA+C;AAC3C,UAAM,aAAa,GAAG,KAAK,aAAL,IAAsB,IAAtB,IAA8B,KAAK,aAAL,CAAmB,OAAnB,CAA2B,MAAI,OAAO,CAAC,IAAvC,KAAkD,IAAtG;AACA,WAAK,QAAL,CAAc;AAAE,QAAA,aAAa,EAAA;AAAf,OAAd;AACH;AACJ,GALO,CAtLZ,CA2SI;AACA;;;AACQ,EAAA,OAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,YAAA;AACU,QAAA,EAAA,GAAyD,KAAK,KAA9D;AAAA,QAAE,QAAQ,GAAA,EAAA,CAAA,QAAV;AAAA,QAAqB,WAAW,GAAA,EAAA,CAAA,OAAhC;AAAA,QAA0C,UAAU,GAAA,EAAA,CAAA,MAApD,CADV,CAEI;;AACM,QAAA,EAAA,GAA8B,KAAK,CAAC,QAAN,CAAe,OAAf,CAAuB,QAAvB,CAA9B;AAAA,QAAC,WAAW,GAAA,EAAA,CAAA,CAAA,CAAZ;AAAA,QAAc,YAAY,GAAA,EAAA,CAAA,CAAA,CAA1B;;AACN,WAAO;AACH,MAAA,OAAO,EAAE,YAAY,IAAI,IAAhB,GAAuB,WAAvB,GAAqC,YAD3C;AAEH,MAAA,MAAM,EAAE,WAAW,IAAI,IAAf,GAAsB,UAAtB,GAAmC;AAFxC,KAAP;AAIH,GARO;;AAYA,EAAA,OAAA,CAAA,SAAA,CAAA,SAAA,GAAR,UAAkB,KAAlB,EAAsC;AAClC;AACA,QAAI,KAAK,CAAC,QAAV,EAAoB;AAChB,aAAO,KAAP;AACH,KAFD,MAEO,IAAI,KAAK,CAAC,MAAN,IAAgB,IAApB,EAA0B;AAC7B,aAAO,KAAK,CAAC,MAAb;AACH,KAFM,MAEA;AACH,aAAO,KAAK,CAAC,aAAb;AACH;AACJ,GATO;;AAWA,EAAA,OAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,YAAA;AACU,QAAA,EAAA,GAA0B,KAAK,KAA/B;AAAA,QAAE,QAAQ,GAAA,EAAA,CAAA,QAAV;AAAA,QAAY,SAAS,GAAA,EAAA,CAAA,SAArB;AACA,QAAA,EAAA,GAAsC,SAAtC;AAAA,QAAE,EAAA,GAAA,EAAA,CAAA,IAAF;AAAA,QAAE,IAAI,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAAX;AAAA,QAAa,EAAA,GAAA,EAAA,CAAA,eAAb;AAAA,QAAa,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAAjC;AACN,WAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACO,SADP,CAAA,EACgB;AACZ,MAAA,WAAW,EAAE;AACT,QAAA,OAAO,EAAE,KAAK,cAAL,EADA;AAET,QAAA,EAAE,EAAE,mBAFK;AAGT,QAAA,KAAK,EAAE;AAHE,OADD;AAMZ,MAAA,IAAI,EAAA,QAAA,CAAA;AAAI,QAAA,iBAAiB,EAAE;AAAvB,OAAA,EAAoC,IAApC,CANQ;AAOZ,MAAA,eAAe,EAAA,QAAA,CAAA;AAAI,QAAA,iBAAiB,EAAE;AAAvB,OAAA,EAAoC,eAApC,CAPH;AAQZ,MAAA,kBAAkB,EAAE;AAChB,QAAA,OAAO,EAAE,IADO;AAEhB,QAAA,EAAE,EAAE,KAAK,kBAFO;AAGhB,QAAA,KAAK,EAAE;AAHS;AARR,KADhB,CAAA;AAeH,GAlBO,CApUZ,CA4bI;AACA;;;AACQ,EAAA,OAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,MAArB,EAAsC,CAAtC,EAA6E,OAA7E,EAA6F;AAA7F,QAAA,KAAA,GAAA,IAAA;;2BAA6F,CACzF;;;AACA,KAAA,EAAA,GAAA,KAAK,iBAAL,MAAsB,IAAtB,IAAsB,EAAA,KAAA,KAAA,CAAtB,GAAsB,KAAA,CAAtB,GAAsB,EAAA,CAAA,IAAA,CAAtB,IAAsB,CAAtB;;AACA,QAAI,OAAO,KAAK,SAAZ,IAAyB,OAAO,GAAG,CAAvC,EAA0C;AACtC,WAAK,iBAAL,GAAyB,KAAK,UAAL,CAAgB,YAAA;AAAM,eAAA,KAAI,CAAC,YAAL,CAAkB,MAAlB,EAAA,CAAA,CAAA;AAA4B,OAAlD,EAAoD,OAApD,CAAzB;AACH,KAFD,MAEO;AACH,UAAI,KAAK,KAAL,CAAW,MAAX,IAAqB,IAAzB,EAA+B;AAC3B,aAAK,QAAL,CAAc;AAAE,UAAA,MAAM,EAAA;AAAR,SAAd;AACH,OAFD,MAEO;AACH,SAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAK,KAAL,EAAW,aAAX,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,MAAH,EAAW,CAAX,CAAxB;AACH;;AACD,UAAI,CAAC,MAAL,EAAa;AACT;AACA;AACA,SAAA,EAAA,GAAA,CAAA,EAAA,GAAA,KAAK,KAAL,EAAW,OAAX,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAA,IAAA,CAAA,EAAA,EAAG,CAAH,CAAlB;AACH;AACJ;AACJ,GAjBO;;AAmBA,EAAA,OAAA,CAAA,SAAA,CAAA,cAAA,GAAR,YAAA;AACU,QAAA,EAAA,GAAyB,KAAK,KAA9B;AAAA,QAAE,OAAO,GAAA,EAAA,CAAA,OAAT;AAAA,QAAW,SAAS,GAAA,EAAA,CAAA,SAApB,CADV,CAEI;;AACA,WAAO,CAAC,OAAD,KAAa,CAAA,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAA,SAAS,CAAE,KAAX,KAAoB,IAApB,IAA4B,SAAS,CAAC,KAAV,CAAgB,OAAzD,CAAP;AACH,GAJO;;AAMA,EAAA,OAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,OAA3B,EAA2C;AACvC,WAAO,KAAK,cAAL,IAAuB,IAAvB,IAA+B,KAAK,cAAL,CAAoB,QAApB,CAA6B,OAA7B,CAAtC;AACH,GAFO;;AAIA,EAAA,OAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,YAAA;AACI,WACI,KAAK,KAAL,CAAW,eAAX,KAA+B,sBAAsB,CAAC,KAAtD,IACA,KAAK,KAAL,CAAW,eAAX,KAA+B,sBAAsB,CAAC,iBAF1D;AAIH,GALO;;AA1dM,EAAA,OAAA,CAAA,WAAA,GAAiB,kBAAkB,GAAA,UAAnC;AAIA,EAAA,OAAA,CAAA,YAAA,GAA8B;AACxC,IAAA,QAAQ,EAAE,cAD8B;AAExC,IAAA,cAAc,EAAE,KAFwB;AAGxC,IAAA,aAAa,EAAE,KAHyB;AAIxC,IAAA,QAAQ,EAAE,KAJ8B;AAKxC,IAAA,IAAI,EAAE,KALkC;AAMxC,IAAA,WAAW,EAAE,KAN2B;AAOxC,IAAA,eAAe,EAAE,GAPuB;AAQxC,IAAA,cAAc,EAAE,GARwB;AASxC,IAAA,gBAAgB,EAAE,IATsB;AAUxC,IAAA,eAAe,EAAE,sBAAsB,CAAC,KAVA;AAWxC,IAAA,OAAO,EAAE,KAX+B;AAYxC,IAAA,SAAS,EAAE,EAZ6B;AAaxC,IAAA,iBAAiB,EAAE,IAbqB;AAcxC;AACA;AACA,IAAA,QAAQ,EAAE,MAhB8B;AAiBxC,IAAA,aAAa,EAAE,MAjByB;AAkBxC,IAAA,kBAAkB,EAAE,GAlBoB;AAmBxC,IAAA,SAAS,EAAE,IAnB6B;AAoBxC,IAAA,cAAc,EAAE;AApBwB,GAA9B;AALL,EAAA,OAAO,GAAA,UAAA,CAAA,CADnB,QACmB,CAAA,EAAP,OAAO,CAAP;AAweb,SAAA,OAAA;AAAC,CAxeD,CAA6B,sBAA7B,CAAA;;SAAa,O","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __decorate, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { polyfill } from \"react-lifecycles-compat\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes, refHandler } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport * as Utils from \"../../common/utils\";\nimport { Overlay } from \"../overlay/overlay\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip } from \"../tooltip/tooltip\";\nimport { PopoverArrow } from \"./popoverArrow\";\nimport { positionToPlacement } from \"./popoverMigrationUtils\";\nimport { arrowOffsetModifier, getTransformOrigin } from \"./popperUtils\";\nexport var PopoverInteractionKind = {\n    CLICK: \"click\",\n    CLICK_TARGET_ONLY: \"click-target\",\n    HOVER: \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\",\n};\n/** @deprecated use { Popover2 } from \"@blueprintjs/popover2\" */\nvar Popover = /** @class */ (function (_super) {\n    __extends(Popover, _super);\n    function Popover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.popoverRef = Utils.createReactRef();\n        /**\n         * DOM element that contains the popover.\n         * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n         * so this reference can be very useful for testing.\n         */\n        _this.popoverElement = null;\n        /** DOM element that contains the target. */\n        _this.targetElement = null;\n        _this.state = {\n            hasDarkParent: false,\n            isOpen: _this.getIsOpen(_this.props),\n            transformOrigin: \"\",\n        };\n        // a flag that lets us detect mouse movement between the target and popover,\n        // now that mouseleave is triggered when you cross the gap between the two.\n        _this.isMouseInTargetOrPopover = false;\n        // a flag that indicates whether the target previously lost focus to another\n        // element on the same page.\n        _this.lostFocusOnSamePage = true;\n        _this.handlePopoverRef = refHandler(_this, \"popoverElement\", _this.props.popoverRef);\n        _this.handleTargetRef = function (ref) { return (_this.targetElement = ref); };\n        /**\n         * Instance method to instruct the `Popover` to recompute its position.\n         *\n         * This method should only be used if you are updating the target in a way\n         * that does not cause it to re-render, such as changing its _position_\n         * without changing its _size_ (since `Popover` already repositions when it\n         * detects a resize).\n         */\n        _this.reposition = function () { var _a; return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this); };\n        _this.renderPopover = function (popperProps) {\n            var _a;\n            var _b = _this.props, usePortal = _b.usePortal, interactionKind = _b.interactionKind;\n            var transformOrigin = _this.state.transformOrigin;\n            // Need to update our reference to this on every render as it will change.\n            _this.popperScheduleUpdate = popperProps.scheduleUpdate;\n            var popoverHandlers = {\n                // always check popover clicks for dismiss class\n                onClick: _this.handlePopoverClick,\n            };\n            if (interactionKind === PopoverInteractionKind.HOVER ||\n                (!usePortal && interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY)) {\n                popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n                popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n            }\n            var popoverClasses = classNames(Classes.POPOVER, (_a = {},\n                _a[Classes.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent,\n                _a[Classes.MINIMAL] = _this.props.minimal,\n                _a[Classes.POPOVER_CAPTURING_DISMISS] = _this.props.captureDismiss,\n                _a), _this.props.popoverClassName);\n            return (React.createElement(\"div\", { className: Classes.TRANSITION_CONTAINER, ref: popperProps.ref, style: popperProps.style },\n                React.createElement(ResizeSensor, { onResize: _this.reposition },\n                    React.createElement(\"div\", __assign({ className: popoverClasses, style: { transformOrigin: transformOrigin }, ref: _this.popoverRef }, popoverHandlers),\n                        _this.isArrowEnabled() && (React.createElement(PopoverArrow, { arrowProps: popperProps.arrowProps, placement: popperProps.placement })),\n                        React.createElement(\"div\", { className: Classes.POPOVER_CONTENT }, _this.understandChildren().content)))));\n        };\n        _this.renderTarget = function (referenceProps) {\n            var _a, _b;\n            var _c = _this.props, fill = _c.fill, openOnTargetFocus = _c.openOnTargetFocus, targetClassName = _c.targetClassName, _d = _c.targetProps, targetProps = _d === void 0 ? {} : _d;\n            var isOpen = _this.state.isOpen;\n            var isControlled = _this.isControlled();\n            var isHoverInteractionKind = _this.isHoverInteractionKind();\n            var targetTagName = _this.props.targetTagName;\n            if (fill) {\n                targetTagName = \"div\";\n            }\n            var finalTargetProps = isHoverInteractionKind\n                ? {\n                    // HOVER handlers\n                    onBlur: _this.handleTargetBlur,\n                    onFocus: _this.handleTargetFocus,\n                    onMouseEnter: _this.handleMouseEnter,\n                    onMouseLeave: _this.handleMouseLeave,\n                }\n                : {\n                    // CLICK needs only one handler\n                    onClick: _this.handleTargetClick,\n                };\n            finalTargetProps.className = classNames(Classes.POPOVER_TARGET, (_a = {}, _a[Classes.POPOVER_OPEN] = isOpen, _a), targetProps.className, targetClassName);\n            finalTargetProps.ref = referenceProps.ref;\n            var rawTarget = Utils.ensureElement(_this.understandChildren().target);\n            if (rawTarget === undefined) {\n                return null;\n            }\n            var rawTabIndex = rawTarget.props.tabIndex;\n            // ensure target is focusable if relevant prop enabled\n            var tabIndex = rawTabIndex == null && openOnTargetFocus && isHoverInteractionKind ? 0 : rawTabIndex;\n            var clonedTarget = React.cloneElement(rawTarget, {\n                className: classNames(rawTarget.props.className, (_b = {},\n                    // this class is mainly useful for button targets; we should only apply it for uncontrolled popovers\n                    // when they are opened by a user interaction\n                    _b[Classes.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n                    _b)),\n                // force disable single Tooltip child when popover is open (BLUEPRINT-552)\n                /* eslint-disable-next-line deprecation/deprecation */\n                disabled: isOpen && Utils.isElementOfType(rawTarget, Tooltip) ? true : rawTarget.props.disabled,\n                tabIndex: tabIndex,\n            });\n            var target = React.createElement(targetTagName, __assign(__assign({}, targetProps), finalTargetProps), clonedTarget);\n            return React.createElement(ResizeSensor, { onResize: _this.reposition }, target);\n        };\n        _this.isControlled = function () { return _this.props.isOpen !== undefined; };\n        _this.handleTargetFocus = function (e) {\n            var _a, _b;\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n                    // ignore this focus event -- the target was already focused but the page itself\n                    // lost focus (e.g. due to switching tabs).\n                    return;\n                }\n                _this.handleMouseEnter(e);\n            }\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handleTargetBlur = function (e) {\n            var _a, _b;\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n                // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n                // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n                // close the popover if necessary.\n                if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n                    _this.handleMouseLeave(e);\n                }\n            }\n            _this.lostFocusOnSamePage = e.relatedTarget != null;\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handleMouseEnter = function (e) {\n            var _a, _b;\n            _this.isMouseInTargetOrPopover = true;\n            // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n            // trigger the mouse leave event, as hovering over the popover shouldn't count.\n            if (!_this.props.usePortal &&\n                _this.isElementInPopover(e.target) &&\n                _this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY &&\n                !_this.props.openOnTargetFocus) {\n                _this.handleMouseLeave(e);\n            }\n            else if (!_this.props.disabled) {\n                // only begin opening popover when it is enabled\n                _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n            }\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handleMouseLeave = function (e) {\n            var _a, _b;\n            _this.isMouseInTargetOrPopover = false;\n            // wait until the event queue is flushed, because we want to leave the\n            // popover open if the mouse entered the popover immediately after\n            // leaving the target (or vice versa).\n            _this.setTimeout(function () {\n                if (_this.isMouseInTargetOrPopover) {\n                    return;\n                }\n                // user-configurable closing delay is helpful when moving mouse from target to popover\n                _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n            });\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        _this.handlePopoverClick = function (e) {\n            var eventTarget = e.target;\n            var eventPopover = eventTarget.closest(\".\" + Classes.POPOVER);\n            var isEventFromSelf = eventPopover === _this.popoverRef.current;\n            var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER_CAPTURING_DISMISS);\n            // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n            var dismissElement = eventTarget.closest(\".\" + Classes.POPOVER_DISMISS + \", .\" + Classes.POPOVER_DISMISS_OVERRIDE);\n            var shouldDismiss = dismissElement != null && dismissElement.classList.contains(Classes.POPOVER_DISMISS);\n            var isDisabled = eventTarget.closest(\":disabled, .\" + Classes.DISABLED) != null;\n            if (shouldDismiss && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleOverlayClose = function (e) {\n            if (_this.targetElement === null || e === undefined) {\n                return;\n            }\n            var eventTarget = e.target;\n            // if click was in target, target event listener will handle things, so don't close\n            if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleTargetClick = function (e) {\n            var _a, _b;\n            // ensure click did not originate from within inline popover before closing\n            if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n                if (_this.props.isOpen == null) {\n                    _this.setState(function (prevState) { return ({ isOpen: !prevState.isOpen }); });\n                }\n                else {\n                    _this.setOpenState(!_this.props.isOpen, e);\n                }\n            }\n            (_b = (_a = _this.props.targetProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);\n        };\n        /** Popper modifier that updates React state (for style properties) based on latest data. */\n        _this.updatePopoverState = function (data) {\n            // always set string; let shouldComponentUpdate determine if update is necessary\n            _this.setState({ transformOrigin: getTransformOrigin(data) });\n            return data;\n        };\n        return _this;\n    }\n    Popover.prototype.render = function () {\n        var _a;\n        // rename wrapper tag to begin with uppercase letter so it's recognized\n        // as JSX component instead of intrinsic element. but because of its\n        // type, tsc actually recognizes that it is _any_ intrinsic element, so\n        // it can typecheck the HTML props!!\n        var _b = this.props, className = _b.className, disabled = _b.disabled, fill = _b.fill, placement = _b.placement;\n        var isOpen = this.state.isOpen;\n        var wrapperTagName = this.props.wrapperTagName;\n        if (fill) {\n            wrapperTagName = \"div\";\n        }\n        var isContentEmpty = Utils.ensureElement(this.understandChildren().content) == null;\n        // need to do this check in render(), because `isOpen` is derived from\n        // state, and state can't necessarily be accessed in validateProps.\n        if (isContentEmpty && !disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n            console.warn(Errors.POPOVER_WARN_EMPTY_CONTENT);\n        }\n        var wrapperClasses = classNames(Classes.POPOVER_WRAPPER, className, (_a = {},\n            _a[Classes.FILL] = fill,\n            _a));\n        var wrapper = React.createElement(wrapperTagName, { className: wrapperClasses }, React.createElement(Reference, { innerRef: this.handleTargetRef }, this.renderTarget), React.createElement(Overlay, { autoFocus: this.props.autoFocus, backdropClassName: Classes.POPOVER_BACKDROP, backdropProps: this.props.backdropProps, canEscapeKeyClose: this.props.canEscapeKeyClose, canOutsideClickClose: this.props.interactionKind === PopoverInteractionKind.CLICK, className: this.props.portalClassName, enforceFocus: this.props.enforceFocus, hasBackdrop: this.props.hasBackdrop, isOpen: isOpen && !isContentEmpty, onClose: this.handleOverlayClose, onClosed: this.props.onClosed, onClosing: this.props.onClosing, onOpened: this.props.onOpened, onOpening: this.props.onOpening, transitionDuration: this.props.transitionDuration, transitionName: Classes.POPOVER, usePortal: this.props.usePortal, portalContainer: this.props.portalContainer },\n            React.createElement(Popper, { innerRef: this.handlePopoverRef, \n                // eslint-disable-next-line deprecation/deprecation\n                placement: placement !== null && placement !== void 0 ? placement : positionToPlacement(this.props.position), modifiers: this.getPopperModifiers() }, this.renderPopover)));\n        return React.createElement(Manager, null, wrapper);\n    };\n    Popover.prototype.componentDidMount = function () {\n        this.updateDarkParent();\n    };\n    Popover.prototype.componentDidUpdate = function (props, state) {\n        _super.prototype.componentDidUpdate.call(this, props, state);\n        this.updateDarkParent();\n        var nextIsOpen = this.getIsOpen(this.props);\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        }\n        else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    };\n    Popover.prototype.validateProps = function (props) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== PopoverInteractionKind.CLICK) {\n            console.error(Errors.POPOVER_HAS_BACKDROP_INTERACTION);\n        }\n        var childrenCount = React.Children.count(props.children);\n        var hasContentProp = props.content !== undefined;\n        var hasTargetProp = props.target !== undefined;\n        if (childrenCount === 0 && !hasTargetProp) {\n            console.error(Errors.POPOVER_REQUIRES_TARGET);\n        }\n        if (childrenCount > 2) {\n            console.warn(Errors.POPOVER_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasTargetProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_TARGET);\n        }\n        if (childrenCount === 2 && hasContentProp) {\n            console.warn(Errors.POPOVER_WARN_DOUBLE_CONTENT);\n        }\n    };\n    Popover.prototype.updateDarkParent = function () {\n        if (this.props.usePortal && this.state.isOpen) {\n            var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + Classes.DARK) != null;\n            this.setState({ hasDarkParent: hasDarkParent });\n        }\n    };\n    // content and target can be specified as props or as children. this method\n    // normalizes the two approaches, preferring child over prop.\n    Popover.prototype.understandChildren = function () {\n        var _a = this.props, children = _a.children, contentProp = _a.content, targetProp = _a.target;\n        // #validateProps asserts that 1 <= children.length <= 2 so content is optional\n        var _b = React.Children.toArray(children), targetChild = _b[0], contentChild = _b[1];\n        return {\n            content: contentChild == null ? contentProp : contentChild,\n            target: targetChild == null ? targetProp : targetChild,\n        };\n    };\n    Popover.prototype.getIsOpen = function (props) {\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        }\n        else if (props.isOpen != null) {\n            return props.isOpen;\n        }\n        else {\n            return props.defaultIsOpen;\n        }\n    };\n    Popover.prototype.getPopperModifiers = function () {\n        var _a = this.props, boundary = _a.boundary, modifiers = _a.modifiers;\n        var _b = modifiers, _c = _b.flip, flip = _c === void 0 ? {} : _c, _d = _b.preventOverflow, preventOverflow = _d === void 0 ? {} : _d;\n        return __assign(__assign({}, modifiers), { arrowOffset: {\n                enabled: this.isArrowEnabled(),\n                fn: arrowOffsetModifier,\n                order: 510,\n            }, flip: __assign({ boundariesElement: boundary }, flip), preventOverflow: __assign({ boundariesElement: boundary }, preventOverflow), updatePopoverState: {\n                enabled: true,\n                fn: this.updatePopoverState,\n                order: 900,\n            } });\n    };\n    // a wrapper around setState({isOpen}) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    Popover.prototype.setOpenState = function (isOpen, e, timeout) {\n        var _this = this;\n        var _a, _b, _c, _d, _e;\n        // cancel any existing timeout because we have new state\n        (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(function () { return _this.setOpenState(isOpen, e); }, timeout);\n        }\n        else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen: isOpen });\n            }\n            else {\n                (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n            }\n        }\n    };\n    Popover.prototype.isArrowEnabled = function () {\n        var _a = this.props, minimal = _a.minimal, modifiers = _a.modifiers;\n        // omitting `arrow` from `modifiers` uses Popper default, which does show an arrow.\n        return !minimal && ((modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow) == null || modifiers.arrow.enabled);\n    };\n    Popover.prototype.isElementInPopover = function (element) {\n        return this.popoverElement != null && this.popoverElement.contains(element);\n    };\n    Popover.prototype.isHoverInteractionKind = function () {\n        return (this.props.interactionKind === PopoverInteractionKind.HOVER ||\n            this.props.interactionKind === PopoverInteractionKind.HOVER_TARGET_ONLY);\n    };\n    Popover.displayName = DISPLAYNAME_PREFIX + \".Popover\";\n    Popover.defaultProps = {\n        boundary: \"scrollParent\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: PopoverInteractionKind.CLICK,\n        minimal: false,\n        modifiers: {},\n        openOnTargetFocus: true,\n        // N.B. we don't set a default for `placement` here because that would override\n        // the deprecated `position` prop\n        position: \"auto\",\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n        wrapperTagName: \"span\",\n    };\n    Popover = __decorate([\n        polyfill\n    ], Popover);\n    return Popover;\n}(AbstractPureComponent2));\nexport { Popover };\n//# sourceMappingURL=popover.js.map"]},"metadata":{},"sourceType":"module"}