{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { Icon } from \"@blueprintjs/core\"; // used to exclude icons from column header measure\n\nexport var CLASSNAME_EXCLUDED_FROM_TEXT_MEASUREMENT = \"bp-table-text-no-measure\"; // supposed width of the icons placeholder\n\nvar EXCLUDED_ICON_PLACEHOLDER_WIDTH = Icon.SIZE_STANDARD;\n/**\n * Since Firefox doesn't provide a computed \"font\" property, we manually\n * construct it using the ordered properties that can be specifed in CSS.\n */\n\nvar CSS_FONT_PROPERTIES = [\"font-style\", \"font-variant\", \"font-weight\", \"font-size\", \"font-family\"]; // table is nearly deprecated, let's not block on code coverage\n\n/* istanbul ignore next */\n\nexport var Utils = {\n  /**\n   * Invokes the callback `n` times, collecting the results in an array, which\n   * is the return value. Similar to _.times\n   */\n  times: function (n, callback) {\n    if (n < 0) {\n      throw new Error(\"[Blueprint] times() cannot be called with negative numbers.\");\n    }\n\n    var result = Array(n);\n\n    for (var index = 0; index < n; index++) {\n      result[index] = callback(index);\n    }\n\n    return result;\n  },\n\n  /**\n   * Takes an array of numbers, returns an array of numbers of the same length in which each\n   * value is the sum of current and previous values in the input array.\n   *\n   * Example input:  [10, 20, 50]\n   *         output: [10, 30, 80]\n   */\n  accumulate: function (numbers) {\n    var result = [];\n    var sum = 0;\n\n    for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {\n      var num = numbers_1[_i];\n      sum += num;\n      result.push(sum);\n    }\n\n    return result;\n  },\n\n  /**\n   * Returns traditional spreadsheet-style column names\n   * e.g. (A, B, ..., Z, AA, AB, ..., ZZ, AAA, AAB, ...).\n   *\n   * Note that this isn't technically mathematically equivalent to base 26 since\n   * there is no zero element.\n   */\n  toBase26Alpha: function (num) {\n    var str = \"\";\n\n    while (true) {\n      var letter = num % 26; // eslint-disable-next-line id-blacklist\n\n      str = String.fromCharCode(65 + letter) + str;\n      num = num - letter;\n\n      if (num <= 0) {\n        return str;\n      }\n\n      num = num / 26 - 1;\n    }\n  },\n\n  /**\n   * Returns traditional spreadsheet-style cell names\n   * e.g. (A1, B2, ..., Z44, AA1) with rows 1-indexed.\n   */\n  toBase26CellName: function (rowIndex, columnIndex) {\n    return \"\" + Utils.toBase26Alpha(columnIndex) + (rowIndex + 1);\n  },\n\n  /**\n   * Performs the binary search algorithm to find the index of the `value`\n   * parameter in a sorted list of numbers. If `value` is not in the list, the\n   * index where `value` can be inserted to maintain the sort is returned.\n   *\n   * Unlike a typical binary search implementation, we use a `lookup`\n   * callback to access the sorted list of numbers instead of an array. This\n   * avoids additional storage overhead.\n   *\n   * We use this to, for example, find the index of a row/col given its client\n   * coordinate.\n   *\n   * Adapted from lodash https://github.com/lodash/lodash/blob/4.11.2/lodash.js#L3579\n   *\n   * @param value - the query value\n   * @param high - the length of the sorted list of numbers\n   * @param lookup - returns the number from the list at the supplied index\n   */\n  binarySearch: function (value, high, lookup) {\n    var low = 0;\n\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2.0);\n      var computed = lookup(mid);\n\n      if (computed < value) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n\n    return high;\n  },\n\n  /**\n   * Returns a copy of the array that will have a length of the supplied parameter.\n   * If the array is too long, it will be truncated. If it is too short, it will be\n   * filled with the suppleid `fillValue` argument.\n   *\n   * @param array - the `Array` to copy and adjust\n   * @param length - the target length of the array\n   * @param fillValue - the value to add to the array if it is too short\n   */\n  arrayOfLength: function (array, length, fillValue) {\n    if (array.length > length) {\n      return array.slice(0, length);\n    }\n\n    array = array.slice();\n\n    while (array.length < length) {\n      array.push(fillValue);\n    }\n\n    return array;\n  },\n\n  /**\n   * Takes in one full array of values and one sparse array of the same\n   * length and type. Returns a copy of the `defaults` array, where each\n   * value is replaced with the corresponding non-null value at the same\n   * index in `sparseOverrides`.\n   *\n   * @param defaults - the full array of default values\n   * @param sparseOverrides - the sparse array of override values\n   */\n  assignSparseValues: function (defaults, sparseOverrides) {\n    if (sparseOverrides == null || defaults.length !== sparseOverrides.length) {\n      return defaults;\n    }\n\n    defaults = defaults.slice();\n\n    for (var i = 0; i < defaults.length; i++) {\n      var override = sparseOverrides[i];\n\n      if (override != null) {\n        defaults[i] = override;\n      }\n    }\n\n    return defaults;\n  },\n\n  /**\n   * Measures the bounds of supplied element's textContent.\n   * We use the computed font from the supplied element and a non-DOM canvas\n   * context to measure the text.\n   */\n  measureElementTextContent: function (element) {\n    var context = document.createElement(\"canvas\").getContext(\"2d\");\n    var style = getComputedStyle(element, null);\n    context.font = CSS_FONT_PROPERTIES.map(function (prop) {\n      return style.getPropertyValue(prop);\n    }).join(\" \");\n    return measureTextContentWithExclusions(context, element);\n  },\n\n  /**\n   * Given a number, returns a value that is clamped within a\n   * minimum/maximum bounded range. The minimum and maximum are optional. If\n   * either is missing, that extrema limit is not applied.\n   *\n   * Assumes max >= min.\n   */\n  clamp: function (value, min, max) {\n    if (min != null && value < min) {\n      value = min;\n    }\n\n    if (max != null && value > max) {\n      value = max;\n    }\n\n    return value;\n  },\n\n  /**\n   * When reordering a contiguous block of rows or columns to a new index, we show a preview guide\n   * at the absolute index in the original ordering but emit the new index in the reordered list.\n   * This function converts an absolute \"guide\" index to a relative \"reordered\" index.\n   *\n   * Example: Say we want to move the first three columns two spots to the right. While we drag, a\n   * vertical guide is shown to preview where we'll be dropping the columns. (In the following\n   * ASCII art, `*` denotes a selected column, `·` denotes a cell border, and `|` denotes a\n   * vertical guide).\n   *\n   *     Before mousedown:\n   *     · 0 · 1 · 2 · 3 · 4 · 5 ·\n   *       *   *   *\n   *\n   *     During mousemove two spots to the right:\n   *     · 0 · 1 · 2 · 3 · 4 | 5 ·\n   *       *   *   *\n   *\n   *     After mouseup:\n   *     · 3 · 4 · 0 · 1 · 2 · 5 ·\n   *               *   *   *\n   *\n   * Note that moving the three columns beyond index 4 effectively moves them two spots rightward.\n   *\n   * In this case, the inputs to this function would be:\n   *     - oldIndex: 0 (the left-most index of the selected column range in the original ordering)\n   *     - newIndex: 5 (the index on whose left boundary the guide appears in the original ordering)\n   *     - length: 3 (the number of columns to move)\n   *\n   * The return value will then be 2, the left-most index of the columns in the new ordering.\n   */\n  guideIndexToReorderedIndex: function (oldIndex, newIndex, length) {\n    if (newIndex < oldIndex) {\n      return newIndex;\n    } else if (oldIndex <= newIndex && newIndex < oldIndex + length) {\n      return oldIndex;\n    } else {\n      return Math.max(0, newIndex - length);\n    }\n  },\n\n  /**\n   * When reordering a contiguous block of rows or columns to a new index, we show a preview guide\n   * at the absolute index in the original ordering but emit the new index in the reordered list.\n   * This function converts a relative \"reordered\"\" index to an absolute \"guide\" index.\n   *\n   * For the scenario in the example above, the inputs to this function would be:\n   *     - oldIndex: 0 (the left-most index of the selected column range in the original ordering)\n   *     - newIndex: 2 (the left-most index of the selected column range in the new ordering)\n   *     - length: 3 (the number of columns to move)\n   *\n   * The return value will then be 5, the index on whose left boundary the guide should appear in\n   * the original ordering.\n   */\n  reorderedIndexToGuideIndex: function (oldIndex, newIndex, length) {\n    return newIndex <= oldIndex ? newIndex : newIndex + length;\n  },\n\n  /**\n   * Returns a copy of the provided array with the `length` contiguous elements starting at the\n   * `from` index reordered to start at the `to` index.\n   *\n   * For example, given the array [A,B,C,D,E,F], reordering the 3 contiguous elements starting at\n   * index 1 (B, C, and D) to start at index 2 would yield [A,E,B,C,D,F].\n   */\n  reorderArray: function (array, from, to, length) {\n    if (length === void 0) {\n      length = 1;\n    }\n\n    if (length === 0 || length === array.length || from === to) {\n      // return an unchanged copy\n      return array.slice();\n    }\n\n    if (length < 0 || length > array.length || from + length > array.length) {\n      return undefined;\n    }\n\n    var before = array.slice(0, from);\n    var within = array.slice(from, from + length);\n    var after = array.slice(from + length);\n    var result = [];\n    var i = 0;\n    var b = 0;\n    var w = 0;\n    var a = 0;\n\n    while (i < to) {\n      if (b < before.length) {\n        result.push(before[b]);\n        b += 1;\n      } else {\n        result.push(after[a]);\n        a += 1;\n      }\n\n      i += 1;\n    }\n\n    while (w < length) {\n      result.push(within[w]);\n      w += 1;\n      i += 1;\n    }\n\n    while (i < array.length) {\n      if (b < before.length) {\n        result.push(before[b]);\n        b += 1;\n      } else {\n        result.push(after[a]);\n        a += 1;\n      }\n\n      i += 1;\n    }\n\n    return result;\n  },\n\n  /**\n   * Returns true if the mouse event was triggered by the left mouse button.\n   */\n  isLeftClick: function (event) {\n    return event.button === 0;\n  },\n  getApproxCellHeight: function (cellText, columnWidth, approxCharWidth, approxLineHeight, horizontalPadding, numBufferLines) {\n    var numCharsInCell = cellText == null ? 0 : cellText.length;\n    var actualCellWidth = columnWidth;\n    var availableCellWidth = actualCellWidth - horizontalPadding;\n    var approxCharsPerLine = availableCellWidth / approxCharWidth;\n    var approxNumLinesDesired = Math.ceil(numCharsInCell / approxCharsPerLine) + numBufferLines;\n    var approxCellHeight = approxNumLinesDesired * approxLineHeight;\n    return approxCellHeight;\n  }\n}; // table is nearly deprecated, let's not block on code coverage\n\n/* istanbul ignore next */\n\n/**\n * Wrapper around Canvas measureText which applies some extra logic to optionally\n * exclude an element's text from the computation.\n */\n\nfunction measureTextContentWithExclusions(context, element) {\n  var elementsToExclude = element.querySelectorAll(\".\" + CLASSNAME_EXCLUDED_FROM_TEXT_MEASUREMENT);\n  var excludedElementsWidth = 0;\n\n  if (elementsToExclude && elementsToExclude.length) {\n    elementsToExclude.forEach(function (e) {\n      var excludedMetrics = context.measureText(e.textContent);\n      excludedElementsWidth += excludedMetrics.width - EXCLUDED_ICON_PLACEHOLDER_WIDTH;\n    });\n  }\n\n  var metrics = context.measureText(element.textContent);\n\n  var metricsWithExclusions = __assign(__assign({}, metrics), {\n    width: metrics.width - excludedElementsWidth\n  });\n\n  return metricsWithExclusions;\n}","map":{"version":3,"sources":["../../../src/common/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { Icon } from \"@blueprintjs/core\";\n// used to exclude icons from column header measure\nexport var CLASSNAME_EXCLUDED_FROM_TEXT_MEASUREMENT = \"bp-table-text-no-measure\";\n// supposed width of the icons placeholder\nvar EXCLUDED_ICON_PLACEHOLDER_WIDTH = Icon.SIZE_STANDARD;\n/**\n * Since Firefox doesn't provide a computed \"font\" property, we manually\n * construct it using the ordered properties that can be specifed in CSS.\n */\nvar CSS_FONT_PROPERTIES = [\"font-style\", \"font-variant\", \"font-weight\", \"font-size\", \"font-family\"];\n// table is nearly deprecated, let's not block on code coverage\n/* istanbul ignore next */\nexport var Utils = {\n    /**\n     * Invokes the callback `n` times, collecting the results in an array, which\n     * is the return value. Similar to _.times\n     */\n    times: function (n, callback) {\n        if (n < 0) {\n            throw new Error(\"[Blueprint] times() cannot be called with negative numbers.\");\n        }\n        var result = Array(n);\n        for (var index = 0; index < n; index++) {\n            result[index] = callback(index);\n        }\n        return result;\n    },\n    /**\n     * Takes an array of numbers, returns an array of numbers of the same length in which each\n     * value is the sum of current and previous values in the input array.\n     *\n     * Example input:  [10, 20, 50]\n     *         output: [10, 30, 80]\n     */\n    accumulate: function (numbers) {\n        var result = [];\n        var sum = 0;\n        for (var _i = 0, numbers_1 = numbers; _i < numbers_1.length; _i++) {\n            var num = numbers_1[_i];\n            sum += num;\n            result.push(sum);\n        }\n        return result;\n    },\n    /**\n     * Returns traditional spreadsheet-style column names\n     * e.g. (A, B, ..., Z, AA, AB, ..., ZZ, AAA, AAB, ...).\n     *\n     * Note that this isn't technically mathematically equivalent to base 26 since\n     * there is no zero element.\n     */\n    toBase26Alpha: function (num) {\n        var str = \"\";\n        while (true) {\n            var letter = num % 26;\n            // eslint-disable-next-line id-blacklist\n            str = String.fromCharCode(65 + letter) + str;\n            num = num - letter;\n            if (num <= 0) {\n                return str;\n            }\n            num = num / 26 - 1;\n        }\n    },\n    /**\n     * Returns traditional spreadsheet-style cell names\n     * e.g. (A1, B2, ..., Z44, AA1) with rows 1-indexed.\n     */\n    toBase26CellName: function (rowIndex, columnIndex) {\n        return \"\" + Utils.toBase26Alpha(columnIndex) + (rowIndex + 1);\n    },\n    /**\n     * Performs the binary search algorithm to find the index of the `value`\n     * parameter in a sorted list of numbers. If `value` is not in the list, the\n     * index where `value` can be inserted to maintain the sort is returned.\n     *\n     * Unlike a typical binary search implementation, we use a `lookup`\n     * callback to access the sorted list of numbers instead of an array. This\n     * avoids additional storage overhead.\n     *\n     * We use this to, for example, find the index of a row/col given its client\n     * coordinate.\n     *\n     * Adapted from lodash https://github.com/lodash/lodash/blob/4.11.2/lodash.js#L3579\n     *\n     * @param value - the query value\n     * @param high - the length of the sorted list of numbers\n     * @param lookup - returns the number from the list at the supplied index\n     */\n    binarySearch: function (value, high, lookup) {\n        var low = 0;\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2.0);\n            var computed = lookup(mid);\n            if (computed < value) {\n                low = mid + 1;\n            }\n            else {\n                high = mid;\n            }\n        }\n        return high;\n    },\n    /**\n     * Returns a copy of the array that will have a length of the supplied parameter.\n     * If the array is too long, it will be truncated. If it is too short, it will be\n     * filled with the suppleid `fillValue` argument.\n     *\n     * @param array - the `Array` to copy and adjust\n     * @param length - the target length of the array\n     * @param fillValue - the value to add to the array if it is too short\n     */\n    arrayOfLength: function (array, length, fillValue) {\n        if (array.length > length) {\n            return array.slice(0, length);\n        }\n        array = array.slice();\n        while (array.length < length) {\n            array.push(fillValue);\n        }\n        return array;\n    },\n    /**\n     * Takes in one full array of values and one sparse array of the same\n     * length and type. Returns a copy of the `defaults` array, where each\n     * value is replaced with the corresponding non-null value at the same\n     * index in `sparseOverrides`.\n     *\n     * @param defaults - the full array of default values\n     * @param sparseOverrides - the sparse array of override values\n     */\n    assignSparseValues: function (defaults, sparseOverrides) {\n        if (sparseOverrides == null || defaults.length !== sparseOverrides.length) {\n            return defaults;\n        }\n        defaults = defaults.slice();\n        for (var i = 0; i < defaults.length; i++) {\n            var override = sparseOverrides[i];\n            if (override != null) {\n                defaults[i] = override;\n            }\n        }\n        return defaults;\n    },\n    /**\n     * Measures the bounds of supplied element's textContent.\n     * We use the computed font from the supplied element and a non-DOM canvas\n     * context to measure the text.\n     */\n    measureElementTextContent: function (element) {\n        var context = document.createElement(\"canvas\").getContext(\"2d\");\n        var style = getComputedStyle(element, null);\n        context.font = CSS_FONT_PROPERTIES.map(function (prop) { return style.getPropertyValue(prop); }).join(\" \");\n        return measureTextContentWithExclusions(context, element);\n    },\n    /**\n     * Given a number, returns a value that is clamped within a\n     * minimum/maximum bounded range. The minimum and maximum are optional. If\n     * either is missing, that extrema limit is not applied.\n     *\n     * Assumes max >= min.\n     */\n    clamp: function (value, min, max) {\n        if (min != null && value < min) {\n            value = min;\n        }\n        if (max != null && value > max) {\n            value = max;\n        }\n        return value;\n    },\n    /**\n     * When reordering a contiguous block of rows or columns to a new index, we show a preview guide\n     * at the absolute index in the original ordering but emit the new index in the reordered list.\n     * This function converts an absolute \"guide\" index to a relative \"reordered\" index.\n     *\n     * Example: Say we want to move the first three columns two spots to the right. While we drag, a\n     * vertical guide is shown to preview where we'll be dropping the columns. (In the following\n     * ASCII art, `*` denotes a selected column, `·` denotes a cell border, and `|` denotes a\n     * vertical guide).\n     *\n     *     Before mousedown:\n     *     · 0 · 1 · 2 · 3 · 4 · 5 ·\n     *       *   *   *\n     *\n     *     During mousemove two spots to the right:\n     *     · 0 · 1 · 2 · 3 · 4 | 5 ·\n     *       *   *   *\n     *\n     *     After mouseup:\n     *     · 3 · 4 · 0 · 1 · 2 · 5 ·\n     *               *   *   *\n     *\n     * Note that moving the three columns beyond index 4 effectively moves them two spots rightward.\n     *\n     * In this case, the inputs to this function would be:\n     *     - oldIndex: 0 (the left-most index of the selected column range in the original ordering)\n     *     - newIndex: 5 (the index on whose left boundary the guide appears in the original ordering)\n     *     - length: 3 (the number of columns to move)\n     *\n     * The return value will then be 2, the left-most index of the columns in the new ordering.\n     */\n    guideIndexToReorderedIndex: function (oldIndex, newIndex, length) {\n        if (newIndex < oldIndex) {\n            return newIndex;\n        }\n        else if (oldIndex <= newIndex && newIndex < oldIndex + length) {\n            return oldIndex;\n        }\n        else {\n            return Math.max(0, newIndex - length);\n        }\n    },\n    /**\n     * When reordering a contiguous block of rows or columns to a new index, we show a preview guide\n     * at the absolute index in the original ordering but emit the new index in the reordered list.\n     * This function converts a relative \"reordered\"\" index to an absolute \"guide\" index.\n     *\n     * For the scenario in the example above, the inputs to this function would be:\n     *     - oldIndex: 0 (the left-most index of the selected column range in the original ordering)\n     *     - newIndex: 2 (the left-most index of the selected column range in the new ordering)\n     *     - length: 3 (the number of columns to move)\n     *\n     * The return value will then be 5, the index on whose left boundary the guide should appear in\n     * the original ordering.\n     */\n    reorderedIndexToGuideIndex: function (oldIndex, newIndex, length) {\n        return newIndex <= oldIndex ? newIndex : newIndex + length;\n    },\n    /**\n     * Returns a copy of the provided array with the `length` contiguous elements starting at the\n     * `from` index reordered to start at the `to` index.\n     *\n     * For example, given the array [A,B,C,D,E,F], reordering the 3 contiguous elements starting at\n     * index 1 (B, C, and D) to start at index 2 would yield [A,E,B,C,D,F].\n     */\n    reorderArray: function (array, from, to, length) {\n        if (length === void 0) { length = 1; }\n        if (length === 0 || length === array.length || from === to) {\n            // return an unchanged copy\n            return array.slice();\n        }\n        if (length < 0 || length > array.length || from + length > array.length) {\n            return undefined;\n        }\n        var before = array.slice(0, from);\n        var within = array.slice(from, from + length);\n        var after = array.slice(from + length);\n        var result = [];\n        var i = 0;\n        var b = 0;\n        var w = 0;\n        var a = 0;\n        while (i < to) {\n            if (b < before.length) {\n                result.push(before[b]);\n                b += 1;\n            }\n            else {\n                result.push(after[a]);\n                a += 1;\n            }\n            i += 1;\n        }\n        while (w < length) {\n            result.push(within[w]);\n            w += 1;\n            i += 1;\n        }\n        while (i < array.length) {\n            if (b < before.length) {\n                result.push(before[b]);\n                b += 1;\n            }\n            else {\n                result.push(after[a]);\n                a += 1;\n            }\n            i += 1;\n        }\n        return result;\n    },\n    /**\n     * Returns true if the mouse event was triggered by the left mouse button.\n     */\n    isLeftClick: function (event) {\n        return event.button === 0;\n    },\n    getApproxCellHeight: function (cellText, columnWidth, approxCharWidth, approxLineHeight, horizontalPadding, numBufferLines) {\n        var numCharsInCell = cellText == null ? 0 : cellText.length;\n        var actualCellWidth = columnWidth;\n        var availableCellWidth = actualCellWidth - horizontalPadding;\n        var approxCharsPerLine = availableCellWidth / approxCharWidth;\n        var approxNumLinesDesired = Math.ceil(numCharsInCell / approxCharsPerLine) + numBufferLines;\n        var approxCellHeight = approxNumLinesDesired * approxLineHeight;\n        return approxCellHeight;\n    },\n};\n// table is nearly deprecated, let's not block on code coverage\n/* istanbul ignore next */\n/**\n * Wrapper around Canvas measureText which applies some extra logic to optionally\n * exclude an element's text from the computation.\n */\nfunction measureTextContentWithExclusions(context, element) {\n    var elementsToExclude = element.querySelectorAll(\".\" + CLASSNAME_EXCLUDED_FROM_TEXT_MEASUREMENT);\n    var excludedElementsWidth = 0;\n    if (elementsToExclude && elementsToExclude.length) {\n        elementsToExclude.forEach(function (e) {\n            var excludedMetrics = context.measureText(e.textContent);\n            excludedElementsWidth += excludedMetrics.width - EXCLUDED_ICON_PLACEHOLDER_WIDTH;\n        });\n    }\n    var metrics = context.measureText(element.textContent);\n    var metricsWithExclusions = __assign(__assign({}, metrics), { width: metrics.width - excludedElementsWidth });\n    return metricsWithExclusions;\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}