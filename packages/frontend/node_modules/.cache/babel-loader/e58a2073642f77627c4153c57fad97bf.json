{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { RegionCardinality, Regions } from \"../regions\";\nimport * as Classes from \"./classes\";\nimport { Rect } from \"./rect\";\nimport { Utils } from \"./utils\";\n/**\n * This class manages the sizes of grid cells using arrays of individual row/column sizes.\n */\n\nvar Grid =\n/** @class */\nfunction () {\n  /**\n   * This constructor accumulates the heights and widths in `O(n)`, saving\n   * time in later calculations.\n   *\n   * @param bleed - The number of rows/cols that we expand beyond the\n   *     viewport (on all sides). This helps avoid displaying an empty\n   *     viewport when the user scrolls quickly.\n   */\n  function Grid(rowHeights, columnWidths, bleed, ghostHeight, ghostWidth) {\n    var _this = this;\n\n    if (bleed === void 0) {\n      bleed = Grid.DEFAULT_BLEED;\n    }\n\n    if (ghostHeight === void 0) {\n      ghostHeight = Grid.DEFAULT_GHOST_HEIGHT;\n    }\n\n    if (ghostWidth === void 0) {\n      ghostWidth = Grid.DEFAULT_GHOST_WIDTH;\n    }\n\n    this.getCumulativeWidthBefore = function (index) {\n      return index === 0 ? 0 : _this.getCumulativeWidthAt(index - 1);\n    };\n\n    this.getCumulativeWidthAt = function (index) {\n      if (_this.numCols === 0) {\n        return _this.ghostWidth * index;\n      } else if (index >= _this.numCols) {\n        return _this.cumulativeColumnWidths[_this.numCols - 1] + _this.ghostWidth * (index - _this.numCols + 1);\n      } else {\n        return _this.cumulativeColumnWidths[index];\n      }\n    };\n\n    this.getCumulativeHeightBefore = function (index) {\n      return index === 0 ? 0 : _this.getCumulativeHeightAt(index - 1);\n    };\n\n    this.getCumulativeHeightAt = function (index) {\n      if (_this.numRows === 0) {\n        return _this.ghostHeight * index;\n      } else if (index >= _this.numRows) {\n        return _this.cumulativeRowHeights[_this.numRows - 1] + _this.ghostHeight * (index - _this.numRows + 1);\n      } else {\n        return _this.cumulativeRowHeights[index];\n      }\n    };\n\n    this.columnWidths = columnWidths;\n    this.rowHeights = rowHeights;\n    this.cumulativeColumnWidths = Utils.accumulate(columnWidths);\n    this.cumulativeRowHeights = Utils.accumulate(rowHeights);\n    this.numCols = columnWidths.length;\n    this.numRows = rowHeights.length;\n    this.bleed = bleed;\n    this.ghostHeight = ghostHeight;\n    this.ghostWidth = ghostWidth;\n  }\n  /**\n   * Returns the `Rect` bounds of a cell in scrollpane client space.\n   *\n   * Scrollpane client coordinate space uses the origin of the scrollpane\n   * client (the inside part that you're moving around).\n   *\n   * For example, let's say you're scrolling around a block of 1000 x 1000\n   * cells. Regardless where you've scrolled, the first cell is always at\n   * 0,0 in scrollpane client space. the cell to the right of it is always\n   * at, e.g., 100,0.\n   */\n\n\n  Grid.prototype.getCellRect = function (rowIndex, columnIndex) {\n    var height = this.rowHeights[rowIndex];\n    var top = this.cumulativeRowHeights[rowIndex] - height;\n    var width = this.columnWidths[columnIndex];\n    var left = this.cumulativeColumnWidths[columnIndex] - width;\n    return new Rect(left, top, width, height);\n  };\n  /**\n   * Returns the `Rect` bounds of a cell in scrollpane client space.\n   *\n   * If the cell is beyond the bounds of the user-defined table cells, it is\n   * considered a \"ghost\" cell. If a width/height is not defined for that\n   * row/column, we use the default width/height.\n   */\n\n\n  Grid.prototype.getGhostCellRect = function (rowIndex, columnIndex) {\n    var left = 0;\n    var top = 0;\n    var width = 0;\n    var height = 0;\n\n    if (rowIndex >= this.rowHeights.length) {\n      height = this.ghostHeight;\n      top = this.getHeight() + this.ghostHeight * (rowIndex - this.numRows);\n    } else {\n      height = this.rowHeights[rowIndex];\n      top = this.cumulativeRowHeights[rowIndex] - height;\n    }\n\n    if (columnIndex >= this.columnWidths.length) {\n      width = this.ghostWidth;\n      left = this.getWidth() + this.ghostWidth * (columnIndex - this.numCols);\n    } else {\n      width = this.columnWidths[columnIndex];\n      left = this.cumulativeColumnWidths[columnIndex] - width;\n    }\n\n    return new Rect(left, top, width, height);\n  };\n  /**\n   * Returns the `Rect` with the base coordinate and height of the specified row.\n   */\n\n\n  Grid.prototype.getRowRect = function (rowIndex) {\n    var height = this.rowHeights[rowIndex];\n    var top = this.cumulativeRowHeights[rowIndex] - height;\n    return new Rect(0, top, this.getWidth(), height);\n  };\n  /**\n   * Returns the `Rect` with the base coordinate and width of the specified column.\n   */\n\n\n  Grid.prototype.getColumnRect = function (columnIndex) {\n    var width = this.columnWidths[columnIndex];\n    var left = this.cumulativeColumnWidths[columnIndex] - width;\n    return new Rect(left, 0, width, this.getHeight());\n  };\n  /**\n   * Returns the total width of the entire grid\n   */\n\n\n  Grid.prototype.getWidth = function () {\n    return this.numCols === 0 ? 0 : this.cumulativeColumnWidths[this.numCols - 1];\n  };\n  /**\n   * Returns the total width of the entire grid\n   */\n\n\n  Grid.prototype.getHeight = function () {\n    return this.numRows === 0 ? 0 : this.cumulativeRowHeights[this.numRows - 1];\n  };\n  /**\n   * Returns the `Rect` bounds of entire grid\n   */\n\n\n  Grid.prototype.getRect = function () {\n    return new Rect(0, 0, this.getWidth(), this.getHeight());\n  };\n  /**\n   * Maps each cell that intersects with the given `Rect` argument. The\n   * indices of iteration are extended in both directions by the integer\n   * `bleed` class property, then are clamped between 0 and the number of\n   * rows/columns.\n   *\n   * Uses a binary search for each of the 4 edges of the bounds, resulting\n   * in a runtime of `O(log(rows) + log(cols))` plus the `O(irows * icols)`\n   * iteration of intersecting cells.\n   */\n\n\n  Grid.prototype.mapCellsInRect = function (rect, callback) {\n    var results = [];\n\n    if (rect == null) {\n      return results;\n    }\n\n    var _a = this.getRowIndicesInRect(rect),\n        rowIndexStart = _a.rowIndexStart,\n        rowIndexEnd = _a.rowIndexEnd;\n\n    var _b = this.getColumnIndicesInRect(rect),\n        columnIndexStart = _b.columnIndexStart,\n        columnIndexEnd = _b.columnIndexEnd;\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n        results.push(callback(rowIndex, columnIndex));\n      }\n    }\n\n    return results;\n  };\n  /**\n   * Maps each row that intersects with the given `Rect` argument.\n   *\n   * See Grid.mapCellsInRect for more details.\n   */\n\n\n  Grid.prototype.mapRowsInRect = function (rect, callback) {\n    var results = [];\n\n    if (rect == null) {\n      return results;\n    }\n\n    var _a = this.getRowIndicesInRect(rect),\n        rowIndexStart = _a.rowIndexStart,\n        rowIndexEnd = _a.rowIndexEnd;\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      results.push(callback(rowIndex));\n    }\n\n    return results;\n  };\n  /**\n   * Maps each column that intersects with the given `Rect` argument.\n   *\n   * See Grid.mapCellsInRect for more details.\n   */\n\n\n  Grid.prototype.mapColumnsInRect = function (rect, callback) {\n    var results = [];\n\n    if (rect == null) {\n      return results;\n    }\n\n    var _a = this.getColumnIndicesInRect(rect),\n        columnIndexStart = _a.columnIndexStart,\n        columnIndexEnd = _a.columnIndexEnd;\n\n    for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n      results.push(callback(columnIndex));\n    }\n\n    return results;\n  };\n  /**\n   * Returns the start and end indices of rows that intersect with the given\n   * `Rect` argument.\n   */\n\n\n  Grid.prototype.getRowIndicesInRect = function (rect, includeGhostCells, limit) {\n    if (includeGhostCells === void 0) {\n      includeGhostCells = false;\n    }\n\n    if (limit === void 0) {\n      limit = Grid.DEFAULT_MAX_ROWS;\n    }\n\n    if (rect == null) {\n      return {\n        rowIndexEnd: 0,\n        rowIndexStart: 0\n      };\n    }\n\n    var searchEnd = includeGhostCells ? Math.max(this.numRows, Grid.DEFAULT_MAX_ROWS) : this.numRows;\n\n    var _a = this.getIndicesInInterval(rect.top, rect.top + rect.height, searchEnd, !includeGhostCells, this.getCumulativeHeightAt),\n        start = _a.start,\n        end = _a.end;\n\n    var rowIndexEnd = limit > 0 && end - start > limit ? start + limit : end;\n    return {\n      rowIndexEnd: rowIndexEnd,\n      rowIndexStart: start\n    };\n  };\n  /**\n   * Returns the start and end indices of columns that intersect with the\n   * given `Rect` argument.\n   */\n\n\n  Grid.prototype.getColumnIndicesInRect = function (rect, includeGhostCells, limit) {\n    if (includeGhostCells === void 0) {\n      includeGhostCells = false;\n    }\n\n    if (limit === void 0) {\n      limit = Grid.DEFAULT_MAX_COLUMNS;\n    }\n\n    if (rect == null) {\n      return {\n        columnIndexEnd: 0,\n        columnIndexStart: 0\n      };\n    }\n\n    var searchEnd = includeGhostCells ? Math.max(this.numCols, Grid.DEFAULT_MAX_COLUMNS) : this.numCols;\n\n    var _a = this.getIndicesInInterval(rect.left, rect.left + rect.width, searchEnd, !includeGhostCells, this.getCumulativeWidthAt),\n        start = _a.start,\n        end = _a.end;\n\n    var columnIndexEnd = limit > 0 && end - start > limit ? start + limit : end;\n    return {\n      columnIndexEnd: columnIndexEnd,\n      columnIndexStart: start\n    };\n  };\n\n  Grid.prototype.isGhostIndex = function (rowIndex, columnIndex) {\n    return rowIndex >= this.numRows || columnIndex >= this.numCols;\n  };\n\n  Grid.prototype.isGhostColumn = function (columnIndex) {\n    return columnIndex >= this.numCols;\n  };\n\n  Grid.prototype.getExtremaClasses = function (rowIndex, columnIndex, rowEnd, columnEnd) {\n    if (rowIndex === rowEnd && columnIndex === columnEnd) {\n      return [Classes.TABLE_LAST_IN_COLUMN, Classes.TABLE_LAST_IN_ROW];\n    }\n\n    if (rowIndex === rowEnd) {\n      return [Classes.TABLE_LAST_IN_COLUMN];\n    }\n\n    if (columnIndex === columnEnd) {\n      return [Classes.TABLE_LAST_IN_ROW];\n    }\n\n    return [];\n  };\n\n  Grid.prototype.getRegionStyle = function (region) {\n    var cardinality = Regions.getRegionCardinality(region);\n\n    switch (cardinality) {\n      case RegionCardinality.CELLS:\n        {\n          var _a = region.rows,\n              rowStart = _a[0],\n              rowEnd = _a[1];\n          var _b = region.cols,\n              colStart = _b[0],\n              colEnd = _b[1]; // if the region is outside the bounds of the table, don't display it\n\n          if (this.isGhostIndex(rowStart, colStart) || this.isGhostIndex(rowEnd, colEnd)) {\n            return {\n              display: \"none\"\n            };\n          }\n\n          var cellRect0 = this.getCellRect(rowStart, colStart);\n          var cellRect1 = this.getCellRect(rowEnd, colEnd);\n          var offsetLeft = colStart === 0 ? 0 : 1;\n          var offsetTop = rowStart === 0 ? 0 : 1;\n          var rect = cellRect0.union(cellRect1);\n          rect.height += offsetTop;\n          rect.left -= offsetLeft;\n          rect.width += offsetLeft;\n          rect.top -= offsetTop;\n          return __assign(__assign({}, rect.style()), {\n            display: \"block\"\n          });\n        }\n\n      case RegionCardinality.FULL_COLUMNS:\n        {\n          var _c = region.cols,\n              colStart = _c[0],\n              colEnd = _c[1]; // if the region is outside the bounds of the table, don't display it\n\n          if (this.isGhostIndex(0, colStart) || this.isGhostIndex(0, colEnd)) {\n            return {\n              display: \"none\"\n            };\n          }\n\n          var cellRect0 = this.getCellRect(0, colStart);\n          var cellRect1 = this.getCellRect(0, colEnd);\n          var rect = cellRect0.union(cellRect1);\n          var offsetLeft = colStart === 0 ? 0 : 1;\n          return {\n            bottom: 0,\n            display: \"block\",\n            left: rect.left - offsetLeft,\n            top: 0,\n            width: rect.width + offsetLeft\n          };\n        }\n\n      case RegionCardinality.FULL_ROWS:\n        {\n          var _d = region.rows,\n              rowStart = _d[0],\n              rowEnd = _d[1]; // if the region is outside the bounds of the table, don't display it\n\n          if (this.isGhostIndex(rowStart, 0) || this.isGhostIndex(rowEnd, 0)) {\n            return {\n              display: \"none\"\n            };\n          }\n\n          var cellRect0 = this.getCellRect(rowStart, 0);\n          var cellRect1 = this.getCellRect(rowEnd, 0);\n          var rect = cellRect0.union(cellRect1);\n          var offsetTop = rowStart === 0 ? 0 : 1;\n          return {\n            display: \"block\",\n            height: rect.height + offsetTop,\n            left: 0,\n            right: 0,\n            top: rect.top - offsetTop\n          };\n        }\n\n      case RegionCardinality.FULL_TABLE:\n        return {\n          bottom: 0,\n          display: \"block\",\n          left: 0,\n          right: 0,\n          top: 0\n        };\n\n      default:\n        return {\n          display: \"none\"\n        };\n    }\n  };\n\n  Grid.prototype.getIndicesInInterval = function (min, max, count, useEndBleed, lookup) {\n    var start = Utils.binarySearch(min, count - 1, lookup);\n    var end = Utils.binarySearch(max, count - 1, lookup); // correct exact pixel alignment\n\n    if (start >= 0 && min === lookup(start)) {\n      start += 1;\n    } // apply bounded bleeds\n\n\n    start = Math.max(0, start - this.bleed);\n\n    if (useEndBleed) {\n      end = Math.min(count - 1, end + this.bleed);\n    } else {\n      end = Math.min(count - 1, end);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  Grid.DEFAULT_BLEED = 3;\n  Grid.DEFAULT_MAX_COLUMNS = 50;\n  Grid.DEFAULT_MAX_ROWS = 200;\n  Grid.DEFAULT_GHOST_HEIGHT = 20;\n  Grid.DEFAULT_GHOST_WIDTH = 150;\n  return Grid;\n}();\n\nexport { Grid };","map":{"version":3,"sources":["../../../src/common/grid.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;AAcG;;AAIH,SAAkB,iBAAlB,EAAqC,OAArC,QAAoD,YAApD;AACA,OAAO,KAAK,OAAZ,MAAyB,WAAzB;AACA,SAAS,IAAT,QAAqB,QAArB;AACA,SAAS,KAAT,QAAsB,SAAtB;AAgBA;;AAEG;;AACH,IAAA,IAAA;AAAA;AAAA,YAAA;AA6BI;;;;;;;AAOG;AACH,WAAA,IAAA,CACI,UADJ,EAEI,YAFJ,EAGI,KAHJ,EAII,WAJJ,EAKI,UALJ,EAKyC;AALzC,QAAA,KAAA,GAAA,IAAA;;AAGI,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,IAAI,CAAC,aAAb;AAA0B;;AAC1B,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAc,IAAI,CAAC,oBAAnB;AAAuC;;AACvC,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAa,IAAI,CAAC,mBAAlB;AAAqC;;AA4TlC,SAAA,wBAAA,GAA2B,UAAC,KAAD,EAAc;AAC5C,aAAO,KAAK,KAAK,CAAV,GAAc,CAAd,GAAkB,KAAI,CAAC,oBAAL,CAA0B,KAAK,GAAG,CAAlC,CAAzB;AACH,KAFM;;AAIA,SAAA,oBAAA,GAAuB,UAAC,KAAD,EAAc;AACxC,UAAI,KAAI,CAAC,OAAL,KAAiB,CAArB,EAAwB;AACpB,eAAO,KAAI,CAAC,UAAL,GAAkB,KAAzB;AACH,OAFD,MAEO,IAAI,KAAK,IAAI,KAAI,CAAC,OAAlB,EAA2B;AAC9B,eAAO,KAAI,CAAC,sBAAL,CAA4B,KAAI,CAAC,OAAL,GAAe,CAA3C,IAAgD,KAAI,CAAC,UAAL,IAAmB,KAAK,GAAG,KAAI,CAAC,OAAb,GAAuB,CAA1C,CAAvD;AACH,OAFM,MAEA;AACH,eAAO,KAAI,CAAC,sBAAL,CAA4B,KAA5B,CAAP;AACH;AACJ,KARM;;AAUA,SAAA,yBAAA,GAA4B,UAAC,KAAD,EAAc;AAC7C,aAAO,KAAK,KAAK,CAAV,GAAc,CAAd,GAAkB,KAAI,CAAC,qBAAL,CAA2B,KAAK,GAAG,CAAnC,CAAzB;AACH,KAFM;;AAIA,SAAA,qBAAA,GAAwB,UAAC,KAAD,EAAc;AACzC,UAAI,KAAI,CAAC,OAAL,KAAiB,CAArB,EAAwB;AACpB,eAAO,KAAI,CAAC,WAAL,GAAmB,KAA1B;AACH,OAFD,MAEO,IAAI,KAAK,IAAI,KAAI,CAAC,OAAlB,EAA2B;AAC9B,eAAO,KAAI,CAAC,oBAAL,CAA0B,KAAI,CAAC,OAAL,GAAe,CAAzC,IAA8C,KAAI,CAAC,WAAL,IAAoB,KAAK,GAAG,KAAI,CAAC,OAAb,GAAuB,CAA3C,CAArD;AACH,OAFM,MAEA;AACH,eAAO,KAAI,CAAC,oBAAL,CAA0B,KAA1B,CAAP;AACH;AACJ,KARM;;AA5UH,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,UAAL,GAAkB,UAAlB;AACA,SAAK,sBAAL,GAA8B,KAAK,CAAC,UAAN,CAAiB,YAAjB,CAA9B;AACA,SAAK,oBAAL,GAA4B,KAAK,CAAC,UAAN,CAAiB,UAAjB,CAA5B;AACA,SAAK,OAAL,GAAe,YAAY,CAAC,MAA5B;AACA,SAAK,OAAL,GAAe,UAAU,CAAC,MAA1B;AACA,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,WAAL,GAAmB,WAAnB;AACA,SAAK,UAAL,GAAkB,UAAlB;AACH;AAED;;;;;;;;;;AAUG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAmB,QAAnB,EAAqC,WAArC,EAAwD;AACpD,QAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,QAAhB,CAAf;AACA,QAAM,GAAG,GAAG,KAAK,oBAAL,CAA0B,QAA1B,IAAsC,MAAlD;AACA,QAAM,KAAK,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAAd;AACA,QAAM,IAAI,GAAG,KAAK,sBAAL,CAA4B,WAA5B,IAA2C,KAAxD;AACA,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,GAAf,EAAoB,KAApB,EAA2B,MAA3B,CAAP;AACH,GANM;AAQP;;;;;;AAMG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAAwB,QAAxB,EAA0C,WAA1C,EAA6D;AACzD,QAAI,IAAI,GAAG,CAAX;AACA,QAAI,GAAG,GAAG,CAAV;AACA,QAAI,KAAK,GAAG,CAAZ;AACA,QAAI,MAAM,GAAG,CAAb;;AACA,QAAI,QAAQ,IAAI,KAAK,UAAL,CAAgB,MAAhC,EAAwC;AACpC,MAAA,MAAM,GAAG,KAAK,WAAd;AACA,MAAA,GAAG,GAAG,KAAK,SAAL,KAAmB,KAAK,WAAL,IAAoB,QAAQ,GAAG,KAAK,OAApC,CAAzB;AACH,KAHD,MAGO;AACH,MAAA,MAAM,GAAG,KAAK,UAAL,CAAgB,QAAhB,CAAT;AACA,MAAA,GAAG,GAAG,KAAK,oBAAL,CAA0B,QAA1B,IAAsC,MAA5C;AACH;;AAED,QAAI,WAAW,IAAI,KAAK,YAAL,CAAkB,MAArC,EAA6C;AACzC,MAAA,KAAK,GAAG,KAAK,UAAb;AACA,MAAA,IAAI,GAAG,KAAK,QAAL,KAAkB,KAAK,UAAL,IAAmB,WAAW,GAAG,KAAK,OAAtC,CAAzB;AACH,KAHD,MAGO;AACH,MAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAAR;AACA,MAAA,IAAI,GAAG,KAAK,sBAAL,CAA4B,WAA5B,IAA2C,KAAlD;AACH;;AACD,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,GAAf,EAAoB,KAApB,EAA2B,MAA3B,CAAP;AACH,GArBM;AAuBP;;AAEG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,QAAlB,EAAkC;AAC9B,QAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,QAAhB,CAAf;AACA,QAAM,GAAG,GAAG,KAAK,oBAAL,CAA0B,QAA1B,IAAsC,MAAlD;AACA,WAAO,IAAI,IAAJ,CAAS,CAAT,EAAY,GAAZ,EAAiB,KAAK,QAAL,EAAjB,EAAkC,MAAlC,CAAP;AACH,GAJM;AAMP;;AAEG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAAwC;AACpC,QAAM,KAAK,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAAd;AACA,QAAM,IAAI,GAAG,KAAK,sBAAL,CAA4B,WAA5B,IAA2C,KAAxD;AACA,WAAO,IAAI,IAAJ,CAAS,IAAT,EAAe,CAAf,EAAkB,KAAlB,EAAyB,KAAK,SAAL,EAAzB,CAAP;AACH,GAJM;AAMP;;AAEG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,QAAA,GAAP,YAAA;AACI,WAAO,KAAK,OAAL,KAAiB,CAAjB,GAAqB,CAArB,GAAyB,KAAK,sBAAL,CAA4B,KAAK,OAAL,GAAe,CAA3C,CAAhC;AACH,GAFM;AAIP;;AAEG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA;AACI,WAAO,KAAK,OAAL,KAAiB,CAAjB,GAAqB,CAArB,GAAyB,KAAK,oBAAL,CAA0B,KAAK,OAAL,GAAe,CAAzC,CAAhC;AACH,GAFM;AAIP;;AAEG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA;AACI,WAAO,IAAI,IAAJ,CAAS,CAAT,EAAY,CAAZ,EAAe,KAAK,QAAL,EAAf,EAAgC,KAAK,SAAL,EAAhC,CAAP;AACH,GAFM;AAIP;;;;;;;;;AASG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAyB,IAAzB,EAAqC,QAArC,EAA6D;AACzD,QAAM,OAAO,GAAQ,EAArB;;AACA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,aAAO,OAAP;AACH;;AAEK,QAAA,EAAA,GAAiC,KAAK,mBAAL,CAAyB,IAAzB,CAAjC;AAAA,QAAE,aAAa,GAAA,EAAA,CAAA,aAAf;AAAA,QAAiB,WAAW,GAAA,EAAA,CAAA,WAA5B;;AACA,QAAA,EAAA,GAAuC,KAAK,sBAAL,CAA4B,IAA5B,CAAvC;AAAA,QAAE,gBAAgB,GAAA,EAAA,CAAA,gBAAlB;AAAA,QAAoB,cAAc,GAAA,EAAA,CAAA,cAAlC;;AACN,SAAK,IAAI,QAAQ,GAAG,aAApB,EAAmC,QAAQ,IAAI,WAA/C,EAA4D,QAAQ,EAApE,EAAwE;AACpE,WAAK,IAAI,WAAW,GAAG,gBAAvB,EAAyC,WAAW,IAAI,cAAxD,EAAwE,WAAW,EAAnF,EAAuF;AACnF,QAAA,OAAO,CAAC,IAAR,CAAa,QAAQ,CAAC,QAAD,EAAW,WAAX,CAArB;AACH;AACJ;;AACD,WAAO,OAAP;AACH,GAdM;AAgBP;;;;AAIG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAwB,IAAxB,EAAoC,QAApC,EAA2D;AACvD,QAAM,OAAO,GAAQ,EAArB;;AACA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,aAAO,OAAP;AACH;;AAEK,QAAA,EAAA,GAAiC,KAAK,mBAAL,CAAyB,IAAzB,CAAjC;AAAA,QAAE,aAAa,GAAA,EAAA,CAAA,aAAf;AAAA,QAAiB,WAAW,GAAA,EAAA,CAAA,WAA5B;;AACN,SAAK,IAAI,QAAQ,GAAG,aAApB,EAAmC,QAAQ,IAAI,WAA/C,EAA4D,QAAQ,EAApE,EAAwE;AACpE,MAAA,OAAO,CAAC,IAAR,CAAa,QAAQ,CAAC,QAAD,CAArB;AACH;;AACD,WAAO,OAAP;AACH,GAXM;AAaP;;;;AAIG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,gBAAA,GAAP,UAA2B,IAA3B,EAAuC,QAAvC,EAAiE;AAC7D,QAAM,OAAO,GAAQ,EAArB;;AACA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,aAAO,OAAP;AACH;;AAEK,QAAA,EAAA,GAAuC,KAAK,sBAAL,CAA4B,IAA5B,CAAvC;AAAA,QAAE,gBAAgB,GAAA,EAAA,CAAA,gBAAlB;AAAA,QAAoB,cAAc,GAAA,EAAA,CAAA,cAAlC;;AACN,SAAK,IAAI,WAAW,GAAG,gBAAvB,EAAyC,WAAW,IAAI,cAAxD,EAAwE,WAAW,EAAnF,EAAuF;AACnF,MAAA,OAAO,CAAC,IAAR,CAAa,QAAQ,CAAC,WAAD,CAArB;AACH;;AACD,WAAO,OAAP;AACH,GAXM;AAaP;;;AAGG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,mBAAA,GAAP,UAA2B,IAA3B,EAAuC,iBAAvC,EAAkE,KAAlE,EAA+F;AAAxD,QAAA,iBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAyB;;AAAE,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,IAAI,CAAC,gBAAb;AAA6B;;AAC3F,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,aAAO;AAAE,QAAA,WAAW,EAAE,CAAf;AAAkB,QAAA,aAAa,EAAE;AAAjC,OAAP;AACH;;AAED,QAAM,SAAS,GAAG,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,OAAd,EAAuB,IAAI,CAAC,gBAA5B,CAAH,GAAmD,KAAK,OAA3F;;AACM,QAAA,EAAA,GAAiB,KAAK,oBAAL,CACnB,IAAI,CAAC,GADc,EAEnB,IAAI,CAAC,GAAL,GAAW,IAAI,CAAC,MAFG,EAGnB,SAHmB,EAInB,CAAC,iBAJkB,EAKnB,KAAK,qBALc,CAAjB;AAAA,QAAE,KAAK,GAAA,EAAA,CAAA,KAAP;AAAA,QAAS,GAAG,GAAA,EAAA,CAAA,GAAZ;;AAON,QAAM,WAAW,GAAG,KAAK,GAAG,CAAR,IAAa,GAAG,GAAG,KAAN,GAAc,KAA3B,GAAmC,KAAK,GAAG,KAA3C,GAAmD,GAAvE;AAEA,WAAO;AACH,MAAA,WAAW,EAAA,WADR;AAEH,MAAA,aAAa,EAAE;AAFZ,KAAP;AAIH,GAnBM;AAqBP;;;AAGG;;;AACI,EAAA,IAAA,CAAA,SAAA,CAAA,sBAAA,GAAP,UACI,IADJ,EAEI,iBAFJ,EAGI,KAHJ,EAGoC;AADhC,QAAA,iBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,iBAAA,GAAA,KAAA;AAAyB;;AACzB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAQ,IAAI,CAAC,mBAAb;AAAgC;;AAEhC,QAAI,IAAI,IAAI,IAAZ,EAAkB;AACd,aAAO;AAAE,QAAA,cAAc,EAAE,CAAlB;AAAqB,QAAA,gBAAgB,EAAE;AAAvC,OAAP;AACH;;AAED,QAAM,SAAS,GAAG,iBAAiB,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,OAAd,EAAuB,IAAI,CAAC,mBAA5B,CAAH,GAAsD,KAAK,OAA9F;;AACM,QAAA,EAAA,GAAiB,KAAK,oBAAL,CACnB,IAAI,CAAC,IADc,EAEnB,IAAI,CAAC,IAAL,GAAY,IAAI,CAAC,KAFE,EAGnB,SAHmB,EAInB,CAAC,iBAJkB,EAKnB,KAAK,oBALc,CAAjB;AAAA,QAAE,KAAK,GAAA,EAAA,CAAA,KAAP;AAAA,QAAS,GAAG,GAAA,EAAA,CAAA,GAAZ;;AAQN,QAAM,cAAc,GAAG,KAAK,GAAG,CAAR,IAAa,GAAG,GAAG,KAAN,GAAc,KAA3B,GAAmC,KAAK,GAAG,KAA3C,GAAmD,GAA1E;AAEA,WAAO;AACH,MAAA,cAAc,EAAA,cADX;AAEH,MAAA,gBAAgB,EAAE;AAFf,KAAP;AAIH,GAxBM;;AA0BA,EAAA,IAAA,CAAA,SAAA,CAAA,YAAA,GAAP,UAAoB,QAApB,EAAsC,WAAtC,EAAyD;AACrD,WAAO,QAAQ,IAAI,KAAK,OAAjB,IAA4B,WAAW,IAAI,KAAK,OAAvD;AACH,GAFM;;AAIA,EAAA,IAAA,CAAA,SAAA,CAAA,aAAA,GAAP,UAAqB,WAArB,EAAwC;AACpC,WAAO,WAAW,IAAI,KAAK,OAA3B;AACH,GAFM;;AAIA,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,GAAP,UAAyB,QAAzB,EAA2C,WAA3C,EAAgE,MAAhE,EAAgF,SAAhF,EAAiG;AAC7F,QAAI,QAAQ,KAAK,MAAb,IAAuB,WAAW,KAAK,SAA3C,EAAsD;AAClD,aAAO,CAAC,OAAO,CAAC,oBAAT,EAA+B,OAAO,CAAC,iBAAvC,CAAP;AACH;;AACD,QAAI,QAAQ,KAAK,MAAjB,EAAyB;AACrB,aAAO,CAAC,OAAO,CAAC,oBAAT,CAAP;AACH;;AACD,QAAI,WAAW,KAAK,SAApB,EAA+B;AAC3B,aAAO,CAAC,OAAO,CAAC,iBAAT,CAAP;AACH;;AACD,WAAO,EAAP;AACH,GAXM;;AAaA,EAAA,IAAA,CAAA,SAAA,CAAA,cAAA,GAAP,UAAsB,MAAtB,EAAqC;AACjC,QAAM,WAAW,GAAG,OAAO,CAAC,oBAAR,CAA6B,MAA7B,CAApB;;AACA,YAAQ,WAAR;AACI,WAAK,iBAAiB,CAAC,KAAvB;AAA8B;AACpB,cAAA,EAAA,GAAqB,MAAM,CAAC,IAA5B;AAAA,cAAC,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAT;AAAA,cAAW,MAAM,GAAA,EAAA,CAAA,CAAA,CAAjB;AACA,cAAA,EAAA,GAAqB,MAAM,CAAC,IAA5B;AAAA,cAAC,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAT;AAAA,cAAW,MAAM,GAAA,EAAA,CAAA,CAAA,CAAjB,CAFoB,CAI1B;;AACA,cAAI,KAAK,YAAL,CAAkB,QAAlB,EAA4B,QAA5B,KAAyC,KAAK,YAAL,CAAkB,MAAlB,EAA0B,MAA1B,CAA7C,EAAgF;AAC5E,mBAAO;AAAE,cAAA,OAAO,EAAE;AAAX,aAAP;AACH;;AACD,cAAM,SAAS,GAAG,KAAK,WAAL,CAAiB,QAAjB,EAA2B,QAA3B,CAAlB;AACA,cAAM,SAAS,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,MAAzB,CAAlB;AACA,cAAM,UAAU,GAAG,QAAQ,KAAK,CAAb,GAAiB,CAAjB,GAAqB,CAAxC;AACA,cAAM,SAAS,GAAG,QAAQ,KAAK,CAAb,GAAiB,CAAjB,GAAqB,CAAvC;AACA,cAAM,IAAI,GAAG,SAAS,CAAC,KAAV,CAAgB,SAAhB,CAAb;AACA,UAAA,IAAI,CAAC,MAAL,IAAe,SAAf;AACA,UAAA,IAAI,CAAC,IAAL,IAAa,UAAb;AACA,UAAA,IAAI,CAAC,KAAL,IAAc,UAAd;AACA,UAAA,IAAI,CAAC,GAAL,IAAY,SAAZ;AACA,iBAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAY,IAAI,CAAC,KAAL,EAAZ,CAAA,EAAwB;AAAE,YAAA,OAAO,EAAE;AAAX,WAAxB,CAAA;AACH;;AAED,WAAK,iBAAiB,CAAC,YAAvB;AAAqC;AAC3B,cAAA,EAAA,GAAqB,MAAM,CAAC,IAA5B;AAAA,cAAC,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAT;AAAA,cAAW,MAAM,GAAA,EAAA,CAAA,CAAA,CAAjB,CAD2B,CAGjC;;AACA,cAAI,KAAK,YAAL,CAAkB,CAAlB,EAAqB,QAArB,KAAkC,KAAK,YAAL,CAAkB,CAAlB,EAAqB,MAArB,CAAtC,EAAoE;AAChE,mBAAO;AAAE,cAAA,OAAO,EAAE;AAAX,aAAP;AACH;;AACD,cAAM,SAAS,GAAG,KAAK,WAAL,CAAiB,CAAjB,EAAoB,QAApB,CAAlB;AACA,cAAM,SAAS,GAAG,KAAK,WAAL,CAAiB,CAAjB,EAAoB,MAApB,CAAlB;AACA,cAAM,IAAI,GAAG,SAAS,CAAC,KAAV,CAAgB,SAAhB,CAAb;AACA,cAAM,UAAU,GAAG,QAAQ,KAAK,CAAb,GAAiB,CAAjB,GAAqB,CAAxC;AACA,iBAAO;AACH,YAAA,MAAM,EAAE,CADL;AAEH,YAAA,OAAO,EAAE,OAFN;AAGH,YAAA,IAAI,EAAE,IAAI,CAAC,IAAL,GAAY,UAHf;AAIH,YAAA,GAAG,EAAE,CAJF;AAKH,YAAA,KAAK,EAAE,IAAI,CAAC,KAAL,GAAa;AALjB,WAAP;AAOH;;AAED,WAAK,iBAAiB,CAAC,SAAvB;AAAkC;AACxB,cAAA,EAAA,GAAqB,MAAM,CAAC,IAA5B;AAAA,cAAC,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAT;AAAA,cAAW,MAAM,GAAA,EAAA,CAAA,CAAA,CAAjB,CADwB,CAG9B;;AACA,cAAI,KAAK,YAAL,CAAkB,QAAlB,EAA4B,CAA5B,KAAkC,KAAK,YAAL,CAAkB,MAAlB,EAA0B,CAA1B,CAAtC,EAAoE;AAChE,mBAAO;AAAE,cAAA,OAAO,EAAE;AAAX,aAAP;AACH;;AACD,cAAM,SAAS,GAAG,KAAK,WAAL,CAAiB,QAAjB,EAA2B,CAA3B,CAAlB;AACA,cAAM,SAAS,GAAG,KAAK,WAAL,CAAiB,MAAjB,EAAyB,CAAzB,CAAlB;AACA,cAAM,IAAI,GAAG,SAAS,CAAC,KAAV,CAAgB,SAAhB,CAAb;AACA,cAAM,SAAS,GAAG,QAAQ,KAAK,CAAb,GAAiB,CAAjB,GAAqB,CAAvC;AACA,iBAAO;AACH,YAAA,OAAO,EAAE,OADN;AAEH,YAAA,MAAM,EAAE,IAAI,CAAC,MAAL,GAAc,SAFnB;AAGH,YAAA,IAAI,EAAE,CAHH;AAIH,YAAA,KAAK,EAAE,CAJJ;AAKH,YAAA,GAAG,EAAE,IAAI,CAAC,GAAL,GAAW;AALb,WAAP;AAOH;;AAED,WAAK,iBAAiB,CAAC,UAAvB;AACI,eAAO;AACH,UAAA,MAAM,EAAE,CADL;AAEH,UAAA,OAAO,EAAE,OAFN;AAGH,UAAA,IAAI,EAAE,CAHH;AAIH,UAAA,KAAK,EAAE,CAJJ;AAKH,UAAA,GAAG,EAAE;AALF,SAAP;;AAQJ;AACI,eAAO;AAAE,UAAA,OAAO,EAAE;AAAX,SAAP;AAvER;AAyEH,GA3EM;;AAyGC,EAAA,IAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UACI,GADJ,EAEI,GAFJ,EAGI,KAHJ,EAII,WAJJ,EAKI,MALJ,EAKqC;AAEjC,QAAI,KAAK,GAAG,KAAK,CAAC,YAAN,CAAmB,GAAnB,EAAwB,KAAK,GAAG,CAAhC,EAAmC,MAAnC,CAAZ;AACA,QAAI,GAAG,GAAG,KAAK,CAAC,YAAN,CAAmB,GAAnB,EAAwB,KAAK,GAAG,CAAhC,EAAmC,MAAnC,CAAV,CAHiC,CAKjC;;AACA,QAAI,KAAK,IAAI,CAAT,IAAc,GAAG,KAAK,MAAM,CAAC,KAAD,CAAhC,EAAyC;AACrC,MAAA,KAAK,IAAI,CAAT;AACH,KARgC,CAUjC;;;AACA,IAAA,KAAK,GAAG,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,KAAK,GAAG,KAAK,KAAzB,CAAR;;AACA,QAAI,WAAJ,EAAiB;AACb,MAAA,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,CAAjB,EAAoB,GAAG,GAAG,KAAK,KAA/B,CAAN;AACH,KAFD,MAEO;AACH,MAAA,GAAG,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,CAAjB,EAAoB,GAApB,CAAN;AACH;;AACD,WAAO;AAAE,MAAA,KAAK,EAAA,KAAP;AAAS,MAAA,GAAG,EAAA;AAAZ,KAAP;AACH,GAvBO;;AAjYM,EAAA,IAAA,CAAA,aAAA,GAAgB,CAAhB;AAEA,EAAA,IAAA,CAAA,mBAAA,GAAsB,EAAtB;AAEA,EAAA,IAAA,CAAA,gBAAA,GAAmB,GAAnB;AAEA,EAAA,IAAA,CAAA,oBAAA,GAAuB,EAAvB;AAEA,EAAA,IAAA,CAAA,mBAAA,GAAsB,GAAtB;AAiZlB,SAAA,IAAA;AAAC,CA1ZD,EAAA;;SAAa,I","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign } from \"tslib\";\nimport { RegionCardinality, Regions } from \"../regions\";\nimport * as Classes from \"./classes\";\nimport { Rect } from \"./rect\";\nimport { Utils } from \"./utils\";\n/**\n * This class manages the sizes of grid cells using arrays of individual row/column sizes.\n */\nvar Grid = /** @class */ (function () {\n    /**\n     * This constructor accumulates the heights and widths in `O(n)`, saving\n     * time in later calculations.\n     *\n     * @param bleed - The number of rows/cols that we expand beyond the\n     *     viewport (on all sides). This helps avoid displaying an empty\n     *     viewport when the user scrolls quickly.\n     */\n    function Grid(rowHeights, columnWidths, bleed, ghostHeight, ghostWidth) {\n        var _this = this;\n        if (bleed === void 0) { bleed = Grid.DEFAULT_BLEED; }\n        if (ghostHeight === void 0) { ghostHeight = Grid.DEFAULT_GHOST_HEIGHT; }\n        if (ghostWidth === void 0) { ghostWidth = Grid.DEFAULT_GHOST_WIDTH; }\n        this.getCumulativeWidthBefore = function (index) {\n            return index === 0 ? 0 : _this.getCumulativeWidthAt(index - 1);\n        };\n        this.getCumulativeWidthAt = function (index) {\n            if (_this.numCols === 0) {\n                return _this.ghostWidth * index;\n            }\n            else if (index >= _this.numCols) {\n                return _this.cumulativeColumnWidths[_this.numCols - 1] + _this.ghostWidth * (index - _this.numCols + 1);\n            }\n            else {\n                return _this.cumulativeColumnWidths[index];\n            }\n        };\n        this.getCumulativeHeightBefore = function (index) {\n            return index === 0 ? 0 : _this.getCumulativeHeightAt(index - 1);\n        };\n        this.getCumulativeHeightAt = function (index) {\n            if (_this.numRows === 0) {\n                return _this.ghostHeight * index;\n            }\n            else if (index >= _this.numRows) {\n                return _this.cumulativeRowHeights[_this.numRows - 1] + _this.ghostHeight * (index - _this.numRows + 1);\n            }\n            else {\n                return _this.cumulativeRowHeights[index];\n            }\n        };\n        this.columnWidths = columnWidths;\n        this.rowHeights = rowHeights;\n        this.cumulativeColumnWidths = Utils.accumulate(columnWidths);\n        this.cumulativeRowHeights = Utils.accumulate(rowHeights);\n        this.numCols = columnWidths.length;\n        this.numRows = rowHeights.length;\n        this.bleed = bleed;\n        this.ghostHeight = ghostHeight;\n        this.ghostWidth = ghostWidth;\n    }\n    /**\n     * Returns the `Rect` bounds of a cell in scrollpane client space.\n     *\n     * Scrollpane client coordinate space uses the origin of the scrollpane\n     * client (the inside part that you're moving around).\n     *\n     * For example, let's say you're scrolling around a block of 1000 x 1000\n     * cells. Regardless where you've scrolled, the first cell is always at\n     * 0,0 in scrollpane client space. the cell to the right of it is always\n     * at, e.g., 100,0.\n     */\n    Grid.prototype.getCellRect = function (rowIndex, columnIndex) {\n        var height = this.rowHeights[rowIndex];\n        var top = this.cumulativeRowHeights[rowIndex] - height;\n        var width = this.columnWidths[columnIndex];\n        var left = this.cumulativeColumnWidths[columnIndex] - width;\n        return new Rect(left, top, width, height);\n    };\n    /**\n     * Returns the `Rect` bounds of a cell in scrollpane client space.\n     *\n     * If the cell is beyond the bounds of the user-defined table cells, it is\n     * considered a \"ghost\" cell. If a width/height is not defined for that\n     * row/column, we use the default width/height.\n     */\n    Grid.prototype.getGhostCellRect = function (rowIndex, columnIndex) {\n        var left = 0;\n        var top = 0;\n        var width = 0;\n        var height = 0;\n        if (rowIndex >= this.rowHeights.length) {\n            height = this.ghostHeight;\n            top = this.getHeight() + this.ghostHeight * (rowIndex - this.numRows);\n        }\n        else {\n            height = this.rowHeights[rowIndex];\n            top = this.cumulativeRowHeights[rowIndex] - height;\n        }\n        if (columnIndex >= this.columnWidths.length) {\n            width = this.ghostWidth;\n            left = this.getWidth() + this.ghostWidth * (columnIndex - this.numCols);\n        }\n        else {\n            width = this.columnWidths[columnIndex];\n            left = this.cumulativeColumnWidths[columnIndex] - width;\n        }\n        return new Rect(left, top, width, height);\n    };\n    /**\n     * Returns the `Rect` with the base coordinate and height of the specified row.\n     */\n    Grid.prototype.getRowRect = function (rowIndex) {\n        var height = this.rowHeights[rowIndex];\n        var top = this.cumulativeRowHeights[rowIndex] - height;\n        return new Rect(0, top, this.getWidth(), height);\n    };\n    /**\n     * Returns the `Rect` with the base coordinate and width of the specified column.\n     */\n    Grid.prototype.getColumnRect = function (columnIndex) {\n        var width = this.columnWidths[columnIndex];\n        var left = this.cumulativeColumnWidths[columnIndex] - width;\n        return new Rect(left, 0, width, this.getHeight());\n    };\n    /**\n     * Returns the total width of the entire grid\n     */\n    Grid.prototype.getWidth = function () {\n        return this.numCols === 0 ? 0 : this.cumulativeColumnWidths[this.numCols - 1];\n    };\n    /**\n     * Returns the total width of the entire grid\n     */\n    Grid.prototype.getHeight = function () {\n        return this.numRows === 0 ? 0 : this.cumulativeRowHeights[this.numRows - 1];\n    };\n    /**\n     * Returns the `Rect` bounds of entire grid\n     */\n    Grid.prototype.getRect = function () {\n        return new Rect(0, 0, this.getWidth(), this.getHeight());\n    };\n    /**\n     * Maps each cell that intersects with the given `Rect` argument. The\n     * indices of iteration are extended in both directions by the integer\n     * `bleed` class property, then are clamped between 0 and the number of\n     * rows/columns.\n     *\n     * Uses a binary search for each of the 4 edges of the bounds, resulting\n     * in a runtime of `O(log(rows) + log(cols))` plus the `O(irows * icols)`\n     * iteration of intersecting cells.\n     */\n    Grid.prototype.mapCellsInRect = function (rect, callback) {\n        var results = [];\n        if (rect == null) {\n            return results;\n        }\n        var _a = this.getRowIndicesInRect(rect), rowIndexStart = _a.rowIndexStart, rowIndexEnd = _a.rowIndexEnd;\n        var _b = this.getColumnIndicesInRect(rect), columnIndexStart = _b.columnIndexStart, columnIndexEnd = _b.columnIndexEnd;\n        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n                results.push(callback(rowIndex, columnIndex));\n            }\n        }\n        return results;\n    };\n    /**\n     * Maps each row that intersects with the given `Rect` argument.\n     *\n     * See Grid.mapCellsInRect for more details.\n     */\n    Grid.prototype.mapRowsInRect = function (rect, callback) {\n        var results = [];\n        if (rect == null) {\n            return results;\n        }\n        var _a = this.getRowIndicesInRect(rect), rowIndexStart = _a.rowIndexStart, rowIndexEnd = _a.rowIndexEnd;\n        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            results.push(callback(rowIndex));\n        }\n        return results;\n    };\n    /**\n     * Maps each column that intersects with the given `Rect` argument.\n     *\n     * See Grid.mapCellsInRect for more details.\n     */\n    Grid.prototype.mapColumnsInRect = function (rect, callback) {\n        var results = [];\n        if (rect == null) {\n            return results;\n        }\n        var _a = this.getColumnIndicesInRect(rect), columnIndexStart = _a.columnIndexStart, columnIndexEnd = _a.columnIndexEnd;\n        for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n            results.push(callback(columnIndex));\n        }\n        return results;\n    };\n    /**\n     * Returns the start and end indices of rows that intersect with the given\n     * `Rect` argument.\n     */\n    Grid.prototype.getRowIndicesInRect = function (rect, includeGhostCells, limit) {\n        if (includeGhostCells === void 0) { includeGhostCells = false; }\n        if (limit === void 0) { limit = Grid.DEFAULT_MAX_ROWS; }\n        if (rect == null) {\n            return { rowIndexEnd: 0, rowIndexStart: 0 };\n        }\n        var searchEnd = includeGhostCells ? Math.max(this.numRows, Grid.DEFAULT_MAX_ROWS) : this.numRows;\n        var _a = this.getIndicesInInterval(rect.top, rect.top + rect.height, searchEnd, !includeGhostCells, this.getCumulativeHeightAt), start = _a.start, end = _a.end;\n        var rowIndexEnd = limit > 0 && end - start > limit ? start + limit : end;\n        return {\n            rowIndexEnd: rowIndexEnd,\n            rowIndexStart: start,\n        };\n    };\n    /**\n     * Returns the start and end indices of columns that intersect with the\n     * given `Rect` argument.\n     */\n    Grid.prototype.getColumnIndicesInRect = function (rect, includeGhostCells, limit) {\n        if (includeGhostCells === void 0) { includeGhostCells = false; }\n        if (limit === void 0) { limit = Grid.DEFAULT_MAX_COLUMNS; }\n        if (rect == null) {\n            return { columnIndexEnd: 0, columnIndexStart: 0 };\n        }\n        var searchEnd = includeGhostCells ? Math.max(this.numCols, Grid.DEFAULT_MAX_COLUMNS) : this.numCols;\n        var _a = this.getIndicesInInterval(rect.left, rect.left + rect.width, searchEnd, !includeGhostCells, this.getCumulativeWidthAt), start = _a.start, end = _a.end;\n        var columnIndexEnd = limit > 0 && end - start > limit ? start + limit : end;\n        return {\n            columnIndexEnd: columnIndexEnd,\n            columnIndexStart: start,\n        };\n    };\n    Grid.prototype.isGhostIndex = function (rowIndex, columnIndex) {\n        return rowIndex >= this.numRows || columnIndex >= this.numCols;\n    };\n    Grid.prototype.isGhostColumn = function (columnIndex) {\n        return columnIndex >= this.numCols;\n    };\n    Grid.prototype.getExtremaClasses = function (rowIndex, columnIndex, rowEnd, columnEnd) {\n        if (rowIndex === rowEnd && columnIndex === columnEnd) {\n            return [Classes.TABLE_LAST_IN_COLUMN, Classes.TABLE_LAST_IN_ROW];\n        }\n        if (rowIndex === rowEnd) {\n            return [Classes.TABLE_LAST_IN_COLUMN];\n        }\n        if (columnIndex === columnEnd) {\n            return [Classes.TABLE_LAST_IN_ROW];\n        }\n        return [];\n    };\n    Grid.prototype.getRegionStyle = function (region) {\n        var cardinality = Regions.getRegionCardinality(region);\n        switch (cardinality) {\n            case RegionCardinality.CELLS: {\n                var _a = region.rows, rowStart = _a[0], rowEnd = _a[1];\n                var _b = region.cols, colStart = _b[0], colEnd = _b[1];\n                // if the region is outside the bounds of the table, don't display it\n                if (this.isGhostIndex(rowStart, colStart) || this.isGhostIndex(rowEnd, colEnd)) {\n                    return { display: \"none\" };\n                }\n                var cellRect0 = this.getCellRect(rowStart, colStart);\n                var cellRect1 = this.getCellRect(rowEnd, colEnd);\n                var offsetLeft = colStart === 0 ? 0 : 1;\n                var offsetTop = rowStart === 0 ? 0 : 1;\n                var rect = cellRect0.union(cellRect1);\n                rect.height += offsetTop;\n                rect.left -= offsetLeft;\n                rect.width += offsetLeft;\n                rect.top -= offsetTop;\n                return __assign(__assign({}, rect.style()), { display: \"block\" });\n            }\n            case RegionCardinality.FULL_COLUMNS: {\n                var _c = region.cols, colStart = _c[0], colEnd = _c[1];\n                // if the region is outside the bounds of the table, don't display it\n                if (this.isGhostIndex(0, colStart) || this.isGhostIndex(0, colEnd)) {\n                    return { display: \"none\" };\n                }\n                var cellRect0 = this.getCellRect(0, colStart);\n                var cellRect1 = this.getCellRect(0, colEnd);\n                var rect = cellRect0.union(cellRect1);\n                var offsetLeft = colStart === 0 ? 0 : 1;\n                return {\n                    bottom: 0,\n                    display: \"block\",\n                    left: rect.left - offsetLeft,\n                    top: 0,\n                    width: rect.width + offsetLeft,\n                };\n            }\n            case RegionCardinality.FULL_ROWS: {\n                var _d = region.rows, rowStart = _d[0], rowEnd = _d[1];\n                // if the region is outside the bounds of the table, don't display it\n                if (this.isGhostIndex(rowStart, 0) || this.isGhostIndex(rowEnd, 0)) {\n                    return { display: \"none\" };\n                }\n                var cellRect0 = this.getCellRect(rowStart, 0);\n                var cellRect1 = this.getCellRect(rowEnd, 0);\n                var rect = cellRect0.union(cellRect1);\n                var offsetTop = rowStart === 0 ? 0 : 1;\n                return {\n                    display: \"block\",\n                    height: rect.height + offsetTop,\n                    left: 0,\n                    right: 0,\n                    top: rect.top - offsetTop,\n                };\n            }\n            case RegionCardinality.FULL_TABLE:\n                return {\n                    bottom: 0,\n                    display: \"block\",\n                    left: 0,\n                    right: 0,\n                    top: 0,\n                };\n            default:\n                return { display: \"none\" };\n        }\n    };\n    Grid.prototype.getIndicesInInterval = function (min, max, count, useEndBleed, lookup) {\n        var start = Utils.binarySearch(min, count - 1, lookup);\n        var end = Utils.binarySearch(max, count - 1, lookup);\n        // correct exact pixel alignment\n        if (start >= 0 && min === lookup(start)) {\n            start += 1;\n        }\n        // apply bounded bleeds\n        start = Math.max(0, start - this.bleed);\n        if (useEndBleed) {\n            end = Math.min(count - 1, end + this.bleed);\n        }\n        else {\n            end = Math.min(count - 1, end);\n        }\n        return { start: start, end: end };\n    };\n    Grid.DEFAULT_BLEED = 3;\n    Grid.DEFAULT_MAX_COLUMNS = 50;\n    Grid.DEFAULT_MAX_ROWS = 200;\n    Grid.DEFAULT_GHOST_HEIGHT = 20;\n    Grid.DEFAULT_GHOST_WIDTH = 150;\n    return Grid;\n}());\nexport { Grid };\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}