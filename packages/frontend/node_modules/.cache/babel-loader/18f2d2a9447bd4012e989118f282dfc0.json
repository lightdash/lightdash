{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport * as React from \"react\";\nimport { Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as FocusedCellUtils from \"../common/internal/focusedCellUtils\";\nimport * as PlatformUtils from \"../common/internal/platformUtils\";\nimport { Utils } from \"../common/utils\";\nimport { Regions } from \"../regions\";\nimport { DragEvents } from \"./dragEvents\";\nimport { Draggable } from \"./draggable\";\n\nvar DragSelectable =\n/** @class */\nfunction (_super) {\n  __extends(DragSelectable, _super);\n\n  function DragSelectable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.didExpandSelectionOnActivate = false;\n\n    _this.handleActivate = function (event) {\n      var _a = _this.props,\n          locateClick = _a.locateClick,\n          selectedRegions = _a.selectedRegions,\n          selectedRegionTransform = _a.selectedRegionTransform;\n\n      if (_this.shouldIgnoreMouseDown(event)) {\n        return false;\n      }\n\n      var region = locateClick(event);\n\n      if (!Regions.isValid(region)) {\n        return false;\n      }\n\n      if (selectedRegionTransform != null) {\n        region = selectedRegionTransform(region, event);\n      }\n\n      var foundIndex = Regions.findMatchingRegion(selectedRegions, region);\n      var matchesExistingSelection = foundIndex !== -1;\n\n      if (matchesExistingSelection && DragEvents.isAdditive(event)) {\n        _this.handleClearSelectionAtIndex(foundIndex); // if we just deselected a selected region, a subsequent drag-move\n        // could reselect it again and *also* clear other selections. that's\n        // quite unintuitive, so ignore subsequent drag-move's.\n\n\n        return false;\n      } // we want to listen to subsequent drag-move's in all following cases,\n      // so this mousedown can be the start of a new selection if desired.\n\n\n      if (matchesExistingSelection) {\n        _this.handleClearAllSelectionsNotAtIndex(foundIndex);\n      } else if (_this.shouldExpandSelection(event)) {\n        _this.handleExpandSelection(region);\n      } else if (_this.shouldAddDisjointSelection(event)) {\n        _this.handleAddDisjointSelection(region);\n      } else {\n        _this.handleReplaceSelection(region);\n      }\n\n      return true;\n    };\n\n    _this.handleDragMove = function (event, coords) {\n      var _a = _this.props,\n          enableMultipleSelection = _a.enableMultipleSelection,\n          focusedCell = _a.focusedCell,\n          locateClick = _a.locateClick,\n          locateDrag = _a.locateDrag,\n          selectedRegions = _a.selectedRegions,\n          selectedRegionTransform = _a.selectedRegionTransform;\n      var region = enableMultipleSelection ? locateDrag(event, coords,\n      /* returnEndOnly? */\n      _this.didExpandSelectionOnActivate) : locateClick(event);\n\n      if (!Regions.isValid(region)) {\n        return;\n      } else if (selectedRegionTransform != null) {\n        region = selectedRegionTransform(region, event, coords);\n      }\n\n      var nextSelectedRegions = _this.didExpandSelectionOnActivate ? _this.expandSelectedRegions(selectedRegions, region, focusedCell) : Regions.update(selectedRegions, region);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n\n      if (!enableMultipleSelection) {\n        // move the focused cell with the selected region\n        var lastIndex = nextSelectedRegions.length - 1;\n        var mostRecentRegion = nextSelectedRegions[lastIndex];\n\n        _this.invokeOnFocusCallbackForRegion(mostRecentRegion, lastIndex);\n      }\n    };\n\n    _this.handleDragEnd = function () {\n      _this.finishInteraction();\n    };\n\n    _this.handleClick = function () {\n      _this.finishInteraction();\n    }; // Boolean checks\n    // ==============\n\n\n    _this.shouldExpandSelection = function (event) {\n      var enableMultipleSelection = _this.props.enableMultipleSelection;\n      return enableMultipleSelection && event.shiftKey;\n    };\n\n    _this.shouldAddDisjointSelection = function (event) {\n      var enableMultipleSelection = _this.props.enableMultipleSelection;\n      return enableMultipleSelection && DragEvents.isAdditive(event);\n    }; // Update logic\n    // ============\n\n\n    _this.handleClearSelectionAtIndex = function (selectedRegionIndex) {\n      var selectedRegions = _this.props.selectedRegions; // remove just the clicked region, leaving other selected regions in place\n\n      var nextSelectedRegions = selectedRegions.slice();\n      nextSelectedRegions.splice(selectedRegionIndex, 1);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // if there are still any selections, move the focused cell to the\n      // most recent selection. otherwise, don't update it.\n\n\n      if (nextSelectedRegions.length > 0) {\n        var lastIndex = nextSelectedRegions.length - 1;\n\n        _this.invokeOnFocusCallbackForRegion(nextSelectedRegions[lastIndex], lastIndex);\n      }\n    };\n\n    _this.handleClearAllSelectionsNotAtIndex = function (selectedRegionIndex) {\n      var selectedRegions = _this.props.selectedRegions;\n      var nextSelectedRegion = selectedRegions[selectedRegionIndex];\n\n      _this.maybeInvokeSelectionCallback([nextSelectedRegion]);\n\n      _this.invokeOnFocusCallbackForRegion(nextSelectedRegion, 0);\n    };\n\n    _this.handleExpandSelection = function (region) {\n      var _a = _this.props,\n          focusedCell = _a.focusedCell,\n          selectedRegions = _a.selectedRegions;\n      _this.didExpandSelectionOnActivate = true; // there should be only one selected region after expanding. do not\n      // update the focused cell.\n\n      var nextSelectedRegions = _this.expandSelectedRegions(selectedRegions, region, focusedCell);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // move the focused cell into the new region if there were no selections before\n\n\n      if (selectedRegions == null || selectedRegions.length === 0) {\n        _this.invokeOnFocusCallbackForRegion(region);\n      }\n    };\n\n    _this.handleAddDisjointSelection = function (region) {\n      var selectedRegions = _this.props.selectedRegions; // add the new region to the existing selections\n\n      var nextSelectedRegions = Regions.add(selectedRegions, region);\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // put the focused cell in the new region\n\n\n      _this.invokeOnFocusCallbackForRegion(region, nextSelectedRegions.length - 1);\n    };\n\n    _this.handleReplaceSelection = function (region) {\n      // clear all selections and retain only the new one\n      var nextSelectedRegions = [region];\n\n      _this.maybeInvokeSelectionCallback(nextSelectedRegions); // move the focused cell into the new selection\n\n\n      _this.invokeOnFocusCallbackForRegion(region);\n    };\n\n    _this.invokeOnFocusCallbackForRegion = function (focusRegion, focusSelectionIndex) {\n      if (focusSelectionIndex === void 0) {\n        focusSelectionIndex = 0;\n      }\n\n      var onFocusedCell = _this.props.onFocusedCell;\n      var focusedCellCoords = Regions.getFocusCellCoordinatesFromRegion(focusRegion);\n      onFocusedCell(FocusedCellUtils.toFullCoordinates(focusedCellCoords, focusSelectionIndex));\n    }; // Other\n    // =====\n\n\n    _this.finishInteraction = function () {\n      var _a, _b;\n\n      (_b = (_a = _this.props).onSelectionEnd) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.selectedRegions);\n      _this.didExpandSelectionOnActivate = false;\n      _this.lastEmittedSelectedRegions = null;\n    };\n\n    return _this;\n  }\n\n  DragSelectable.prototype.render = function () {\n    var draggableProps = this.getDraggableProps();\n    return React.createElement(Draggable, __assign({}, draggableProps, {\n      preventDefault: false\n    }), this.props.children);\n  };\n\n  DragSelectable.prototype.getDraggableProps = function () {\n    return this.props.onSelection == null ? {} : {\n      onActivate: this.handleActivate,\n      onClick: this.handleClick,\n      onDragEnd: this.handleDragEnd,\n      onDragMove: this.handleDragMove\n    };\n  };\n\n  DragSelectable.prototype.shouldIgnoreMouseDown = function (event) {\n    var _a = this.props,\n        disabled = _a.disabled,\n        _b = _a.ignoredSelectors,\n        ignoredSelectors = _b === void 0 ? [] : _b;\n    var element = event.target;\n    var isLeftClick = Utils.isLeftClick(event);\n    var isContextMenuTrigger = isLeftClick && event.ctrlKey && PlatformUtils.isMac();\n    var isDisabled = typeof disabled === \"function\" ? disabled(event) : disabled;\n    return !isLeftClick || isContextMenuTrigger || isDisabled || ignoredSelectors.some(function (selector) {\n      return element.closest(selector) != null;\n    });\n  }; // Callbacks\n  // =========\n\n\n  DragSelectable.prototype.maybeInvokeSelectionCallback = function (nextSelectedRegions) {\n    var onSelection = this.props.onSelection; // invoke only if the selection changed. this is useful only on\n    // mousemove; there's special handling for mousedown interactions that\n    // target an already-selected region.\n\n    if (this.lastEmittedSelectedRegions == null || !CoreUtils.deepCompareKeys(this.lastEmittedSelectedRegions, nextSelectedRegions)) {\n      onSelection(nextSelectedRegions);\n      this.lastEmittedSelectedRegions = nextSelectedRegions;\n    }\n  };\n  /**\n   * Expands the last-selected region to the new region, and replaces the\n   * last-selected region with the expanded region. If a focused cell is provided,\n   * the focused cell will serve as an anchor for the expansion.\n   */\n\n\n  DragSelectable.prototype.expandSelectedRegions = function (regions, region, focusedCell) {\n    if (regions.length === 0) {\n      return [region];\n    } else if (focusedCell != null) {\n      var expandedRegion = FocusedCellUtils.expandFocusedRegion(focusedCell, region);\n      return Regions.update(regions, expandedRegion);\n    } else {\n      var expandedRegion = Regions.expandRegion(regions[regions.length - 1], region);\n      return Regions.update(regions, expandedRegion);\n    }\n  };\n\n  DragSelectable.defaultProps = {\n    disabled: false,\n    enableMultipleSelection: false,\n    selectedRegions: []\n  };\n  return DragSelectable;\n}(React.PureComponent);\n\nexport { DragSelectable };","map":{"version":3,"sources":["../../../src/interactions/selectable.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport * as React from \"react\";\nimport { Utils as CoreUtils } from \"@blueprintjs/core\";\nimport * as FocusedCellUtils from \"../common/internal/focusedCellUtils\";\nimport * as PlatformUtils from \"../common/internal/platformUtils\";\nimport { Utils } from \"../common/utils\";\nimport { Regions } from \"../regions\";\nimport { DragEvents } from \"./dragEvents\";\nimport { Draggable } from \"./draggable\";\nvar DragSelectable = /** @class */ (function (_super) {\n    __extends(DragSelectable, _super);\n    function DragSelectable() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.didExpandSelectionOnActivate = false;\n        _this.handleActivate = function (event) {\n            var _a = _this.props, locateClick = _a.locateClick, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;\n            if (_this.shouldIgnoreMouseDown(event)) {\n                return false;\n            }\n            var region = locateClick(event);\n            if (!Regions.isValid(region)) {\n                return false;\n            }\n            if (selectedRegionTransform != null) {\n                region = selectedRegionTransform(region, event);\n            }\n            var foundIndex = Regions.findMatchingRegion(selectedRegions, region);\n            var matchesExistingSelection = foundIndex !== -1;\n            if (matchesExistingSelection && DragEvents.isAdditive(event)) {\n                _this.handleClearSelectionAtIndex(foundIndex);\n                // if we just deselected a selected region, a subsequent drag-move\n                // could reselect it again and *also* clear other selections. that's\n                // quite unintuitive, so ignore subsequent drag-move's.\n                return false;\n            }\n            // we want to listen to subsequent drag-move's in all following cases,\n            // so this mousedown can be the start of a new selection if desired.\n            if (matchesExistingSelection) {\n                _this.handleClearAllSelectionsNotAtIndex(foundIndex);\n            }\n            else if (_this.shouldExpandSelection(event)) {\n                _this.handleExpandSelection(region);\n            }\n            else if (_this.shouldAddDisjointSelection(event)) {\n                _this.handleAddDisjointSelection(region);\n            }\n            else {\n                _this.handleReplaceSelection(region);\n            }\n            return true;\n        };\n        _this.handleDragMove = function (event, coords) {\n            var _a = _this.props, enableMultipleSelection = _a.enableMultipleSelection, focusedCell = _a.focusedCell, locateClick = _a.locateClick, locateDrag = _a.locateDrag, selectedRegions = _a.selectedRegions, selectedRegionTransform = _a.selectedRegionTransform;\n            var region = enableMultipleSelection\n                ? locateDrag(event, coords, /* returnEndOnly? */ _this.didExpandSelectionOnActivate)\n                : locateClick(event);\n            if (!Regions.isValid(region)) {\n                return;\n            }\n            else if (selectedRegionTransform != null) {\n                region = selectedRegionTransform(region, event, coords);\n            }\n            var nextSelectedRegions = _this.didExpandSelectionOnActivate\n                ? _this.expandSelectedRegions(selectedRegions, region, focusedCell)\n                : Regions.update(selectedRegions, region);\n            _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n            if (!enableMultipleSelection) {\n                // move the focused cell with the selected region\n                var lastIndex = nextSelectedRegions.length - 1;\n                var mostRecentRegion = nextSelectedRegions[lastIndex];\n                _this.invokeOnFocusCallbackForRegion(mostRecentRegion, lastIndex);\n            }\n        };\n        _this.handleDragEnd = function () {\n            _this.finishInteraction();\n        };\n        _this.handleClick = function () {\n            _this.finishInteraction();\n        };\n        // Boolean checks\n        // ==============\n        _this.shouldExpandSelection = function (event) {\n            var enableMultipleSelection = _this.props.enableMultipleSelection;\n            return enableMultipleSelection && event.shiftKey;\n        };\n        _this.shouldAddDisjointSelection = function (event) {\n            var enableMultipleSelection = _this.props.enableMultipleSelection;\n            return enableMultipleSelection && DragEvents.isAdditive(event);\n        };\n        // Update logic\n        // ============\n        _this.handleClearSelectionAtIndex = function (selectedRegionIndex) {\n            var selectedRegions = _this.props.selectedRegions;\n            // remove just the clicked region, leaving other selected regions in place\n            var nextSelectedRegions = selectedRegions.slice();\n            nextSelectedRegions.splice(selectedRegionIndex, 1);\n            _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n            // if there are still any selections, move the focused cell to the\n            // most recent selection. otherwise, don't update it.\n            if (nextSelectedRegions.length > 0) {\n                var lastIndex = nextSelectedRegions.length - 1;\n                _this.invokeOnFocusCallbackForRegion(nextSelectedRegions[lastIndex], lastIndex);\n            }\n        };\n        _this.handleClearAllSelectionsNotAtIndex = function (selectedRegionIndex) {\n            var selectedRegions = _this.props.selectedRegions;\n            var nextSelectedRegion = selectedRegions[selectedRegionIndex];\n            _this.maybeInvokeSelectionCallback([nextSelectedRegion]);\n            _this.invokeOnFocusCallbackForRegion(nextSelectedRegion, 0);\n        };\n        _this.handleExpandSelection = function (region) {\n            var _a = _this.props, focusedCell = _a.focusedCell, selectedRegions = _a.selectedRegions;\n            _this.didExpandSelectionOnActivate = true;\n            // there should be only one selected region after expanding. do not\n            // update the focused cell.\n            var nextSelectedRegions = _this.expandSelectedRegions(selectedRegions, region, focusedCell);\n            _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n            // move the focused cell into the new region if there were no selections before\n            if (selectedRegions == null || selectedRegions.length === 0) {\n                _this.invokeOnFocusCallbackForRegion(region);\n            }\n        };\n        _this.handleAddDisjointSelection = function (region) {\n            var selectedRegions = _this.props.selectedRegions;\n            // add the new region to the existing selections\n            var nextSelectedRegions = Regions.add(selectedRegions, region);\n            _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n            // put the focused cell in the new region\n            _this.invokeOnFocusCallbackForRegion(region, nextSelectedRegions.length - 1);\n        };\n        _this.handleReplaceSelection = function (region) {\n            // clear all selections and retain only the new one\n            var nextSelectedRegions = [region];\n            _this.maybeInvokeSelectionCallback(nextSelectedRegions);\n            // move the focused cell into the new selection\n            _this.invokeOnFocusCallbackForRegion(region);\n        };\n        _this.invokeOnFocusCallbackForRegion = function (focusRegion, focusSelectionIndex) {\n            if (focusSelectionIndex === void 0) { focusSelectionIndex = 0; }\n            var onFocusedCell = _this.props.onFocusedCell;\n            var focusedCellCoords = Regions.getFocusCellCoordinatesFromRegion(focusRegion);\n            onFocusedCell(FocusedCellUtils.toFullCoordinates(focusedCellCoords, focusSelectionIndex));\n        };\n        // Other\n        // =====\n        _this.finishInteraction = function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onSelectionEnd) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.selectedRegions);\n            _this.didExpandSelectionOnActivate = false;\n            _this.lastEmittedSelectedRegions = null;\n        };\n        return _this;\n    }\n    DragSelectable.prototype.render = function () {\n        var draggableProps = this.getDraggableProps();\n        return (React.createElement(Draggable, __assign({}, draggableProps, { preventDefault: false }), this.props.children));\n    };\n    DragSelectable.prototype.getDraggableProps = function () {\n        return this.props.onSelection == null\n            ? {}\n            : {\n                onActivate: this.handleActivate,\n                onClick: this.handleClick,\n                onDragEnd: this.handleDragEnd,\n                onDragMove: this.handleDragMove,\n            };\n    };\n    DragSelectable.prototype.shouldIgnoreMouseDown = function (event) {\n        var _a = this.props, disabled = _a.disabled, _b = _a.ignoredSelectors, ignoredSelectors = _b === void 0 ? [] : _b;\n        var element = event.target;\n        var isLeftClick = Utils.isLeftClick(event);\n        var isContextMenuTrigger = isLeftClick && event.ctrlKey && PlatformUtils.isMac();\n        var isDisabled = typeof disabled === \"function\" ? disabled(event) : disabled;\n        return (!isLeftClick ||\n            isContextMenuTrigger ||\n            isDisabled ||\n            ignoredSelectors.some(function (selector) { return element.closest(selector) != null; }));\n    };\n    // Callbacks\n    // =========\n    DragSelectable.prototype.maybeInvokeSelectionCallback = function (nextSelectedRegions) {\n        var onSelection = this.props.onSelection;\n        // invoke only if the selection changed. this is useful only on\n        // mousemove; there's special handling for mousedown interactions that\n        // target an already-selected region.\n        if (this.lastEmittedSelectedRegions == null ||\n            !CoreUtils.deepCompareKeys(this.lastEmittedSelectedRegions, nextSelectedRegions)) {\n            onSelection(nextSelectedRegions);\n            this.lastEmittedSelectedRegions = nextSelectedRegions;\n        }\n    };\n    /**\n     * Expands the last-selected region to the new region, and replaces the\n     * last-selected region with the expanded region. If a focused cell is provided,\n     * the focused cell will serve as an anchor for the expansion.\n     */\n    DragSelectable.prototype.expandSelectedRegions = function (regions, region, focusedCell) {\n        if (regions.length === 0) {\n            return [region];\n        }\n        else if (focusedCell != null) {\n            var expandedRegion = FocusedCellUtils.expandFocusedRegion(focusedCell, region);\n            return Regions.update(regions, expandedRegion);\n        }\n        else {\n            var expandedRegion = Regions.expandRegion(regions[regions.length - 1], region);\n            return Regions.update(regions, expandedRegion);\n        }\n    };\n    DragSelectable.defaultProps = {\n        disabled: false,\n        enableMultipleSelection: false,\n        selectedRegions: [],\n    };\n    return DragSelectable;\n}(React.PureComponent));\nexport { DragSelectable };\n//# sourceMappingURL=selectable.js.map"]},"metadata":{},"sourceType":"module"}