{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractComponent2, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport { emptyCellRenderer } from \"./cell/cell\";\nimport { Batcher } from \"./common/batcher\";\nimport * as Classes from \"./common/classes\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nvar SHALLOW_COMPARE_DENYLIST = [\"viewportRect\"];\n/**\n * We don't want to reset the batcher when this set of keys changes. Any other\n * changes should reset the batcher's internal cache.\n */\n\nvar BATCHER_RESET_PROP_KEYS_DENYLIST = [\"columnIndexEnd\", \"columnIndexStart\", \"rowIndexEnd\", \"rowIndexStart\"];\n\nvar TableBodyCells =\n/** @class */\nfunction (_super) {\n  __extends(TableBodyCells, _super);\n\n  function TableBodyCells() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.batcher = new Batcher(); // Cell renderers\n    // ==============\n\n    _this.renderNewCell = function (rowIndex, columnIndex) {\n      var _a = _this.props,\n          columnIndexEnd = _a.columnIndexEnd,\n          grid = _a.grid,\n          rowIndexEnd = _a.rowIndexEnd;\n      var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);\n      var isGhost = grid.isGhostIndex(rowIndex, columnIndex);\n      return _this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost);\n    };\n\n    _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {\n      var _a;\n\n      var _b = _this.props,\n          cellRenderer = _b.cellRenderer,\n          focusedCell = _b.focusedCell,\n          loading = _b.loading,\n          grid = _b.grid;\n      var baseCell = isGhost ? emptyCellRenderer() : cellRenderer(rowIndex, columnIndex); // cellRenderer still may return null\n\n      baseCell = baseCell == null ? emptyCellRenderer() : baseCell;\n      var className = classNames(cellClassNames(rowIndex, columnIndex), extremaClasses, (_a = {}, _a[Classes.TABLE_CELL_GHOST] = isGhost, _a[Classes.TABLE_CELL_LEDGER_ODD] = rowIndex % 2 === 1, _a[Classes.TABLE_CELL_LEDGER_EVEN] = rowIndex % 2 === 0, _a), baseCell.props.className);\n      var key = TableBodyCells.cellReactKey(rowIndex, columnIndex);\n      var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);\n      var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;\n\n      var style = __assign(__assign({}, baseCell.props.style), Rect.style(rect));\n\n      var isFocused = focusedCell != null && focusedCell.row === rowIndex && focusedCell.col === columnIndex;\n      return React.cloneElement(baseCell, {\n        className: className,\n        isFocused: isFocused,\n        key: key,\n        loading: cellLoading,\n        style: style\n      });\n    }; // Other\n    // =====\n\n\n    _this.didViewportRectChange = function (nextViewportRect, currViewportRect) {\n      if (nextViewportRect == null && currViewportRect == null) {\n        return false;\n      } else if (nextViewportRect == null || currViewportRect == null) {\n        return true;\n      } else {\n        return !nextViewportRect.equals(currViewportRect);\n      }\n    };\n\n    return _this;\n  }\n\n  TableBodyCells.cellReactKey = function (rowIndex, columnIndex) {\n    return \"cell-\" + rowIndex + \"-\" + columnIndex;\n  };\n\n  TableBodyCells.prototype.componentDidMount = function () {\n    this.maybeInvokeOnCompleteRender();\n  };\n\n  TableBodyCells.prototype.shouldComponentUpdate = function (nextProps) {\n    return !CoreUtils.shallowCompareKeys(nextProps, this.props, {\n      exclude: SHALLOW_COMPARE_DENYLIST\n    }) || // \"viewportRect\" is not a plain object, so we can't just deep\n    // compare; we need custom logic.\n    this.didViewportRectChange(nextProps.viewportRect, this.props.viewportRect);\n  };\n\n  TableBodyCells.prototype.componentDidUpdate = function (prevProps) {\n    var shouldResetBatcher = !CoreUtils.shallowCompareKeys(prevProps, this.props, {\n      exclude: BATCHER_RESET_PROP_KEYS_DENYLIST\n    });\n\n    if (shouldResetBatcher) {\n      this.batcher.reset();\n    }\n\n    this.maybeInvokeOnCompleteRender();\n  };\n\n  TableBodyCells.prototype.componentWillUnmount = function () {\n    this.batcher.cancelOutstandingCallback();\n  };\n\n  TableBodyCells.prototype.render = function () {\n    var renderMode = this.props.renderMode;\n    var cells = renderMode === RenderMode.BATCH ? this.renderBatchedCells() : this.renderAllCells();\n    return React.createElement(\"div\", {\n      className: Classes.TABLE_BODY_CELLS\n    }, cells);\n  }; // Render modes\n  // ============\n\n\n  TableBodyCells.prototype.renderBatchedCells = function () {\n    var _this = this;\n\n    var _a = this.props,\n        columnIndexEnd = _a.columnIndexEnd,\n        columnIndexStart = _a.columnIndexStart,\n        rowIndexEnd = _a.rowIndexEnd,\n        rowIndexStart = _a.rowIndexStart; // render cells in batches\n\n    this.batcher.startNewBatch();\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n        this.batcher.addArgsToBatch(rowIndex, columnIndex);\n      }\n    }\n\n    this.batcher.removeOldAddNew(this.renderNewCell);\n\n    if (!this.batcher.isDone()) {\n      this.batcher.idleCallback(function () {\n        return _this.forceUpdate();\n      });\n    }\n\n    return this.batcher.getList();\n  };\n\n  TableBodyCells.prototype.renderAllCells = function () {\n    var _a = this.props,\n        columnIndexEnd = _a.columnIndexEnd,\n        columnIndexStart = _a.columnIndexStart,\n        rowIndexEnd = _a.rowIndexEnd,\n        rowIndexStart = _a.rowIndexStart;\n    var cells = [];\n    var cellsArgs = [];\n\n    for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n      for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n        cells.push(this.renderNewCell(rowIndex, columnIndex));\n        cellsArgs.push([rowIndex, columnIndex]);\n      }\n    } // pretend we did an entire rendering pass using the batcher. that way,\n    // if we switch from `RenderMode.NONE` to `RenderMode.BATCH`, we don't\n    // have to re-paint every cell still in view.\n\n\n    this.batcher.setList(cellsArgs, cells);\n    return cells;\n  }; // Callbacks\n  // =========\n\n\n  TableBodyCells.prototype.maybeInvokeOnCompleteRender = function () {\n    var _a = this.props,\n        onCompleteRender = _a.onCompleteRender,\n        renderMode = _a.renderMode;\n\n    if (renderMode === RenderMode.NONE || renderMode === RenderMode.BATCH && this.batcher.isDone()) {\n      onCompleteRender === null || onCompleteRender === void 0 ? void 0 : onCompleteRender();\n    }\n  };\n\n  TableBodyCells.defaultProps = {\n    renderMode: RenderMode.BATCH\n  };\n  return TableBodyCells;\n}(AbstractComponent2);\n\nexport { TableBodyCells };\n/**\n * Returns the array of class names that must be applied to each table\n * cell so that we can locate any cell based on its coordinate.\n */\n\nexport function cellClassNames(rowIndex, columnIndex) {\n  return [Classes.rowCellIndexClass(rowIndex), Classes.columnCellIndexClass(columnIndex)];\n}","map":{"version":3,"sources":["../../src/tableBodyCells.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractComponent2, Utils as CoreUtils } from \"@blueprintjs/core\";\nimport { emptyCellRenderer } from \"./cell/cell\";\nimport { Batcher } from \"./common/batcher\";\nimport * as Classes from \"./common/classes\";\nimport { Rect } from \"./common/rect\";\nimport { RenderMode } from \"./common/renderMode\";\nvar SHALLOW_COMPARE_DENYLIST = [\"viewportRect\"];\n/**\n * We don't want to reset the batcher when this set of keys changes. Any other\n * changes should reset the batcher's internal cache.\n */\nvar BATCHER_RESET_PROP_KEYS_DENYLIST = [\n    \"columnIndexEnd\",\n    \"columnIndexStart\",\n    \"rowIndexEnd\",\n    \"rowIndexStart\",\n];\nvar TableBodyCells = /** @class */ (function (_super) {\n    __extends(TableBodyCells, _super);\n    function TableBodyCells() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.batcher = new Batcher();\n        // Cell renderers\n        // ==============\n        _this.renderNewCell = function (rowIndex, columnIndex) {\n            var _a = _this.props, columnIndexEnd = _a.columnIndexEnd, grid = _a.grid, rowIndexEnd = _a.rowIndexEnd;\n            var extremaClasses = grid.getExtremaClasses(rowIndex, columnIndex, rowIndexEnd, columnIndexEnd);\n            var isGhost = grid.isGhostIndex(rowIndex, columnIndex);\n            return _this.renderCell(rowIndex, columnIndex, extremaClasses, isGhost);\n        };\n        _this.renderCell = function (rowIndex, columnIndex, extremaClasses, isGhost) {\n            var _a;\n            var _b = _this.props, cellRenderer = _b.cellRenderer, focusedCell = _b.focusedCell, loading = _b.loading, grid = _b.grid;\n            var baseCell = isGhost ? emptyCellRenderer() : cellRenderer(rowIndex, columnIndex);\n            // cellRenderer still may return null\n            baseCell = baseCell == null ? emptyCellRenderer() : baseCell;\n            var className = classNames(cellClassNames(rowIndex, columnIndex), extremaClasses, (_a = {},\n                _a[Classes.TABLE_CELL_GHOST] = isGhost,\n                _a[Classes.TABLE_CELL_LEDGER_ODD] = rowIndex % 2 === 1,\n                _a[Classes.TABLE_CELL_LEDGER_EVEN] = rowIndex % 2 === 0,\n                _a), baseCell.props.className);\n            var key = TableBodyCells.cellReactKey(rowIndex, columnIndex);\n            var rect = isGhost ? grid.getGhostCellRect(rowIndex, columnIndex) : grid.getCellRect(rowIndex, columnIndex);\n            var cellLoading = baseCell.props.loading != null ? baseCell.props.loading : loading;\n            var style = __assign(__assign({}, baseCell.props.style), Rect.style(rect));\n            var isFocused = focusedCell != null && focusedCell.row === rowIndex && focusedCell.col === columnIndex;\n            return React.cloneElement(baseCell, {\n                className: className,\n                isFocused: isFocused,\n                key: key,\n                loading: cellLoading,\n                style: style,\n            });\n        };\n        // Other\n        // =====\n        _this.didViewportRectChange = function (nextViewportRect, currViewportRect) {\n            if (nextViewportRect == null && currViewportRect == null) {\n                return false;\n            }\n            else if (nextViewportRect == null || currViewportRect == null) {\n                return true;\n            }\n            else {\n                return !nextViewportRect.equals(currViewportRect);\n            }\n        };\n        return _this;\n    }\n    TableBodyCells.cellReactKey = function (rowIndex, columnIndex) {\n        return \"cell-\" + rowIndex + \"-\" + columnIndex;\n    };\n    TableBodyCells.prototype.componentDidMount = function () {\n        this.maybeInvokeOnCompleteRender();\n    };\n    TableBodyCells.prototype.shouldComponentUpdate = function (nextProps) {\n        return (!CoreUtils.shallowCompareKeys(nextProps, this.props, {\n            exclude: SHALLOW_COMPARE_DENYLIST,\n        }) ||\n            // \"viewportRect\" is not a plain object, so we can't just deep\n            // compare; we need custom logic.\n            this.didViewportRectChange(nextProps.viewportRect, this.props.viewportRect));\n    };\n    TableBodyCells.prototype.componentDidUpdate = function (prevProps) {\n        var shouldResetBatcher = !CoreUtils.shallowCompareKeys(prevProps, this.props, {\n            exclude: BATCHER_RESET_PROP_KEYS_DENYLIST,\n        });\n        if (shouldResetBatcher) {\n            this.batcher.reset();\n        }\n        this.maybeInvokeOnCompleteRender();\n    };\n    TableBodyCells.prototype.componentWillUnmount = function () {\n        this.batcher.cancelOutstandingCallback();\n    };\n    TableBodyCells.prototype.render = function () {\n        var renderMode = this.props.renderMode;\n        var cells = renderMode === RenderMode.BATCH ? this.renderBatchedCells() : this.renderAllCells();\n        return React.createElement(\"div\", { className: Classes.TABLE_BODY_CELLS }, cells);\n    };\n    // Render modes\n    // ============\n    TableBodyCells.prototype.renderBatchedCells = function () {\n        var _this = this;\n        var _a = this.props, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart;\n        // render cells in batches\n        this.batcher.startNewBatch();\n        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n                this.batcher.addArgsToBatch(rowIndex, columnIndex);\n            }\n        }\n        this.batcher.removeOldAddNew(this.renderNewCell);\n        if (!this.batcher.isDone()) {\n            this.batcher.idleCallback(function () { return _this.forceUpdate(); });\n        }\n        return this.batcher.getList();\n    };\n    TableBodyCells.prototype.renderAllCells = function () {\n        var _a = this.props, columnIndexEnd = _a.columnIndexEnd, columnIndexStart = _a.columnIndexStart, rowIndexEnd = _a.rowIndexEnd, rowIndexStart = _a.rowIndexStart;\n        var cells = [];\n        var cellsArgs = [];\n        for (var rowIndex = rowIndexStart; rowIndex <= rowIndexEnd; rowIndex++) {\n            for (var columnIndex = columnIndexStart; columnIndex <= columnIndexEnd; columnIndex++) {\n                cells.push(this.renderNewCell(rowIndex, columnIndex));\n                cellsArgs.push([rowIndex, columnIndex]);\n            }\n        }\n        // pretend we did an entire rendering pass using the batcher. that way,\n        // if we switch from `RenderMode.NONE` to `RenderMode.BATCH`, we don't\n        // have to re-paint every cell still in view.\n        this.batcher.setList(cellsArgs, cells);\n        return cells;\n    };\n    // Callbacks\n    // =========\n    TableBodyCells.prototype.maybeInvokeOnCompleteRender = function () {\n        var _a = this.props, onCompleteRender = _a.onCompleteRender, renderMode = _a.renderMode;\n        if (renderMode === RenderMode.NONE || (renderMode === RenderMode.BATCH && this.batcher.isDone())) {\n            onCompleteRender === null || onCompleteRender === void 0 ? void 0 : onCompleteRender();\n        }\n    };\n    TableBodyCells.defaultProps = {\n        renderMode: RenderMode.BATCH,\n    };\n    return TableBodyCells;\n}(AbstractComponent2));\nexport { TableBodyCells };\n/**\n * Returns the array of class names that must be applied to each table\n * cell so that we can locate any cell based on its coordinate.\n */\nexport function cellClassNames(rowIndex, columnIndex) {\n    return [Classes.rowCellIndexClass(rowIndex), Classes.columnCellIndexClass(columnIndex)];\n}\n//# sourceMappingURL=tableBodyCells.js.map"]},"metadata":{},"sourceType":"module"}