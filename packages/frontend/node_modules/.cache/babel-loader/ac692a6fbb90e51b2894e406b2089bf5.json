{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as Classes from \"./common/classes\";\nimport { Rect } from \"./common/rect\";\nimport { Utils } from \"./common/utils\";\n\nvar Locator =\n/** @class */\nfunction () {\n  function Locator(\n  /* The root table element within which a click is deemed valid and relevant. */\n  tableElement,\n  /* The scrollable element that wraps the cell container. */\n  scrollContainerElement,\n  /* The element containing all body cells in the grid (excluding headers). */\n  cellContainerElement) {\n    var _this = this;\n\n    this.tableElement = tableElement;\n    this.scrollContainerElement = scrollContainerElement;\n    this.cellContainerElement = cellContainerElement;\n\n    this.convertCellIndexToClientX = function (index) {\n      return _this.grid.getCumulativeWidthAt(index);\n    };\n\n    this.convertCellMidpointToClientX = function (index) {\n      var cellLeft = _this.grid.getCumulativeWidthBefore(index);\n\n      var cellRight = _this.grid.getCumulativeWidthAt(index);\n\n      return (cellLeft + cellRight) / 2;\n    };\n\n    this.convertCellIndexToClientY = function (index) {\n      return _this.grid.getCumulativeHeightAt(index);\n    };\n\n    this.convertCellMidpointToClientY = function (index) {\n      var cellTop = _this.grid.getCumulativeHeightBefore(index);\n\n      var cellBottom = _this.grid.getCumulativeHeightAt(index);\n\n      return (cellTop + cellBottom) / 2;\n    };\n\n    this.toGridX = function (clientX) {\n      var gridOffsetFromPageLeft = _this.cellContainerElement.getBoundingClientRect().left;\n\n      var scrollOffsetFromGridLeft = _this.scrollContainerElement.scrollLeft;\n      var cursorOffsetFromGridLeft = clientX - (gridOffsetFromPageLeft + scrollOffsetFromGridLeft);\n\n      var isCursorWithinFrozenColumns = _this.numFrozenColumns != null && _this.numFrozenColumns > 0 && cursorOffsetFromGridLeft <= _this.grid.getCumulativeWidthBefore(_this.numFrozenColumns); // the frozen-column region doesn't scroll, so ignore the scroll distance in that case\n\n\n      return isCursorWithinFrozenColumns ? cursorOffsetFromGridLeft : cursorOffsetFromGridLeft + scrollOffsetFromGridLeft;\n    };\n\n    this.toGridY = function (clientY) {\n      var gridOffsetFromPageTop = _this.cellContainerElement.getBoundingClientRect().top;\n\n      var scrollOffsetFromGridTop = _this.scrollContainerElement.scrollTop;\n      var cursorOffsetFromGridTop = clientY - (gridOffsetFromPageTop + scrollOffsetFromGridTop);\n\n      var isCursorWithinFrozenRows = _this.numFrozenRows != null && _this.numFrozenRows > 0 && cursorOffsetFromGridTop <= _this.grid.getCumulativeHeightBefore(_this.numFrozenRows);\n\n      return isCursorWithinFrozenRows ? cursorOffsetFromGridTop : cursorOffsetFromGridTop + scrollOffsetFromGridTop;\n    };\n\n    this.numFrozenRows = 0;\n    this.numFrozenColumns = 0;\n  } // Setters\n  // =======\n\n\n  Locator.prototype.setGrid = function (grid) {\n    this.grid = grid;\n    return this;\n  };\n\n  Locator.prototype.setNumFrozenRows = function (numFrozenRows) {\n    this.numFrozenRows = numFrozenRows;\n    return this;\n  };\n\n  Locator.prototype.setNumFrozenColumns = function (numFrozenColumns) {\n    this.numFrozenColumns = numFrozenColumns;\n    return this;\n  }; // Getters\n  // =======\n\n\n  Locator.prototype.getViewportRect = function () {\n    return new Rect(this.scrollContainerElement.scrollLeft, this.scrollContainerElement.scrollTop, this.scrollContainerElement.clientWidth, this.scrollContainerElement.clientHeight);\n  };\n\n  Locator.prototype.getWidestVisibleCellInColumn = function (columnIndex) {\n    var columnCellSelector = this.getColumnCellSelector(columnIndex);\n    var columnHeaderAndBodyCells = this.tableElement.querySelectorAll(columnCellSelector);\n    var maxWidth = 0;\n\n    for (var i = 0; i < columnHeaderAndBodyCells.length; i++) {\n      var contentWidth = Utils.measureElementTextContent(columnHeaderAndBodyCells.item(i)).width;\n      var cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;\n\n      if (cellWidth > maxWidth) {\n        maxWidth = cellWidth;\n      }\n    }\n\n    return maxWidth;\n  };\n\n  Locator.prototype.getTallestVisibleCellInColumn = function (columnIndex) {\n    // consider only body cells, hence the extra Classes.TABLE_CELL specificity\n    var columnCellSelector = this.getColumnCellSelector(columnIndex);\n    var columnBodyCells = this.tableElement.querySelectorAll(columnCellSelector + \".\" + Classes.TABLE_CELL);\n    var maxHeight = 0;\n\n    for (var i = 0; i < columnBodyCells.length; i++) {\n      var cell = columnBodyCells.item(i);\n      var cellValue = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_VALUE);\n      var cellTruncatedFormatText = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_FORMAT_TEXT);\n      var cellTruncatedText = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_TEXT);\n      var height = 0;\n\n      if (cellValue != null) {\n        height = cellValue.scrollHeight;\n      } else if (cellTruncatedFormatText != null) {\n        height = cellTruncatedFormatText.scrollHeight;\n      } else if (cellTruncatedText != null) {\n        height = cellTruncatedText.scrollHeight;\n      } else {\n        // it's not anything we recognize, just use the current height of the cell\n        height = cell.scrollHeight;\n      }\n\n      if (height > maxHeight) {\n        maxHeight = height;\n      }\n    }\n\n    return maxHeight;\n  }; // Converters\n  // ==========\n\n\n  Locator.prototype.convertPointToColumn = function (clientX, useMidpoint) {\n    var tableRect = this.getTableRect();\n\n    if (!tableRect.containsX(clientX)) {\n      return -1;\n    }\n\n    var gridX = this.toGridX(clientX);\n    var limit = useMidpoint ? this.grid.numCols : this.grid.numCols - 1;\n    var lookupFn = useMidpoint ? this.convertCellMidpointToClientX : this.convertCellIndexToClientX;\n    return Utils.binarySearch(gridX, limit, lookupFn);\n  };\n\n  Locator.prototype.convertPointToRow = function (clientY, useMidpoint) {\n    var tableRect = this.getTableRect();\n\n    if (!tableRect.containsY(clientY)) {\n      return -1;\n    }\n\n    var gridY = this.toGridY(clientY);\n    var limit = useMidpoint ? this.grid.numRows : this.grid.numRows - 1;\n    var lookupFn = useMidpoint ? this.convertCellMidpointToClientY : this.convertCellIndexToClientY;\n    return Utils.binarySearch(gridY, limit, lookupFn);\n  };\n\n  Locator.prototype.convertPointToCell = function (clientX, clientY) {\n    var gridX = this.toGridX(clientX);\n    var gridY = this.toGridY(clientY);\n    var col = Utils.binarySearch(gridX, this.grid.numCols - 1, this.convertCellIndexToClientX);\n    var row = Utils.binarySearch(gridY, this.grid.numRows - 1, this.convertCellIndexToClientY);\n    return {\n      col: col,\n      row: row\n    };\n  }; // Private helpers\n  // ===============\n\n\n  Locator.prototype.getColumnCellSelector = function (columnIndex) {\n    // measure frozen columns in the LEFT quadrant; otherwise, they might\n    // have been scrolled out of view, leading to wonky measurements (#1561)\n    var isFrozenColumnIndex = columnIndex < this.numFrozenColumns;\n    var quadrantClass = isFrozenColumnIndex ? Classes.TABLE_QUADRANT_LEFT : Classes.TABLE_QUADRANT_MAIN;\n    var cellClass = Classes.columnCellIndexClass(columnIndex);\n    return \".\" + quadrantClass + \" .\" + cellClass;\n  };\n\n  Locator.prototype.getTableRect = function () {\n    return Rect.wrap(this.tableElement.getBoundingClientRect());\n  };\n\n  Locator.CELL_HORIZONTAL_PADDING = 10;\n  return Locator;\n}();\n\nexport { Locator };","map":{"version":3,"sources":["../../src/locator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as Classes from \"./common/classes\";\nimport { Rect } from \"./common/rect\";\nimport { Utils } from \"./common/utils\";\nvar Locator = /** @class */ (function () {\n    function Locator(\n    /* The root table element within which a click is deemed valid and relevant. */\n    tableElement, \n    /* The scrollable element that wraps the cell container. */\n    scrollContainerElement, \n    /* The element containing all body cells in the grid (excluding headers). */\n    cellContainerElement) {\n        var _this = this;\n        this.tableElement = tableElement;\n        this.scrollContainerElement = scrollContainerElement;\n        this.cellContainerElement = cellContainerElement;\n        this.convertCellIndexToClientX = function (index) {\n            return _this.grid.getCumulativeWidthAt(index);\n        };\n        this.convertCellMidpointToClientX = function (index) {\n            var cellLeft = _this.grid.getCumulativeWidthBefore(index);\n            var cellRight = _this.grid.getCumulativeWidthAt(index);\n            return (cellLeft + cellRight) / 2;\n        };\n        this.convertCellIndexToClientY = function (index) {\n            return _this.grid.getCumulativeHeightAt(index);\n        };\n        this.convertCellMidpointToClientY = function (index) {\n            var cellTop = _this.grid.getCumulativeHeightBefore(index);\n            var cellBottom = _this.grid.getCumulativeHeightAt(index);\n            return (cellTop + cellBottom) / 2;\n        };\n        this.toGridX = function (clientX) {\n            var gridOffsetFromPageLeft = _this.cellContainerElement.getBoundingClientRect().left;\n            var scrollOffsetFromGridLeft = _this.scrollContainerElement.scrollLeft;\n            var cursorOffsetFromGridLeft = clientX - (gridOffsetFromPageLeft + scrollOffsetFromGridLeft);\n            var isCursorWithinFrozenColumns = _this.numFrozenColumns != null &&\n                _this.numFrozenColumns > 0 &&\n                cursorOffsetFromGridLeft <= _this.grid.getCumulativeWidthBefore(_this.numFrozenColumns);\n            // the frozen-column region doesn't scroll, so ignore the scroll distance in that case\n            return isCursorWithinFrozenColumns\n                ? cursorOffsetFromGridLeft\n                : cursorOffsetFromGridLeft + scrollOffsetFromGridLeft;\n        };\n        this.toGridY = function (clientY) {\n            var gridOffsetFromPageTop = _this.cellContainerElement.getBoundingClientRect().top;\n            var scrollOffsetFromGridTop = _this.scrollContainerElement.scrollTop;\n            var cursorOffsetFromGridTop = clientY - (gridOffsetFromPageTop + scrollOffsetFromGridTop);\n            var isCursorWithinFrozenRows = _this.numFrozenRows != null &&\n                _this.numFrozenRows > 0 &&\n                cursorOffsetFromGridTop <= _this.grid.getCumulativeHeightBefore(_this.numFrozenRows);\n            return isCursorWithinFrozenRows ? cursorOffsetFromGridTop : cursorOffsetFromGridTop + scrollOffsetFromGridTop;\n        };\n        this.numFrozenRows = 0;\n        this.numFrozenColumns = 0;\n    }\n    // Setters\n    // =======\n    Locator.prototype.setGrid = function (grid) {\n        this.grid = grid;\n        return this;\n    };\n    Locator.prototype.setNumFrozenRows = function (numFrozenRows) {\n        this.numFrozenRows = numFrozenRows;\n        return this;\n    };\n    Locator.prototype.setNumFrozenColumns = function (numFrozenColumns) {\n        this.numFrozenColumns = numFrozenColumns;\n        return this;\n    };\n    // Getters\n    // =======\n    Locator.prototype.getViewportRect = function () {\n        return new Rect(this.scrollContainerElement.scrollLeft, this.scrollContainerElement.scrollTop, this.scrollContainerElement.clientWidth, this.scrollContainerElement.clientHeight);\n    };\n    Locator.prototype.getWidestVisibleCellInColumn = function (columnIndex) {\n        var columnCellSelector = this.getColumnCellSelector(columnIndex);\n        var columnHeaderAndBodyCells = this.tableElement.querySelectorAll(columnCellSelector);\n        var maxWidth = 0;\n        for (var i = 0; i < columnHeaderAndBodyCells.length; i++) {\n            var contentWidth = Utils.measureElementTextContent(columnHeaderAndBodyCells.item(i)).width;\n            var cellWidth = Math.ceil(contentWidth) + Locator.CELL_HORIZONTAL_PADDING * 2;\n            if (cellWidth > maxWidth) {\n                maxWidth = cellWidth;\n            }\n        }\n        return maxWidth;\n    };\n    Locator.prototype.getTallestVisibleCellInColumn = function (columnIndex) {\n        // consider only body cells, hence the extra Classes.TABLE_CELL specificity\n        var columnCellSelector = this.getColumnCellSelector(columnIndex);\n        var columnBodyCells = this.tableElement.querySelectorAll(columnCellSelector + \".\" + Classes.TABLE_CELL);\n        var maxHeight = 0;\n        for (var i = 0; i < columnBodyCells.length; i++) {\n            var cell = columnBodyCells.item(i);\n            var cellValue = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_VALUE);\n            var cellTruncatedFormatText = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_FORMAT_TEXT);\n            var cellTruncatedText = cell.querySelector(\".\" + Classes.TABLE_TRUNCATED_TEXT);\n            var height = 0;\n            if (cellValue != null) {\n                height = cellValue.scrollHeight;\n            }\n            else if (cellTruncatedFormatText != null) {\n                height = cellTruncatedFormatText.scrollHeight;\n            }\n            else if (cellTruncatedText != null) {\n                height = cellTruncatedText.scrollHeight;\n            }\n            else {\n                // it's not anything we recognize, just use the current height of the cell\n                height = cell.scrollHeight;\n            }\n            if (height > maxHeight) {\n                maxHeight = height;\n            }\n        }\n        return maxHeight;\n    };\n    // Converters\n    // ==========\n    Locator.prototype.convertPointToColumn = function (clientX, useMidpoint) {\n        var tableRect = this.getTableRect();\n        if (!tableRect.containsX(clientX)) {\n            return -1;\n        }\n        var gridX = this.toGridX(clientX);\n        var limit = useMidpoint ? this.grid.numCols : this.grid.numCols - 1;\n        var lookupFn = useMidpoint ? this.convertCellMidpointToClientX : this.convertCellIndexToClientX;\n        return Utils.binarySearch(gridX, limit, lookupFn);\n    };\n    Locator.prototype.convertPointToRow = function (clientY, useMidpoint) {\n        var tableRect = this.getTableRect();\n        if (!tableRect.containsY(clientY)) {\n            return -1;\n        }\n        var gridY = this.toGridY(clientY);\n        var limit = useMidpoint ? this.grid.numRows : this.grid.numRows - 1;\n        var lookupFn = useMidpoint ? this.convertCellMidpointToClientY : this.convertCellIndexToClientY;\n        return Utils.binarySearch(gridY, limit, lookupFn);\n    };\n    Locator.prototype.convertPointToCell = function (clientX, clientY) {\n        var gridX = this.toGridX(clientX);\n        var gridY = this.toGridY(clientY);\n        var col = Utils.binarySearch(gridX, this.grid.numCols - 1, this.convertCellIndexToClientX);\n        var row = Utils.binarySearch(gridY, this.grid.numRows - 1, this.convertCellIndexToClientY);\n        return { col: col, row: row };\n    };\n    // Private helpers\n    // ===============\n    Locator.prototype.getColumnCellSelector = function (columnIndex) {\n        // measure frozen columns in the LEFT quadrant; otherwise, they might\n        // have been scrolled out of view, leading to wonky measurements (#1561)\n        var isFrozenColumnIndex = columnIndex < this.numFrozenColumns;\n        var quadrantClass = isFrozenColumnIndex ? Classes.TABLE_QUADRANT_LEFT : Classes.TABLE_QUADRANT_MAIN;\n        var cellClass = Classes.columnCellIndexClass(columnIndex);\n        return \".\" + quadrantClass + \" .\" + cellClass;\n    };\n    Locator.prototype.getTableRect = function () {\n        return Rect.wrap(this.tableElement.getBoundingClientRect());\n    };\n    Locator.CELL_HORIZONTAL_PADDING = 10;\n    return Locator;\n}());\nexport { Locator };\n//# sourceMappingURL=locator.js.map"]},"metadata":{},"sourceType":"module"}