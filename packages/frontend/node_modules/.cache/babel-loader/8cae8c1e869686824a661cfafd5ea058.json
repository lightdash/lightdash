{"ast":null,"code":"/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes as CoreClasses, combineRefs, DISPLAYNAME_PREFIX, isRefCallback, Overlay, ResizeSensor, Utils } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport * as Errors from \"./errors\";\nimport { POPOVER_ARROW_SVG_SIZE, Popover2Arrow } from \"./popover2Arrow\"; // eslint-disable-next-line import/no-cycle\n\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\nexport var Popover2InteractionKind = {\n  CLICK: \"click\",\n  CLICK_TARGET_ONLY: \"click-target\",\n  HOVER: \"hover\",\n  HOVER_TARGET_ONLY: \"hover-target\"\n};\n/**\n * @template T target component props inteface\n */\n\nvar Popover2 =\n/** @class */\nfunction (_super) {\n  __extends(Popover2, _super);\n\n  function Popover2() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.popoverRef = Utils.createReactRef();\n    _this.state = {\n      hasDarkParent: false,\n      isOpen: _this.getIsOpen(_this.props)\n    };\n    /**\n     * DOM element that contains the popover.\n     * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n     * so this reference can be very useful for testing.\n     */\n\n    _this.popoverElement = null;\n    /** DOM element that contains the target. */\n\n    _this.targetElement = null;\n    _this.refHandlers = {\n      popover: function (ref) {\n        var _a, _b;\n\n        _this.popoverElement = ref;\n        (_b = (_a = _this.props).popoverRef) === null || _b === void 0 ? void 0 : _b.call(_a, ref);\n      },\n      target: function (ref) {\n        return _this.targetElement = ref;\n      }\n    }; // a flag that lets us detect mouse movement between the target and popover,\n    // now that mouseleave is triggered when you cross the gap between the two.\n\n    _this.isMouseInTargetOrPopover = false; // a flag that indicates whether the target previously lost focus to another\n    // element on the same page.\n\n    _this.lostFocusOnSamePage = true;\n\n    _this.isControlled = function () {\n      return _this.props.isOpen !== undefined;\n    }; // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n\n\n    _this.isArrowEnabled = function () {\n      var _a, _b;\n\n      return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false;\n    };\n\n    _this.isHoverInteractionKind = function () {\n      return _this.props.interactionKind === Popover2InteractionKind.HOVER || _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY;\n    };\n    /**\n     * Instance method to instruct the `Popover` to recompute its position.\n     *\n     * This method should only be used if you are updating the target in a way\n     * that does not cause it to re-render, such as changing its _position_\n     * without changing its _size_ (since `Popover` already repositions when it\n     * detects a resize).\n     */\n\n\n    _this.reposition = function () {\n      var _a;\n\n      return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this);\n    };\n\n    _this.renderTarget = function (_a) {\n      var _b, _c;\n\n      var ref = _a.ref;\n      var _d = _this.props,\n          children = _d.children,\n          className = _d.className,\n          fill = _d.fill,\n          openOnTargetFocus = _d.openOnTargetFocus,\n          renderTarget = _d.renderTarget;\n      var isOpen = _this.state.isOpen;\n\n      var isControlled = _this.isControlled();\n\n      var isHoverInteractionKind = _this.isHoverInteractionKind();\n\n      var targetTagName = _this.props.targetTagName;\n\n      if (fill) {\n        targetTagName = \"div\";\n      }\n\n      if (isRefCallback(ref)) {\n        ref = combineRefs(ref, _this.refHandlers.target);\n      }\n\n      var targetEventHandlers = isHoverInteractionKind ? {\n        // HOVER handlers\n        onBlur: _this.handleTargetBlur,\n        onFocus: _this.handleTargetFocus,\n        onMouseEnter: _this.handleMouseEnter,\n        onMouseLeave: _this.handleMouseLeave\n      } : {\n        // CLICK needs only one handler\n        onClick: _this.handleTargetClick\n      };\n\n      var targetProps = __assign({\n        // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n        // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n        // applied to the generated target wrapper element.\n        className: classNames(className, Classes.POPOVER2_TARGET, (_b = {}, _b[Classes.POPOVER2_OPEN] = isOpen, // this class is mainly useful for button targets\n        _b[CoreClasses.ACTIVE] = !isControlled && isOpen && !isHoverInteractionKind, _b)),\n        ref: ref,\n        // Ensure target is focusable if relevant prop enabled. When renderTarget is undefined, we apply\n        // tabIndex to the wrapper because that's the element which has event handlers.\n        tabIndex: openOnTargetFocus && isHoverInteractionKind ? 0 : undefined\n      }, targetEventHandlers);\n\n      var target;\n\n      if (renderTarget !== undefined) {\n        target = renderTarget(__assign(__assign({}, targetProps), {\n          // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n          // when *this* popover is open\n          isOpen: isOpen\n        }));\n      } else {\n        var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n\n        if (childTarget === undefined) {\n          return null;\n        } // if there is a tabIndex set on the child target, we are going to promote it to the wrapper element\n\n\n        var childTargetTabIndex = childTarget.props.tabIndex;\n\n        if (childTargetTabIndex != null) {\n          targetProps.tabIndex = childTargetTabIndex;\n        }\n\n        var targetModifierClasses = (_c = {}, // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n        // uncontrolled popovers when they are opened by a user interaction\n        _c[CoreClasses.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind, // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n        _c[CoreClasses.FILL] = fill, _c);\n        var clonedTarget = React.cloneElement(childTarget, {\n          className: classNames(childTarget.props.className, targetModifierClasses),\n          // force disable single Tooltip2 child when popover is open\n          disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n          // avoid having two nested elements which are focussable via keyboard navigation\n          tabIndex: targetProps.tabIndex !== undefined ? -1 : undefined\n        });\n        var wrappedTarget = React.createElement(targetTagName, targetProps, clonedTarget);\n        target = wrappedTarget;\n      }\n\n      return React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, target);\n    };\n\n    _this.renderPopover = function (popperProps) {\n      var _a;\n\n      var _b = _this.props,\n          interactionKind = _b.interactionKind,\n          usePortal = _b.usePortal;\n      var isOpen = _this.state.isOpen; // compute an appropriate transform origin so the scale animation points towards target\n\n      var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined); // need to update our reference to this function on every render as it will change.\n\n      _this.popperScheduleUpdate = popperProps.update;\n      var popoverHandlers = {\n        // always check popover clicks for dismiss class\n        onClick: _this.handlePopoverClick\n      };\n\n      if (interactionKind === Popover2InteractionKind.HOVER || !usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY) {\n        popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n        popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n      }\n\n      var basePlacement = getBasePlacement(popperProps.placement);\n      var popoverClasses = classNames(Classes.POPOVER2, (_a = {}, _a[CoreClasses.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent, _a[CoreClasses.MINIMAL] = _this.props.minimal, _a[Classes.POPOVER2_CAPTURING_DISMISS] = _this.props.captureDismiss, _a), Classes.POPOVER2_CONTENT_PLACEMENT + \"-\" + basePlacement, _this.props.popoverClassName);\n      return React.createElement(Overlay, {\n        autoFocus: _this.props.autoFocus,\n        backdropClassName: Classes.POPOVER2_BACKDROP,\n        backdropProps: _this.props.backdropProps,\n        canEscapeKeyClose: _this.props.canEscapeKeyClose,\n        canOutsideClickClose: _this.props.interactionKind === Popover2InteractionKind.CLICK,\n        enforceFocus: _this.props.enforceFocus,\n        hasBackdrop: _this.props.hasBackdrop,\n        isOpen: isOpen,\n        onClose: _this.handleOverlayClose,\n        onClosed: _this.props.onClosed,\n        onClosing: _this.props.onClosing,\n        onOpened: _this.props.onOpened,\n        onOpening: _this.props.onOpening,\n        transitionDuration: _this.props.transitionDuration,\n        transitionName: Classes.POPOVER2,\n        usePortal: _this.props.usePortal,\n        portalClassName: _this.props.portalClassName,\n        portalContainer: _this.props.portalContainer\n      }, React.createElement(\"div\", {\n        className: Classes.POPOVER2_TRANSITION_CONTAINER,\n        ref: popperProps.ref,\n        style: popperProps.style\n      }, React.createElement(ResizeSensor, {\n        onResize: _this.reposition\n      }, React.createElement(\"div\", __assign({\n        className: popoverClasses,\n        style: {\n          transformOrigin: transformOrigin\n        },\n        ref: _this.popoverRef\n      }, popoverHandlers), _this.isArrowEnabled() && React.createElement(Popover2Arrow, {\n        arrowProps: popperProps.arrowProps,\n        placement: popperProps.placement\n      }), React.createElement(\"div\", {\n        className: Classes.POPOVER2_CONTENT\n      }, _this.props.content)))));\n    };\n\n    _this.handleTargetFocus = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n          // ignore this focus event -- the target was already focused but the page itself\n          // lost focus (e.g. due to switching tabs).\n          return;\n        }\n\n        _this.handleMouseEnter(e);\n      }\n    };\n\n    _this.handleTargetBlur = function (e) {\n      if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n        // if the next element to receive focus is within the popover, we'll want to leave the\n        // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n        // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n        // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n        // close the popover if necessary.\n        if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n          _this.handleMouseLeave(e);\n        }\n      }\n\n      _this.lostFocusOnSamePage = e.relatedTarget != null;\n    };\n\n    _this.handleMouseEnter = function (e) {\n      _this.isMouseInTargetOrPopover = true; // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n      // trigger the mouse leave event, as hovering over the popover shouldn't count.\n\n      if (!_this.props.usePortal && _this.isElementInPopover(e.target) && _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY && !_this.props.openOnTargetFocus) {\n        _this.handleMouseLeave(e);\n      } else if (!_this.props.disabled) {\n        // only begin opening popover when it is enabled\n        _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n      }\n    };\n\n    _this.handleMouseLeave = function (e) {\n      _this.isMouseInTargetOrPopover = false; // wait until the event queue is flushed, because we want to leave the\n      // popover open if the mouse entered the popover immediately after\n      // leaving the target (or vice versa).\n\n      _this.setTimeout(function () {\n        if (_this.isMouseInTargetOrPopover) {\n          return;\n        } // user-configurable closing delay is helpful when moving mouse from target to popover\n\n\n        _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n      });\n    };\n\n    _this.handlePopoverClick = function (e) {\n      var eventTarget = e.target;\n      var eventPopover = eventTarget.closest(\".\" + Classes.POPOVER2);\n      var isEventFromSelf = eventPopover === _this.popoverRef.current;\n      var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS); // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n\n      var dismissElement = eventTarget.closest(\".\" + Classes.POPOVER2_DISMISS + \", .\" + Classes.POPOVER2_DISMISS_OVERRIDE);\n      var shouldDismiss = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER2_DISMISS); // dismiss selectors from the \"V1\" version of Popover in the core pacakge\n      // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n      // this can be removed once Popover2 is merged into core in v4.0\n\n      var dismissElementV1 = eventTarget.closest(\".\" + CoreClasses.POPOVER_DISMISS + \", .\" + CoreClasses.POPOVER_DISMISS_OVERRIDE);\n      var shouldDismissV1 = dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(CoreClasses.POPOVER_DISMISS);\n      var isDisabled = eventTarget.closest(\":disabled, .\" + CoreClasses.DISABLED) != null;\n\n      if ((shouldDismiss || shouldDismissV1) && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleOverlayClose = function (e) {\n      if (_this.targetElement === null || e === undefined) {\n        return;\n      }\n\n      var eventTarget = e.target; // if click was in target, target event listener will handle things, so don't close\n\n      if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n        _this.setOpenState(false, e);\n      }\n    };\n\n    _this.handleTargetClick = function (e) {\n      // ensure click did not originate from within inline popover before closing\n      if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n        if (_this.props.isOpen == null) {\n          _this.setState(function (prevState) {\n            return {\n              isOpen: !prevState.isOpen\n            };\n          });\n        } else {\n          _this.setOpenState(!_this.props.isOpen, e);\n        }\n      }\n    };\n\n    return _this;\n  }\n\n  Popover2.prototype.getIsOpen = function (props) {\n    var _a; // disabled popovers should never be allowed to open.\n\n\n    if (props.disabled) {\n      return false;\n    } else {\n      return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n    }\n  };\n\n  Popover2.prototype.render = function () {\n    var _a = this.props,\n        disabled = _a.disabled,\n        content = _a.content;\n    var isOpen = this.state.isOpen;\n    var isContentEmpty = content == null || typeof content === \"string\" && content.trim() === \"\";\n\n    if (isContentEmpty) {\n      // need to do this check in render(), because `isOpen` is derived from\n      // state, and state can't necessarily be accessed in validateProps.\n      if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n        console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n      } // just render the target without a content overlay if there is no content to display\n\n\n      return this.renderTarget({\n        ref: noop\n      });\n    }\n\n    return React.createElement(Manager, null, React.createElement(Reference, null, this.renderTarget), React.createElement(Popper, {\n      innerRef: this.refHandlers.popover,\n      placement: this.props.placement,\n      strategy: \"absolute\",\n      modifiers: this.computePopperModifiers()\n    }, this.renderPopover));\n  };\n\n  Popover2.prototype.componentDidMount = function () {\n    this.updateDarkParent();\n  };\n\n  Popover2.prototype.componentDidUpdate = function (props, state) {\n    _super.prototype.componentDidUpdate.call(this, props, state);\n\n    this.updateDarkParent();\n    var nextIsOpen = this.getIsOpen(this.props);\n\n    if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n      this.setOpenState(nextIsOpen); // tricky: setOpenState calls setState only if this.props.isOpen is\n      // not controlled, so we need to invoke setState manually here.\n\n      this.setState({\n        isOpen: nextIsOpen\n      });\n    } else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n      // special case: close an uncontrolled popover when disabled is set to true\n      this.setOpenState(false);\n    }\n  };\n\n  Popover2.prototype.validateProps = function (props) {\n    if (props.isOpen == null && props.onInteraction != null) {\n      console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n    }\n\n    if (props.hasBackdrop && !props.usePortal) {\n      console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n    }\n\n    if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n      console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n    }\n\n    var childrenCount = React.Children.count(props.children);\n    var hasRenderTargetPropp = props.renderTarget !== undefined;\n\n    if (childrenCount === 0 && !hasRenderTargetPropp) {\n      console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n    }\n\n    if (childrenCount > 1) {\n      console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n    }\n\n    if (childrenCount > 0 && hasRenderTargetPropp) {\n      console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n    }\n  };\n\n  Popover2.prototype.computePopperModifiers = function () {\n    var _a, _b, _c, _d;\n\n    var modifiers = this.props.modifiers;\n    return [__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"arrow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow), __assign(__assign({\n      name: \"computeStyles\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), {\n      options: __assign({\n        adaptive: true,\n        // We disable the built-in gpuAcceleration so that\n        // Popper.js will return us easy to interpolate values\n        // (top, left instead of transform: translate3d)\n        // We'll then use these values to generate the needed\n        // css transform values blended with the react-spring values\n        gpuAcceleration: false\n      }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options)\n    }), __assign(__assign({\n      enabled: this.isArrowEnabled(),\n      name: \"offset\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), {\n      options: __assign({\n        offset: [0, POPOVER_ARROW_SVG_SIZE / 2]\n      }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options)\n    }), __assign(__assign({\n      name: \"flip\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options)\n    }), __assign(__assign({\n      name: \"preventOverflow\"\n    }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), {\n      options: __assign({\n        boundary: this.props.boundary,\n        rootBoundary: this.props.rootBoundary\n      }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options)\n    })];\n  }; // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n  // starts a timeout to delay changing the state if a non-zero duration is provided.\n\n\n  Popover2.prototype.setOpenState = function (isOpen, e, timeout) {\n    var _this = this;\n\n    var _a, _b, _c, _d, _e; // cancel any existing timeout because we have new state\n\n\n    (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n\n    if (timeout !== undefined && timeout > 0) {\n      this.cancelOpenTimeout = this.setTimeout(function () {\n        return _this.setOpenState(isOpen, e);\n      }, timeout);\n    } else {\n      if (this.props.isOpen == null) {\n        this.setState({\n          isOpen: isOpen\n        });\n      } else {\n        (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n      }\n\n      if (!isOpen) {\n        // non-null assertion because the only time `e` is undefined is when in controlled mode\n        // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n        (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n      }\n    }\n  };\n\n  Popover2.prototype.updateDarkParent = function () {\n    if (this.props.usePortal && this.state.isOpen) {\n      var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + CoreClasses.DARK) != null;\n      this.setState({\n        hasDarkParent: hasDarkParent\n      });\n    }\n  };\n\n  Popover2.prototype.isElementInPopover = function (element) {\n    return this.popoverElement != null && this.popoverElement.contains(element);\n  };\n\n  Popover2.displayName = DISPLAYNAME_PREFIX + \".Popover2\";\n  Popover2.defaultProps = {\n    boundary: \"clippingParents\",\n    captureDismiss: false,\n    defaultIsOpen: false,\n    disabled: false,\n    fill: false,\n    hasBackdrop: false,\n    hoverCloseDelay: 300,\n    hoverOpenDelay: 150,\n    inheritDarkTheme: true,\n    interactionKind: Popover2InteractionKind.CLICK,\n    minimal: false,\n    openOnTargetFocus: true,\n    placement: \"auto\",\n    renderTarget: undefined,\n    targetTagName: \"span\",\n    transitionDuration: 300,\n    usePortal: true\n  };\n  return Popover2;\n}(AbstractPureComponent2);\n\nexport { Popover2 };\n\nfunction noop() {// no-op\n}","map":{"version":3,"sources":["../../src/popover2.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/*\n * Copyright 2021 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { __assign, __extends } from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Manager, Popper, Reference } from \"react-popper\";\nimport { AbstractPureComponent2, Classes as CoreClasses, combineRefs, DISPLAYNAME_PREFIX, isRefCallback, Overlay, ResizeSensor, Utils, } from \"@blueprintjs/core\";\nimport * as Classes from \"./classes\";\nimport * as Errors from \"./errors\";\nimport { POPOVER_ARROW_SVG_SIZE, Popover2Arrow } from \"./popover2Arrow\";\n// eslint-disable-next-line import/no-cycle\nimport { Tooltip2 } from \"./tooltip2\";\nimport { getBasePlacement, getTransformOrigin } from \"./utils\";\nexport var Popover2InteractionKind = {\n    CLICK: \"click\",\n    CLICK_TARGET_ONLY: \"click-target\",\n    HOVER: \"hover\",\n    HOVER_TARGET_ONLY: \"hover-target\",\n};\n/**\n * @template T target component props inteface\n */\nvar Popover2 = /** @class */ (function (_super) {\n    __extends(Popover2, _super);\n    function Popover2() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.popoverRef = Utils.createReactRef();\n        _this.state = {\n            hasDarkParent: false,\n            isOpen: _this.getIsOpen(_this.props),\n        };\n        /**\n         * DOM element that contains the popover.\n         * When `usePortal={true}`, this element will be portaled outside the usual DOM flow,\n         * so this reference can be very useful for testing.\n         */\n        _this.popoverElement = null;\n        /** DOM element that contains the target. */\n        _this.targetElement = null;\n        _this.refHandlers = {\n            popover: function (ref) {\n                var _a, _b;\n                _this.popoverElement = ref;\n                (_b = (_a = _this.props).popoverRef) === null || _b === void 0 ? void 0 : _b.call(_a, ref);\n            },\n            target: function (ref) { return (_this.targetElement = ref); },\n        };\n        // a flag that lets us detect mouse movement between the target and popover,\n        // now that mouseleave is triggered when you cross the gap between the two.\n        _this.isMouseInTargetOrPopover = false;\n        // a flag that indicates whether the target previously lost focus to another\n        // element on the same page.\n        _this.lostFocusOnSamePage = true;\n        _this.isControlled = function () { return _this.props.isOpen !== undefined; };\n        // arrow is disabled if minimal, or if the arrow modifier was explicitly disabled\n        _this.isArrowEnabled = function () { var _a, _b; return !_this.props.minimal && ((_b = (_a = _this.props.modifiers) === null || _a === void 0 ? void 0 : _a.arrow) === null || _b === void 0 ? void 0 : _b.enabled) !== false; };\n        _this.isHoverInteractionKind = function () {\n            return (_this.props.interactionKind === Popover2InteractionKind.HOVER ||\n                _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY);\n        };\n        /**\n         * Instance method to instruct the `Popover` to recompute its position.\n         *\n         * This method should only be used if you are updating the target in a way\n         * that does not cause it to re-render, such as changing its _position_\n         * without changing its _size_ (since `Popover` already repositions when it\n         * detects a resize).\n         */\n        _this.reposition = function () { var _a; return (_a = _this.popperScheduleUpdate) === null || _a === void 0 ? void 0 : _a.call(_this); };\n        _this.renderTarget = function (_a) {\n            var _b, _c;\n            var ref = _a.ref;\n            var _d = _this.props, children = _d.children, className = _d.className, fill = _d.fill, openOnTargetFocus = _d.openOnTargetFocus, renderTarget = _d.renderTarget;\n            var isOpen = _this.state.isOpen;\n            var isControlled = _this.isControlled();\n            var isHoverInteractionKind = _this.isHoverInteractionKind();\n            var targetTagName = _this.props.targetTagName;\n            if (fill) {\n                targetTagName = \"div\";\n            }\n            if (isRefCallback(ref)) {\n                ref = combineRefs(ref, _this.refHandlers.target);\n            }\n            var targetEventHandlers = isHoverInteractionKind\n                ? {\n                    // HOVER handlers\n                    onBlur: _this.handleTargetBlur,\n                    onFocus: _this.handleTargetFocus,\n                    onMouseEnter: _this.handleMouseEnter,\n                    onMouseLeave: _this.handleMouseLeave,\n                }\n                : {\n                    // CLICK needs only one handler\n                    onClick: _this.handleTargetClick,\n                };\n            var targetProps = __assign({ \n                // N.B. this.props.className is passed along to renderTarget even though the user would have access to it.\n                // If, instead, renderTarget is undefined and the target is provided as a child, this.props.className is\n                // applied to the generated target wrapper element.\n                className: classNames(className, Classes.POPOVER2_TARGET, (_b = {},\n                    _b[Classes.POPOVER2_OPEN] = isOpen,\n                    // this class is mainly useful for button targets\n                    _b[CoreClasses.ACTIVE] = !isControlled && isOpen && !isHoverInteractionKind,\n                    _b)), ref: ref, \n                // Ensure target is focusable if relevant prop enabled. When renderTarget is undefined, we apply\n                // tabIndex to the wrapper because that's the element which has event handlers.\n                tabIndex: openOnTargetFocus && isHoverInteractionKind ? 0 : undefined }, targetEventHandlers);\n            var target;\n            if (renderTarget !== undefined) {\n                target = renderTarget(__assign(__assign({}, targetProps), { \n                    // if the consumer renders a tooltip target, it's their responsibility to disable that tooltip\n                    // when *this* popover is open\n                    isOpen: isOpen }));\n            }\n            else {\n                var childTarget = Utils.ensureElement(React.Children.toArray(children)[0]);\n                if (childTarget === undefined) {\n                    return null;\n                }\n                // if there is a tabIndex set on the child target, we are going to promote it to the wrapper element\n                var childTargetTabIndex = childTarget.props.tabIndex;\n                if (childTargetTabIndex != null) {\n                    targetProps.tabIndex = childTargetTabIndex;\n                }\n                var targetModifierClasses = (_c = {},\n                    // this class is mainly useful for Blueprint <Button> targets; we should only apply it for\n                    // uncontrolled popovers when they are opened by a user interaction\n                    _c[CoreClasses.ACTIVE] = isOpen && !isControlled && !isHoverInteractionKind,\n                    // similarly, this class is mainly useful for targets like <Button>, <InputGroup>, etc.\n                    _c[CoreClasses.FILL] = fill,\n                    _c);\n                var clonedTarget = React.cloneElement(childTarget, {\n                    className: classNames(childTarget.props.className, targetModifierClasses),\n                    // force disable single Tooltip2 child when popover is open\n                    disabled: isOpen && Utils.isElementOfType(childTarget, Tooltip2) ? true : childTarget.props.disabled,\n                    // avoid having two nested elements which are focussable via keyboard navigation\n                    tabIndex: targetProps.tabIndex !== undefined ? -1 : undefined,\n                });\n                var wrappedTarget = React.createElement(targetTagName, targetProps, clonedTarget);\n                target = wrappedTarget;\n            }\n            return React.createElement(ResizeSensor, { onResize: _this.reposition }, target);\n        };\n        _this.renderPopover = function (popperProps) {\n            var _a;\n            var _b = _this.props, interactionKind = _b.interactionKind, usePortal = _b.usePortal;\n            var isOpen = _this.state.isOpen;\n            // compute an appropriate transform origin so the scale animation points towards target\n            var transformOrigin = getTransformOrigin(popperProps.placement, _this.isArrowEnabled() ? popperProps.arrowProps.style : undefined);\n            // need to update our reference to this function on every render as it will change.\n            _this.popperScheduleUpdate = popperProps.update;\n            var popoverHandlers = {\n                // always check popover clicks for dismiss class\n                onClick: _this.handlePopoverClick,\n            };\n            if (interactionKind === Popover2InteractionKind.HOVER ||\n                (!usePortal && interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY)) {\n                popoverHandlers.onMouseEnter = _this.handleMouseEnter;\n                popoverHandlers.onMouseLeave = _this.handleMouseLeave;\n            }\n            var basePlacement = getBasePlacement(popperProps.placement);\n            var popoverClasses = classNames(Classes.POPOVER2, (_a = {},\n                _a[CoreClasses.DARK] = _this.props.inheritDarkTheme && _this.state.hasDarkParent,\n                _a[CoreClasses.MINIMAL] = _this.props.minimal,\n                _a[Classes.POPOVER2_CAPTURING_DISMISS] = _this.props.captureDismiss,\n                _a), Classes.POPOVER2_CONTENT_PLACEMENT + \"-\" + basePlacement, _this.props.popoverClassName);\n            return (React.createElement(Overlay, { autoFocus: _this.props.autoFocus, backdropClassName: Classes.POPOVER2_BACKDROP, backdropProps: _this.props.backdropProps, canEscapeKeyClose: _this.props.canEscapeKeyClose, canOutsideClickClose: _this.props.interactionKind === Popover2InteractionKind.CLICK, enforceFocus: _this.props.enforceFocus, hasBackdrop: _this.props.hasBackdrop, isOpen: isOpen, onClose: _this.handleOverlayClose, onClosed: _this.props.onClosed, onClosing: _this.props.onClosing, onOpened: _this.props.onOpened, onOpening: _this.props.onOpening, transitionDuration: _this.props.transitionDuration, transitionName: Classes.POPOVER2, usePortal: _this.props.usePortal, portalClassName: _this.props.portalClassName, portalContainer: _this.props.portalContainer },\n                React.createElement(\"div\", { className: Classes.POPOVER2_TRANSITION_CONTAINER, ref: popperProps.ref, style: popperProps.style },\n                    React.createElement(ResizeSensor, { onResize: _this.reposition },\n                        React.createElement(\"div\", __assign({ className: popoverClasses, style: { transformOrigin: transformOrigin }, ref: _this.popoverRef }, popoverHandlers),\n                            _this.isArrowEnabled() && (React.createElement(Popover2Arrow, { arrowProps: popperProps.arrowProps, placement: popperProps.placement })),\n                            React.createElement(\"div\", { className: Classes.POPOVER2_CONTENT }, _this.props.content))))));\n        };\n        _this.handleTargetFocus = function (e) {\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                if (e.relatedTarget == null && !_this.lostFocusOnSamePage) {\n                    // ignore this focus event -- the target was already focused but the page itself\n                    // lost focus (e.g. due to switching tabs).\n                    return;\n                }\n                _this.handleMouseEnter(e);\n            }\n        };\n        _this.handleTargetBlur = function (e) {\n            if (_this.props.openOnTargetFocus && _this.isHoverInteractionKind()) {\n                // if the next element to receive focus is within the popover, we'll want to leave the\n                // popover open. e.relatedTarget ought to tell us the next element to receive focus, but if the user just\n                // clicked on an element which is not focusable (either by default or with a tabIndex attribute),\n                // it won't be set. So, we filter those out here and assume that a click handler somewhere else will\n                // close the popover if necessary.\n                if (e.relatedTarget != null && !_this.isElementInPopover(e.relatedTarget)) {\n                    _this.handleMouseLeave(e);\n                }\n            }\n            _this.lostFocusOnSamePage = e.relatedTarget != null;\n        };\n        _this.handleMouseEnter = function (e) {\n            _this.isMouseInTargetOrPopover = true;\n            // if we're entering the popover, and the mode is set to be HOVER_TARGET_ONLY, we want to manually\n            // trigger the mouse leave event, as hovering over the popover shouldn't count.\n            if (!_this.props.usePortal &&\n                _this.isElementInPopover(e.target) &&\n                _this.props.interactionKind === Popover2InteractionKind.HOVER_TARGET_ONLY &&\n                !_this.props.openOnTargetFocus) {\n                _this.handleMouseLeave(e);\n            }\n            else if (!_this.props.disabled) {\n                // only begin opening popover when it is enabled\n                _this.setOpenState(true, e, _this.props.hoverOpenDelay);\n            }\n        };\n        _this.handleMouseLeave = function (e) {\n            _this.isMouseInTargetOrPopover = false;\n            // wait until the event queue is flushed, because we want to leave the\n            // popover open if the mouse entered the popover immediately after\n            // leaving the target (or vice versa).\n            _this.setTimeout(function () {\n                if (_this.isMouseInTargetOrPopover) {\n                    return;\n                }\n                // user-configurable closing delay is helpful when moving mouse from target to popover\n                _this.setOpenState(false, e, _this.props.hoverCloseDelay);\n            });\n        };\n        _this.handlePopoverClick = function (e) {\n            var eventTarget = e.target;\n            var eventPopover = eventTarget.closest(\".\" + Classes.POPOVER2);\n            var isEventFromSelf = eventPopover === _this.popoverRef.current;\n            var isEventPopoverCapturing = eventPopover === null || eventPopover === void 0 ? void 0 : eventPopover.classList.contains(Classes.POPOVER2_CAPTURING_DISMISS);\n            // an OVERRIDE inside a DISMISS does not dismiss, and a DISMISS inside an OVERRIDE will dismiss.\n            var dismissElement = eventTarget.closest(\".\" + Classes.POPOVER2_DISMISS + \", .\" + Classes.POPOVER2_DISMISS_OVERRIDE);\n            var shouldDismiss = dismissElement === null || dismissElement === void 0 ? void 0 : dismissElement.classList.contains(Classes.POPOVER2_DISMISS);\n            // dismiss selectors from the \"V1\" version of Popover in the core pacakge\n            // we expect these to be rendered by MenuItem, which at this point has no knowledge of Popover2\n            // this can be removed once Popover2 is merged into core in v4.0\n            var dismissElementV1 = eventTarget.closest(\".\" + CoreClasses.POPOVER_DISMISS + \", .\" + CoreClasses.POPOVER_DISMISS_OVERRIDE);\n            var shouldDismissV1 = dismissElementV1 === null || dismissElementV1 === void 0 ? void 0 : dismissElementV1.classList.contains(CoreClasses.POPOVER_DISMISS);\n            var isDisabled = eventTarget.closest(\":disabled, .\" + CoreClasses.DISABLED) != null;\n            if ((shouldDismiss || shouldDismissV1) && !isDisabled && (!isEventPopoverCapturing || isEventFromSelf)) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleOverlayClose = function (e) {\n            if (_this.targetElement === null || e === undefined) {\n                return;\n            }\n            var eventTarget = e.target;\n            // if click was in target, target event listener will handle things, so don't close\n            if (!Utils.elementIsOrContains(_this.targetElement, eventTarget) || e.nativeEvent instanceof KeyboardEvent) {\n                _this.setOpenState(false, e);\n            }\n        };\n        _this.handleTargetClick = function (e) {\n            // ensure click did not originate from within inline popover before closing\n            if (!_this.props.disabled && !_this.isElementInPopover(e.target)) {\n                if (_this.props.isOpen == null) {\n                    _this.setState(function (prevState) { return ({ isOpen: !prevState.isOpen }); });\n                }\n                else {\n                    _this.setOpenState(!_this.props.isOpen, e);\n                }\n            }\n        };\n        return _this;\n    }\n    Popover2.prototype.getIsOpen = function (props) {\n        var _a;\n        // disabled popovers should never be allowed to open.\n        if (props.disabled) {\n            return false;\n        }\n        else {\n            return (_a = props.isOpen) !== null && _a !== void 0 ? _a : props.defaultIsOpen;\n        }\n    };\n    Popover2.prototype.render = function () {\n        var _a = this.props, disabled = _a.disabled, content = _a.content;\n        var isOpen = this.state.isOpen;\n        var isContentEmpty = content == null || (typeof content === \"string\" && content.trim() === \"\");\n        if (isContentEmpty) {\n            // need to do this check in render(), because `isOpen` is derived from\n            // state, and state can't necessarily be accessed in validateProps.\n            if (!disabled && isOpen !== false && !Utils.isNodeEnv(\"production\")) {\n                console.warn(Errors.POPOVER2_WARN_EMPTY_CONTENT);\n            }\n            // just render the target without a content overlay if there is no content to display\n            return this.renderTarget({ ref: noop });\n        }\n        return (React.createElement(Manager, null,\n            React.createElement(Reference, null, this.renderTarget),\n            React.createElement(Popper, { innerRef: this.refHandlers.popover, placement: this.props.placement, strategy: \"absolute\", modifiers: this.computePopperModifiers() }, this.renderPopover)));\n    };\n    Popover2.prototype.componentDidMount = function () {\n        this.updateDarkParent();\n    };\n    Popover2.prototype.componentDidUpdate = function (props, state) {\n        _super.prototype.componentDidUpdate.call(this, props, state);\n        this.updateDarkParent();\n        var nextIsOpen = this.getIsOpen(this.props);\n        if (this.props.isOpen != null && nextIsOpen !== this.state.isOpen) {\n            this.setOpenState(nextIsOpen);\n            // tricky: setOpenState calls setState only if this.props.isOpen is\n            // not controlled, so we need to invoke setState manually here.\n            this.setState({ isOpen: nextIsOpen });\n        }\n        else if (this.props.disabled && this.state.isOpen && this.props.isOpen == null) {\n            // special case: close an uncontrolled popover when disabled is set to true\n            this.setOpenState(false);\n        }\n    };\n    Popover2.prototype.validateProps = function (props) {\n        if (props.isOpen == null && props.onInteraction != null) {\n            console.warn(Errors.POPOVER2_WARN_UNCONTROLLED_ONINTERACTION);\n        }\n        if (props.hasBackdrop && !props.usePortal) {\n            console.warn(Errors.POPOVER2_WARN_HAS_BACKDROP_INLINE);\n        }\n        if (props.hasBackdrop && props.interactionKind !== Popover2InteractionKind.CLICK) {\n            console.warn(Errors.POPOVER2_HAS_BACKDROP_INTERACTION);\n        }\n        var childrenCount = React.Children.count(props.children);\n        var hasRenderTargetPropp = props.renderTarget !== undefined;\n        if (childrenCount === 0 && !hasRenderTargetPropp) {\n            console.warn(Errors.POPOVER2_REQUIRES_TARGET);\n        }\n        if (childrenCount > 1) {\n            console.warn(Errors.POPOVER2_WARN_TOO_MANY_CHILDREN);\n        }\n        if (childrenCount > 0 && hasRenderTargetPropp) {\n            console.warn(Errors.POPOVER2_WARN_DOUBLE_TARGET);\n        }\n    };\n    Popover2.prototype.computePopperModifiers = function () {\n        var _a, _b, _c, _d;\n        var modifiers = this.props.modifiers;\n        return [\n            __assign({ enabled: this.isArrowEnabled(), name: \"arrow\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.arrow),\n            __assign(__assign({ name: \"computeStyles\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles), { options: __assign({ adaptive: true, \n                    // We disable the built-in gpuAcceleration so that\n                    // Popper.js will return us easy to interpolate values\n                    // (top, left instead of transform: translate3d)\n                    // We'll then use these values to generate the needed\n                    // css transform values blended with the react-spring values\n                    gpuAcceleration: false }, (_a = modifiers === null || modifiers === void 0 ? void 0 : modifiers.computeStyles) === null || _a === void 0 ? void 0 : _a.options) }),\n            __assign(__assign({ enabled: this.isArrowEnabled(), name: \"offset\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset), { options: __assign({ offset: [0, POPOVER_ARROW_SVG_SIZE / 2] }, (_b = modifiers === null || modifiers === void 0 ? void 0 : modifiers.offset) === null || _b === void 0 ? void 0 : _b.options) }),\n            __assign(__assign({ name: \"flip\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip), { options: __assign({ boundary: this.props.boundary, rootBoundary: this.props.rootBoundary }, (_c = modifiers === null || modifiers === void 0 ? void 0 : modifiers.flip) === null || _c === void 0 ? void 0 : _c.options) }),\n            __assign(__assign({ name: \"preventOverflow\" }, modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow), { options: __assign({ boundary: this.props.boundary, rootBoundary: this.props.rootBoundary }, (_d = modifiers === null || modifiers === void 0 ? void 0 : modifiers.preventOverflow) === null || _d === void 0 ? void 0 : _d.options) }),\n        ];\n    };\n    // a wrapper around setState({ isOpen }) that will call props.onInteraction instead when in controlled mode.\n    // starts a timeout to delay changing the state if a non-zero duration is provided.\n    Popover2.prototype.setOpenState = function (isOpen, e, timeout) {\n        var _this = this;\n        var _a, _b, _c, _d, _e;\n        // cancel any existing timeout because we have new state\n        (_a = this.cancelOpenTimeout) === null || _a === void 0 ? void 0 : _a.call(this);\n        if (timeout !== undefined && timeout > 0) {\n            this.cancelOpenTimeout = this.setTimeout(function () { return _this.setOpenState(isOpen, e); }, timeout);\n        }\n        else {\n            if (this.props.isOpen == null) {\n                this.setState({ isOpen: isOpen });\n            }\n            else {\n                (_c = (_b = this.props).onInteraction) === null || _c === void 0 ? void 0 : _c.call(_b, isOpen, e);\n            }\n            if (!isOpen) {\n                // non-null assertion because the only time `e` is undefined is when in controlled mode\n                // or the rare special case in uncontrolled mode when the `disabled` flag is toggled true\n                (_e = (_d = this.props).onClose) === null || _e === void 0 ? void 0 : _e.call(_d, e);\n            }\n        }\n    };\n    Popover2.prototype.updateDarkParent = function () {\n        if (this.props.usePortal && this.state.isOpen) {\n            var hasDarkParent = this.targetElement != null && this.targetElement.closest(\".\" + CoreClasses.DARK) != null;\n            this.setState({ hasDarkParent: hasDarkParent });\n        }\n    };\n    Popover2.prototype.isElementInPopover = function (element) {\n        return this.popoverElement != null && this.popoverElement.contains(element);\n    };\n    Popover2.displayName = DISPLAYNAME_PREFIX + \".Popover2\";\n    Popover2.defaultProps = {\n        boundary: \"clippingParents\",\n        captureDismiss: false,\n        defaultIsOpen: false,\n        disabled: false,\n        fill: false,\n        hasBackdrop: false,\n        hoverCloseDelay: 300,\n        hoverOpenDelay: 150,\n        inheritDarkTheme: true,\n        interactionKind: Popover2InteractionKind.CLICK,\n        minimal: false,\n        openOnTargetFocus: true,\n        placement: \"auto\",\n        renderTarget: undefined,\n        targetTagName: \"span\",\n        transitionDuration: 300,\n        usePortal: true,\n    };\n    return Popover2;\n}(AbstractPureComponent2));\nexport { Popover2 };\nfunction noop() {\n    // no-op\n}\n//# sourceMappingURL=popover2.js.map"]},"metadata":{},"sourceType":"module"}