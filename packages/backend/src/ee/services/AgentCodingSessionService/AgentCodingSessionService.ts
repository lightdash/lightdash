import {
    AgentCodingSession,
    AgentCodingSessionEvent,
    AgentCodingSessionMessage,
    AgentCodingStreamEvent,
    DbtProjectType,
    ForbiddenError,
    ParameterError,
    SessionUser,
} from '@lightdash/common';
import { Sandbox } from 'e2b';
import { getInstallationTokenForRepository } from '../../../clients/github/Github';
import { LightdashConfig } from '../../../config/parseConfig';
import Logger from '../../../logging/logger';
import { PersonalAccessTokenModel } from '../../../models/DashboardModel/PersonalAccessTokenModel';
import { GithubAppInstallationsModel } from '../../../models/GithubAppInstallations/GithubAppInstallationsModel';
import { ProjectModel } from '../../../models/ProjectModel/ProjectModel';
import { E2bClient } from '../../clients/E2bClient';
import { AgentCodingSessionModel } from '../../models/AgentCodingSessionModel';

interface AgentCodingSessionServiceDependencies {
    lightdashConfig: LightdashConfig;
    agentCodingSessionModel: AgentCodingSessionModel;
    githubAppInstallationsModel: GithubAppInstallationsModel;
    projectModel: ProjectModel;
    personalAccessTokenModel: PersonalAccessTokenModel;
}

const sleep = (ms: number): Promise<void> =>
    new Promise((resolve) => {
        setTimeout(resolve, ms);
    });

export class AgentCodingSessionService {
    private readonly lightdashConfig: LightdashConfig;

    private readonly agentCodingSessionModel: AgentCodingSessionModel;

    private readonly githubAppInstallationsModel: GithubAppInstallationsModel;

    private readonly projectModel: ProjectModel;

    private readonly personalAccessTokenModel: PersonalAccessTokenModel;

    private readonly e2bClient: E2bClient;

    constructor(deps: AgentCodingSessionServiceDependencies) {
        this.lightdashConfig = deps.lightdashConfig;
        this.agentCodingSessionModel = deps.agentCodingSessionModel;
        this.githubAppInstallationsModel = deps.githubAppInstallationsModel;
        this.projectModel = deps.projectModel;
        this.personalAccessTokenModel = deps.personalAccessTokenModel;
        this.e2bClient = new E2bClient({
            lightdashConfig: this.lightdashConfig,
        });
    }

    private async validateProjectGitHubConfig(
        user: SessionUser,
        projectUuid: string,
    ): Promise<{ repository: string; installationId: string }> {
        const project = await this.projectModel.get(projectUuid);

        // Check project has GitHub dbt connection
        const { dbtConnection } = project;
        if (!dbtConnection || dbtConnection.type !== DbtProjectType.GITHUB) {
            throw new ParameterError(
                'Project must be configured with GitHub repository to use agent coding sessions',
            );
        }

        const { repository } = dbtConnection;
        if (!repository) {
            throw new ParameterError(
                'Project GitHub configuration is missing repository',
            );
        }

        // Check org has GitHub App installed
        const installationId =
            await this.githubAppInstallationsModel.findInstallationId(
                user.organizationUuid!,
            );
        if (!installationId) {
            throw new ParameterError(
                'GitHub App must be installed on your organization to use agent coding sessions',
            );
        }

        return { repository, installationId };
    }

    private async createShortLivedPAT(user: SessionUser): Promise<string> {
        // Create a PAT that expires in 1 hour
        const expiresAt = new Date(Date.now() + 60 * 60 * 1000);
        const pat = await this.personalAccessTokenModel.create(
            { userId: user.userId },
            {
                description: `Agent Coding Session - ${new Date().toISOString()}`,
                expiresAt,
                autoGenerated: true,
            },
        );
        return pat.token;
    }

    async listSessions(
        user: SessionUser,
        projectUuid: string,
    ): Promise<AgentCodingSession[]> {
        return this.agentCodingSessionModel.listSessionsByUserAndProject(
            user.userUuid,
            projectUuid,
        );
    }

    async getSession(
        user: SessionUser,
        sessionUuid: string,
    ): Promise<AgentCodingSession> {
        const session =
            await this.agentCodingSessionModel.getSession(sessionUuid);

        // Verify ownership
        if (session.createdByUserUuid !== user.userUuid) {
            throw new ForbiddenError('You do not have access to this session');
        }

        return session;
    }

    async getSessionMessages(
        user: SessionUser,
        sessionUuid: string,
    ): Promise<AgentCodingSessionMessage[]> {
        // Verify ownership first
        await this.getSession(user, sessionUuid);
        return this.agentCodingSessionModel.getMessagesBySession(sessionUuid);
    }

    async createSession(
        user: SessionUser,
        projectUuid: string,
        prompt: string,
        githubBranch: string,
    ): Promise<AgentCodingSession> {
        Logger.info('Creating agent coding session', {
            projectUuid,
            userUuid: user.userUuid,
            githubBranch,
            promptLength: prompt.length,
        });

        const { repository } = await this.validateProjectGitHubConfig(
            user,
            projectUuid,
        );

        Logger.info('Project GitHub config validated', {
            projectUuid,
            repository,
        });

        // Create session in DB
        const session = await this.agentCodingSessionModel.createSession(
            projectUuid,
            user.userUuid,
            repository,
            githubBranch,
        );

        Logger.info('Agent coding session created in database', {
            sessionUuid: session.sessionUuid,
            projectUuid,
            repository,
            githubBranch,
        });

        // Store the initial prompt as a user message
        await this.agentCodingSessionModel.createMessage(
            session.sessionUuid,
            'user',
            prompt,
        );

        // Kick off execution asynchronously (fire and forget)
        this.executeSession(session.sessionUuid, user).catch((err) => {
            Logger.error('Background session execution failed', {
                sessionUuid: session.sessionUuid,
                error: err instanceof Error ? err.message : 'Unknown error',
            });
        });

        return session;
    }

    /**
     * Helper to append an event to the DB.
     */
    private async appendEvent(
        sessionUuid: string,
        event: AgentCodingStreamEvent,
    ): Promise<number> {
        return this.agentCodingSessionModel.appendEvent(sessionUuid, event);
    }

    /**
     * Execute a session in the background.
     * Writes events to DB instead of using callbacks.
     */
    private async executeSession(
        sessionUuid: string,
        user: SessionUser,
    ): Promise<void> {
        Logger.info('Starting background session execution', {
            sessionUuid,
            userUuid: user.userUuid,
        });

        const session =
            await this.agentCodingSessionModel.getSessionWithSandboxId(
                sessionUuid,
            );

        Logger.info('Session retrieved from database', {
            sessionUuid,
            projectUuid: session.projectUuid,
            existingSandboxId: session.e2bSandboxId || null,
            existingClaudeSessionId: session.claudeSessionId || null,
        });

        // Get messages to find the prompt
        const messages =
            await this.agentCodingSessionModel.getMessagesBySession(
                sessionUuid,
            );
        const lastUserMessage = messages.filter((m) => m.role === 'user').pop();
        if (!lastUserMessage) {
            await this.appendEvent(sessionUuid, {
                type: 'error',
                error: 'No prompt found for session',
            });
            await this.agentCodingSessionModel.updateSession(sessionUuid, {
                status: 'errored',
                errorMessage: 'No prompt found for session',
            });
            return;
        }

        const { repository, installationId } =
            await this.validateProjectGitHubConfig(user, session.projectUuid);

        Logger.info('GitHub config validated for session', {
            sessionUuid,
            repository,
            installationId,
        });

        let sandbox: Sandbox | undefined;

        try {
            // Get scoped GitHub token
            const githubToken = await getInstallationTokenForRepository(
                installationId,
                repository,
            );

            // Create short-lived Lightdash PAT
            const lightdashPat = await this.createShortLivedPAT(user);

            // Get Lightdash domain
            const lightdashUrl = new URL(this.lightdashConfig.siteUrl);
            const lightdashDomain = lightdashUrl.hostname;

            // Get Anthropic API key from AI copilot config
            const anthropicApiKey =
                this.lightdashConfig.ai.copilot.providers.anthropic?.apiKey ||
                '';

            const envs = {
                ANTHROPIC_API_KEY: anthropicApiKey,
                GITHUB_TOKEN: githubToken,
                LIGHTDASH_API_KEY: lightdashPat,
                LIGHTDASH_URL: this.lightdashConfig.siteUrl,
                LIGHTDASH_PROJECT: session.projectUuid,
            };

            // Resume existing sandbox or create new one
            if (session.e2bSandboxId) {
                Logger.info('Attempting to resume existing sandbox', {
                    sessionUuid,
                    sandboxId: session.e2bSandboxId,
                });
                try {
                    sandbox = await this.e2bClient.resumeSandbox(
                        session.e2bSandboxId,
                    );
                    Logger.info('Sandbox resumed successfully', {
                        sessionUuid,
                        sandboxId: session.e2bSandboxId,
                    });
                    await this.agentCodingSessionModel.updateSession(
                        sessionUuid,
                        { status: 'running' },
                    );
                    await this.appendEvent(sessionUuid, {
                        type: 'status',
                        status: 'running',
                    });
                } catch (resumeError) {
                    Logger.info('Failed to resume sandbox, creating new one', {
                        sessionUuid,
                        oldSandboxId: session.e2bSandboxId,
                        error:
                            resumeError instanceof Error
                                ? resumeError.message
                                : 'Unknown error',
                    });
                    // Sandbox expired, create new one
                    sandbox = await this.e2bClient.createSandbox({
                        lightdashDomain,
                        anthropicApiKey: envs.ANTHROPIC_API_KEY,
                        githubToken,
                        lightdashApiKey: lightdashPat,
                        lightdashProjectUuid: session.projectUuid,
                    });

                    await this.e2bClient.cloneRepository(
                        sandbox,
                        repository,
                        session.githubBranch,
                        githubToken,
                    );

                    // Clear old Claude session since we have a new sandbox
                    await this.agentCodingSessionModel.updateSession(
                        sessionUuid,
                        {
                            e2bSandboxId: sandbox.sandboxId,
                            claudeSessionId: undefined,
                            status: 'running',
                        },
                    );
                    Logger.info('New sandbox created after resume failure', {
                        sessionUuid,
                        newSandboxId: sandbox.sandboxId,
                    });
                    await this.appendEvent(sessionUuid, {
                        type: 'status',
                        status: 'running',
                    });
                }
            } else {
                Logger.info('Creating first sandbox for session', {
                    sessionUuid,
                    repository,
                    branch: session.githubBranch,
                });
                // First time - create sandbox and clone
                sandbox = await this.e2bClient.createSandbox({
                    lightdashDomain,
                    anthropicApiKey: envs.ANTHROPIC_API_KEY,
                    githubToken,
                    lightdashApiKey: lightdashPat,
                    lightdashProjectUuid: session.projectUuid,
                });

                Logger.info('Sandbox created, cloning repository', {
                    sessionUuid,
                    sandboxId: sandbox.sandboxId,
                    repository,
                });

                await this.e2bClient.cloneRepository(
                    sandbox,
                    repository,
                    session.githubBranch,
                    githubToken,
                );

                await this.agentCodingSessionModel.updateSession(sessionUuid, {
                    e2bSandboxId: sandbox.sandboxId,
                    status: 'running',
                });
                Logger.info('Sandbox setup complete', {
                    sessionUuid,
                    sandboxId: sandbox.sandboxId,
                });
                await this.appendEvent(sessionUuid, {
                    type: 'status',
                    status: 'running',
                });
            }

            // Verify Lightdash CLI works before starting Claude
            await this.e2bClient.verifyLightdashCli(sandbox, envs);

            // Run Claude
            Logger.info('Starting Claude execution in sandbox', {
                sessionUuid,
                sandboxId: sandbox.sandboxId,
                resumeClaudeSession: session.claudeSessionId || null,
            });

            let assistantResponse = '';
            const { sessionId: claudeSessionId } =
                await this.e2bClient.runClaudeStreaming(
                    sandbox,
                    lastUserMessage.content,
                    envs,
                    session.claudeSessionId || undefined,
                    async (token) => {
                        assistantResponse += token;
                        await this.appendEvent(sessionUuid, {
                            type: 'token',
                            text: token,
                        });
                    },
                    async (newSessionId) => {
                        await this.appendEvent(sessionUuid, {
                            type: 'status',
                            status: 'running',
                            sessionId: newSessionId,
                        });
                    },
                    {
                        onToolStart: async (toolName, toolUseId) => {
                            await this.appendEvent(sessionUuid, {
                                type: 'tool_start',
                                toolName,
                                toolUseId,
                            });
                        },
                        onToolInputDelta: async (partialJson) => {
                            await this.appendEvent(sessionUuid, {
                                type: 'tool_input_delta',
                                partialJson,
                            });
                        },
                        onToolEnd: async () => {
                            await this.appendEvent(sessionUuid, {
                                type: 'tool_end',
                            });
                        },
                    },
                );

            Logger.info('Claude execution completed', {
                sessionUuid,
                claudeSessionId,
                responseLength: assistantResponse.length,
            });

            // Store assistant response
            if (assistantResponse) {
                await this.agentCodingSessionModel.createMessage(
                    sessionUuid,
                    'assistant',
                    assistantResponse,
                );
            }

            // Commit and push any changes Claude made
            await this.e2bClient.commitAndPush(
                sandbox,
                session.githubBranch,
                `Lightdash AI: ${lastUserMessage.content.slice(0, 50)}${lastUserMessage.content.length > 50 ? '...' : ''}`,
            );

            // Pause sandbox to preserve state for future interactions
            await this.e2bClient.pauseSandbox(sandbox);

            // Update session with Claude session ID and status
            await this.agentCodingSessionModel.updateSession(sessionUuid, {
                claudeSessionId: claudeSessionId || undefined,
                status: 'finished',
            });

            // Write completion event
            await this.appendEvent(sessionUuid, {
                type: 'status',
                status: 'finished',
            });
            await this.appendEvent(sessionUuid, { type: 'complete' });

            Logger.info('Session execution completed successfully', {
                sessionUuid,
                claudeSessionId,
            });

            // Prune events for completed session (optional - could also be done by scheduled job)
            // We keep them for now to allow reconnection for a short period after completion
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : 'Unknown error';
            Logger.error('Session execution failed', {
                sessionUuid,
                error: errorMessage,
            });

            // Clean up sandbox on error to avoid leaving it running
            if (sandbox) {
                try {
                    await sandbox.kill();
                    Logger.info('Sandbox killed after error', {
                        sessionUuid,
                        sandboxId: sandbox.sandboxId,
                    });
                } catch (killError) {
                    Logger.warn('Failed to kill sandbox after error', {
                        sessionUuid,
                        sandboxId: sandbox.sandboxId,
                        error:
                            killError instanceof Error
                                ? killError.message
                                : 'Unknown error',
                    });
                }
            }

            await this.agentCodingSessionModel.updateSession(sessionUuid, {
                status: 'errored',
                errorMessage,
            });
            await this.appendEvent(sessionUuid, {
                type: 'error',
                error: errorMessage,
            });
        }
    }

    /**
     * Stream session events to a client.
     * Supports reconnection via lastEventId parameter.
     */
    async streamSession(
        user: SessionUser,
        sessionUuid: string,
        lastEventId: number,
        onEvent: (event: AgentCodingSessionEvent) => void,
        signal: AbortSignal,
    ): Promise<void> {
        // Verify ownership
        await this.getSession(user, sessionUuid);

        let currentEventId = lastEventId;

        /* eslint-disable no-await-in-loop */
        // Intentional polling loop - awaits are required for sequential event streaming
        while (!signal.aborted) {
            // Fetch new events since last event ID
            const events =
                await this.agentCodingSessionModel.getEventsSince(
                    sessionUuid,
                    currentEventId,
                );

            for (const event of events) {
                onEvent(event);
                currentEventId = event.eventId;
            }

            // Check if session is complete
            const session =
                await this.agentCodingSessionModel.getSession(sessionUuid);
            if (session.status === 'finished' || session.status === 'errored') {
                // Fetch any remaining events one more time
                const finalEvents =
                    await this.agentCodingSessionModel.getEventsSince(
                        sessionUuid,
                        currentEventId,
                    );
                for (const event of finalEvents) {
                    onEvent(event);
                }
                break;
            }

            // Poll interval
            await sleep(100);
        }
        /* eslint-enable no-await-in-loop */
    }

    async sendMessage(
        user: SessionUser,
        sessionUuid: string,
        prompt: string,
    ): Promise<AgentCodingSessionMessage> {
        // Verify ownership
        const session = await this.getSession(user, sessionUuid);

        // Prevent sending message while session is running
        if (session.status === 'running') {
            throw new ParameterError(
                'Session is already running. Wait for it to complete before sending a new message.',
            );
        }

        // Clear old streaming events before starting new execution
        // This prevents the frontend from receiving duplicate content
        await this.agentCodingSessionModel.pruneEventsForSession(sessionUuid);

        // Store the message
        const message = await this.agentCodingSessionModel.createMessage(
            sessionUuid,
            'user',
            prompt,
        );

        // Update session status to pending
        await this.agentCodingSessionModel.updateSession(sessionUuid, {
            status: 'pending',
        });

        // Kick off execution asynchronously (fire and forget)
        this.executeSession(sessionUuid, user).catch((err) => {
            Logger.error('Background session execution failed', {
                sessionUuid,
                error: err instanceof Error ? err.message : 'Unknown error',
            });
        });

        return message;
    }

    async deleteSession(user: SessionUser, sessionUuid: string): Promise<void> {
        const session =
            await this.agentCodingSessionModel.getSessionWithSandboxId(
                sessionUuid,
            );

        // Verify ownership
        if (session.createdByUserUuid !== user.userUuid) {
            throw new ForbiddenError('You do not have access to this session');
        }

        // Kill sandbox if exists
        if (session.e2bSandboxId) {
            await this.e2bClient.killSandbox(session.e2bSandboxId);
        }

        // Delete from DB (cascades to messages)
        await this.agentCodingSessionModel.deleteSession(sessionUuid);
    }
}
