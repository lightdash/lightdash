import {
    getTotalFilterRules,
    isSlackPrompt,
    metricQueryTableViz,
    toolTableVizArgsSchema,
    toolTableVizArgsSchemaTransformed,
} from '@lightdash/common';
import { tool } from 'ai';
import { stringify } from 'csv-stringify/sync';
import { CsvService } from '../../../../services/CsvService/CsvService';
import type {
    GetExploreFn,
    GetPromptFn,
    RunMiniMetricQueryFn,
    SendFileFn,
    UpdateProgressFn,
    UpdatePromptFn,
} from '../types/aiAgentDependencies';
import { serializeData } from '../utils/serializeData';
import { toolErrorHandler } from '../utils/toolErrorHandler';
import {
    validateFilterRules,
    validateSelectedFieldsExistence,
} from '../utils/validators';
import { renderTableViz } from '../visualizations/vizTable';

type Dependencies = {
    getExplore: GetExploreFn;
    updateProgress: UpdateProgressFn;
    runMiniMetricQuery: RunMiniMetricQueryFn;
    getPrompt: GetPromptFn;
    updatePrompt: UpdatePromptFn;
    sendFile: SendFileFn;
    maxLimit: number;
};
export const getGenerateTableVizConfig = ({
    getExplore,
    runMiniMetricQuery,
    getPrompt,
    sendFile,
    updatePrompt,
    updateProgress,
    maxLimit,
}: Dependencies) => {
    const schema = toolTableVizArgsSchema;

    return tool({
        description: `Use this tool to query data to display in a table or summarized if limit is set to 1.`,
        parameters: schema,
        execute: async (toolArgs) => {
            let isOneRow = false;
            try {
                await updateProgress('ðŸ”¢ Querying the data...');

                // TODO: common for all viz tools. find a way to reuse this code.
                const vizTool =
                    toolTableVizArgsSchemaTransformed.parse(toolArgs);

                const filterRules = getTotalFilterRules(vizTool.filters);
                const explore = await getExplore({
                    exploreName: vizTool.vizConfig.exploreName,
                });
                const fieldsToValidate = [
                    ...vizTool.vizConfig.dimensions,
                    ...vizTool.vizConfig.metrics,
                    ...vizTool.vizConfig.sorts.map(
                        (sortField) => sortField.fieldId,
                    ),
                ].filter((x) => typeof x === 'string');
                validateSelectedFieldsExistence(explore, fieldsToValidate);
                validateFilterRules(explore, filterRules);
                // end of TODO

                const prompt = await getPrompt();
                await updatePrompt({
                    promptUuid: prompt.promptUuid,
                    vizConfigOutput: toolArgs,
                });

                const { csv, results } = await renderTableViz({
                    runMetricQuery: (q) => runMiniMetricQuery(q, maxLimit),
                    vizTool,
                    maxLimit,
                });
                await updateProgress('âœ… Done.');

                isOneRow = results.rows.length === 1;

                if (isOneRow) {
                    return `Here's the result:
${serializeData(csv, 'csv')}`;
                }

                if (isSlackPrompt(prompt)) {
                    await sendFile({
                        channelId: prompt.slackChannelId,
                        threadTs: prompt.slackThreadTs,
                        organizationUuid: prompt.organizationUuid,
                        title: 'Generated by Lightdash',
                        comment: `CSV results generated by Lightdash`,
                        filename: 'lightdash-query-results.csv',
                        file: Buffer.from(csv, 'utf8'),
                    });
                }

                return `Success.`;
            } catch (e) {
                return toolErrorHandler(
                    e,
                    `Error generating ${
                        isOneRow ? 'one row' : 'table'
                    } result.`,
                );
            }
        },
    });
};
