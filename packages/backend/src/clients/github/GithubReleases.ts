import {
    type Release,
    type ReleaseItem,
    UnexpectedServerError,
} from '@lightdash/common';
import fetch from 'node-fetch';
import Logger from '../../logging/logger';

// =============================================================================
// Constants
// =============================================================================

const GITHUB_API_BASE = 'https://api.github.com';
const OWNER = 'lightdash';
const REPO = 'lightdash';

/** GitHub API page size for fetching releases */
const GITHUB_API_PAGE_SIZE = 30;

/** Ratio of newer releases to show (1/3 newer, 2/3 older when centered) */
const NEWER_RELEASES_RATIO = 1 / 3;

/** Cache TTL in milliseconds (15 minutes) */
const CACHE_TTL_MS = 15 * 60 * 1000;

// =============================================================================
// Types
// =============================================================================

type GitHubRelease = {
    id: number;
    tag_name: string;
    name: string | null;
    body: string | null;
    published_at: string | null;
    html_url: string;
    prerelease: boolean;
    draft: boolean;
};

type CachedReleases = {
    releases: GitHubRelease[];
    fetchedAt: number;
};

// =============================================================================
// Cache
// =============================================================================

/**
 * Simple in-memory cache for GitHub releases.
 * Caches all fetched releases to avoid hitting GitHub API rate limits.
 * GitHub unauthenticated API allows only 60 requests/hour/IP.
 */
let releasesCache: CachedReleases | null = null;

/**
 * Checks if the cache is valid (exists and not expired)
 */
function isCacheValid(): boolean {
    if (!releasesCache) return false;
    const age = Date.now() - releasesCache.fetchedAt;
    return age < CACHE_TTL_MS;
}

/**
 * Clears the releases cache. Useful for testing.
 */
export function clearReleasesCache(): void {
    releasesCache = null;
}

// =============================================================================
// Section Type Mapping
// =============================================================================

/**
 * Maps conventional changelog section headers to item types
 */
const SECTION_TYPE_MAP: Record<string, string> = {
    'bug fixes': 'fix',
    features: 'feat',
    chores: 'chore',
    'performance improvements': 'perf',
    documentation: 'docs',
    refactor: 'refactor',
    tests: 'test',
    'breaking changes': 'breaking',
    reverts: 'revert',
    style: 'style',
    ci: 'ci',
    build: 'build',
};

// =============================================================================
// Parsing Functions
// =============================================================================

/**
 * Parses release notes in the format generated by semantic-release/conventional-changelog.
 *
 * Example format:
 * ```markdown
 * ### Bug Fixes
 * * handle table calculation references ([#18613](url))
 *
 * ### Features
 * * improve dashboard refresh ([#18606](url))
 * ```
 */
function parseReleaseNotes(body: string | null): ReleaseItem[] {
    if (!body) return [];

    const items: ReleaseItem[] = [];
    let currentType = 'change';

    // Normalize line endings and split
    const lines = body.replace(/\r\n/g, '\n').split('\n');

    for (const line of lines) {
        try {
            // Check for section headers like "### Bug Fixes"
            const sectionMatch = line.match(/^###\s+(.+)$/);
            if (sectionMatch) {
                const sectionName = sectionMatch[1].toLowerCase().trim();
                currentType = SECTION_TYPE_MAP[sectionName] || 'change';
            } else if (line.startsWith('* ')) {
                // Parse bullet items like "* description ([#123](url)) ([commit](url))"
                const content = line.slice(2).trim();

                // Extract PR number from pattern like ([#18613](url))
                let prNumber: number | null = null;
                const prMatch = content.match(/\(\[#(\d+)\]\([^)]+\)\)/);
                if (prMatch) {
                    prNumber = parseInt(prMatch[1], 10);
                }

                // Remove PR link and commit hash links from description
                // Pattern: ([#18613](url)) ([f39c759](url))
                let description = content
                    .replace(/\s*\(\[#\d+\]\([^)]+\)\)/g, '')
                    .replace(/\s*\(\[[a-f0-9]+\]\([^)]+\)\)/g, '')
                    .trim();

                // Extract scope if present: "**scope:** description"
                let scope: string | null = null;
                const scopeMatch = description.match(
                    /^\*\*([^*]+)\*\*:\s*(.+)$/,
                );
                if (scopeMatch) {
                    scope = scopeMatch[1] || null;
                    description = scopeMatch[2] || description;
                }

                if (description) {
                    items.push({
                        type: currentType,
                        scope,
                        description: description.trim(),
                        prNumber,
                        prUrl: prNumber
                            ? `https://github.com/${OWNER}/${REPO}/pull/${prNumber}`
                            : null,
                    });
                }
            }
        } catch (error) {
            Logger.debug('Failed to parse release note line', { line, error });
            // Continue processing other lines
        }
    }

    return items;
}

/**
 * Converts a GitHub API release to our Release type
 */
function toRelease(
    ghRelease: GitHubRelease,
    currentVersion: string,
): Release | null {
    // Skip drafts and prereleases
    if (ghRelease.draft || ghRelease.prerelease) {
        return null;
    }

    const version = ghRelease.tag_name.replace(/^v/, '');
    const items = parseReleaseNotes(ghRelease.body);

    return {
        version,
        title: ghRelease.name || version,
        publishedAt: ghRelease.published_at || new Date().toISOString(),
        url: ghRelease.html_url,
        items,
        isCurrent: version === currentVersion,
    };
}

// =============================================================================
// GitHub API Functions
// =============================================================================

/**
 * Fetches a single page of releases from GitHub API
 * @param page - Page number (1-indexed)
 * @param perPage - Number of releases per page
 */
async function fetchGitHubReleasesPage(
    page: number,
    perPage: number,
): Promise<GitHubRelease[]> {
    const url = `${GITHUB_API_BASE}/repos/${OWNER}/${REPO}/releases?page=${page}&per_page=${perPage}`;

    const response = await fetch(url, {
        method: 'GET',
        headers: {
            Accept: 'application/vnd.github+json',
            'User-Agent': 'Lightdash-App',
            'X-GitHub-Api-Version': '2022-11-28',
        },
    });

    if (!response.ok) {
        if (response.status === 429) {
            throw new UnexpectedServerError(
                'GitHub API rate limit exceeded. Please try again later.',
            );
        }
        if (response.status === 403) {
            // GitHub returns 403 when rate limited without proper headers
            const remaining = response.headers.get('x-ratelimit-remaining');
            if (remaining === '0') {
                throw new UnexpectedServerError(
                    'GitHub API rate limit exceeded. Please try again later.',
                );
            }
        }
        if (response.status >= 500) {
            throw new UnexpectedServerError(
                `GitHub API is unavailable (${response.status}). Please try again later.`,
            );
        }
        throw new UnexpectedServerError(
            `GitHub API error: ${response.status} ${response.statusText}`,
        );
    }

    return (await response.json()) as GitHubRelease[];
}

/**
 * Fetches all releases from GitHub API with caching.
 * Uses in-memory cache to avoid hitting rate limits.
 */
async function fetchAllGitHubReleases(): Promise<GitHubRelease[]> {
    // Return cached releases if valid
    if (isCacheValid() && releasesCache) {
        Logger.debug('Using cached GitHub releases', {
            cacheAge: Date.now() - releasesCache.fetchedAt,
            releaseCount: releasesCache.releases.length,
        });
        return releasesCache.releases;
    }

    Logger.debug('Fetching fresh GitHub releases');

    try {
        const allReleases: GitHubRelease[] = [];
        let page = 1;
        let hasMore = true;

        // Fetch up to 5 pages (150 releases) to cover reasonable history
        const maxPages = 5;

        while (hasMore && page <= maxPages) {
            // eslint-disable-next-line no-await-in-loop
            const releases = await fetchGitHubReleasesPage(
                page,
                GITHUB_API_PAGE_SIZE,
            );
            allReleases.push(...releases);
            hasMore = releases.length === GITHUB_API_PAGE_SIZE;
            page += 1;
        }

        // Update cache
        releasesCache = {
            releases: allReleases,
            fetchedAt: Date.now(),
        };

        Logger.info('Fetched and cached GitHub releases', {
            releaseCount: allReleases.length,
        });

        return allReleases;
    } catch (error) {
        // If we have stale cache, use it as fallback
        if (releasesCache) {
            Logger.warn('GitHub API failed, using stale cache', { error });
            return releasesCache.releases;
        }

        Logger.error('Failed to fetch GitHub releases', { error });

        // Re-throw with proper error type
        if (error instanceof UnexpectedServerError) {
            throw error;
        }
        throw new UnexpectedServerError('Failed to fetch releases from GitHub');
    }
}

// =============================================================================
// Public API
// =============================================================================

export type ReleasesResult = {
    releases: Release[];
    currentVersionFound: boolean;
    hasPrevious: boolean;
    hasNext: boolean;
    previousCursor: string | null;
    nextCursor: string | null;
};

/**
 * Gets releases around a specific version.
 *
 * ## Pagination
 * - First request (no cursor) returns releases centered around current deployed version
 * - Use `nextCursor` + `direction=before` to get older releases
 * - Use `previousCursor` + `direction=after` to get newer releases
 *
 * @param currentVersion - The current deployed version
 * @param count - Number of releases to fetch around the current version
 * @param cursor - Optional cursor (release version tag) to paginate from
 * @param direction - Direction to paginate:
 *   'before' fetches older releases (published before cursor),
 *   'after' fetches newer releases (published after cursor).
 *   Releases are ordered by publish date descending (newest first).
 */
export async function getReleasesAroundVersion(
    currentVersion: string,
    count: number = 15,
    cursor?: string,
    direction: 'before' | 'after' = 'before',
): Promise<ReleasesResult> {
    const allGitHubReleases = await fetchAllGitHubReleases();

    // Convert to our Release type, filtering out drafts/prereleases
    const allReleases: Release[] = [];
    let currentVersionFound = false;

    for (const ghRelease of allGitHubReleases) {
        const release = toRelease(ghRelease, currentVersion);
        if (release) {
            if (release.isCurrent) {
                currentVersionFound = true;
            }
            allReleases.push(release);
        }
    }

    if (!currentVersionFound) {
        Logger.warn('Current version not found in GitHub releases', {
            currentVersion,
            latestRelease: allReleases[0]?.version,
        });
    }

    // Handle pagination
    let releases: Release[];
    let hasPrevious: boolean;
    let hasNext: boolean;

    if (!cursor) {
        // No cursor: center around current version
        const currentIdx = allReleases.findIndex((r) => r.isCurrent);
        if (currentIdx === -1) {
            // Current version not found, just return the first N releases
            releases = allReleases.slice(0, count);
            hasPrevious = false;
            hasNext = allReleases.length > count;
        } else {
            // Get releases centered around current version
            // Show fewer newer releases, more older releases
            const newerCount = Math.floor(count * NEWER_RELEASES_RATIO);

            const startIdx = Math.max(0, currentIdx - newerCount);
            const endIdx = Math.min(allReleases.length, startIdx + count);

            releases = allReleases.slice(startIdx, endIdx);
            hasPrevious = startIdx > 0;
            hasNext = endIdx < allReleases.length;
        }
    } else {
        // With cursor: paginate from cursor position
        const cursorIdx = allReleases.findIndex((r) => r.version === cursor);

        if (cursorIdx === -1) {
            // Cursor not found, return first N releases
            Logger.warn('Pagination cursor not found', { cursor });
            releases = allReleases.slice(0, count);
            hasPrevious = false;
            hasNext = allReleases.length > count;
        } else if (direction === 'before') {
            // Get releases after cursor (older, higher index)
            const startIdx = cursorIdx + 1;
            const endIdx = Math.min(allReleases.length, startIdx + count);
            releases = allReleases.slice(startIdx, endIdx);
            hasPrevious = startIdx > 0;
            hasNext = endIdx < allReleases.length;
        } else {
            // Get releases before cursor (newer, lower index)
            const endIdx = cursorIdx;
            const startIdx = Math.max(0, endIdx - count);
            releases = allReleases.slice(startIdx, endIdx);
            hasPrevious = startIdx > 0;
            hasNext = endIdx < allReleases.length;
        }
    }

    return {
        releases,
        currentVersionFound,
        hasPrevious,
        hasNext,
        previousCursor: releases.length > 0 ? releases[0].version : null,
        nextCursor:
            releases.length > 0 ? releases[releases.length - 1].version : null,
    };
}
