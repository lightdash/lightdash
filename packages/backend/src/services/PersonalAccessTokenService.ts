import {
    CreatePersonalAccessToken,
    ParameterError,
    PersonalAccessToken,
    PersonalAccessTokenWithToken,
    RequestMethod,
    SessionUser,
} from '@lightdash/common';
import { LightdashAnalytics } from '../analytics/LightdashAnalytics';
import { PersonalAccessTokenModel } from '../models/DashboardModel/PersonalAccessTokenModel';
import { BaseService } from './BaseService';

type PersonalAccessTokenServiceArguments = {
    analytics: LightdashAnalytics;
    personalAccessTokenModel: PersonalAccessTokenModel;
};

export class PersonalAccessTokenService extends BaseService {
    private readonly analytics: LightdashAnalytics;

    private readonly personalAccessTokenModel: PersonalAccessTokenModel;

    constructor(args: PersonalAccessTokenServiceArguments) {
        super();
        this.analytics = args.analytics;
        this.personalAccessTokenModel = args.personalAccessTokenModel;
    }

    async createPersonalAccessToken(
        user: Pick<SessionUser, 'userId' | 'userUuid'>,
        data: CreatePersonalAccessToken,
        method: RequestMethod,
    ): Promise<PersonalAccessTokenWithToken> {
        const result = await this.personalAccessTokenModel.create(user, data);
        this.analytics.track({
            userId: user.userUuid,
            event: 'personal_access_token.created',
            properties: {
                userId: user.userUuid,
                autoGenerated: data.autoGenerated,
                method,
            },
        });
        return result;
    }

    async deletePersonalAccessToken(
        user: Pick<SessionUser, 'userUuid'>,
        personalAccessTokenUuid: string,
    ): Promise<void> {
        await this.personalAccessTokenModel.delete(personalAccessTokenUuid);
        this.analytics.track({
            userId: user.userUuid,
            event: 'personal_access_token.deleted',
        });
    }

    async getAllPersonalAccessTokens(
        user: Pick<SessionUser, 'userId'>,
    ): Promise<PersonalAccessToken[]> {
        return this.personalAccessTokenModel.getAllForUser(user.userId);
    }

    async rotatePersonalAccessToken(
        user: Pick<SessionUser, 'userUuid'>,
        personalAccessTokenUuid: string,
        data: { expiresAt: Date },
    ): Promise<PersonalAccessTokenWithToken> {
        if (data.expiresAt.getTime() < Date.now()) {
            throw new ParameterError('Expire time must be in the future');
        }

        const existingToken = await this.personalAccessTokenModel.getUserToken({
            userUuid: user.userUuid,
            tokenUuid: personalAccessTokenUuid,
        });

        // Business decision, we don't want to rotate tokens that don't expire. Rotation is a security feature that should be used with tokens that expire.
        if (!existingToken.expiresAt) {
            throw new ParameterError(
                'Token with no expiration date cannot be rotated',
            );
        }

        if (
            existingToken.rotatedAt &&
            existingToken.rotatedAt.getTime() > Date.now() - 3600000
        ) {
            throw new ParameterError('Token can only be rotated once per hour');
        }

        const newToken = await this.personalAccessTokenModel.rotate({
            personalAccessTokenUuid,
            expiresAt: data.expiresAt,
        });
        this.analytics.track({
            userId: user.userUuid,
            event: 'personal_access_token.rotated',
        });
        return newToken;
    }
}
