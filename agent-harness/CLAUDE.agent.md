# Agent ${AGENT_ID} — Lightdash Development Environment

## Your Environment

- **Agent ID**: ${AGENT_ID}
- **Frontend URL**: http://localhost:${FE_PORT}
- **API URL**: http://localhost:${API_PORT}
- **Database**: `agent_${AGENT_ID}` on `localhost:${DB_PORT}`
- **Test login**: `demo@lightdash.com` / `demo_password!`

## Managing Your Stack

Always use `agent-cli.sh` to interact with your stack:

```bash
# Check process status
./agent-harness/agent-cli.sh ${AGENT_ID} status

# View logs (api, frontend, common-watch, warehouses-watch)
./agent-harness/agent-cli.sh ${AGENT_ID} logs api

# Restart a service after changes
./agent-harness/agent-cli.sh ${AGENT_ID} restart api

# Check health
./agent-harness/agent-cli.sh ${AGENT_ID} health

# Run SQL queries
./agent-harness/agent-cli.sh ${AGENT_ID} psql "SELECT * FROM users LIMIT 5;"

# View slow queries
./agent-harness/agent-cli.sh ${AGENT_ID} slow-queries

# Get URLs
./agent-harness/agent-cli.sh ${AGENT_ID} url
```

## Verification Workflow

Run verification **after every change**:

```bash
# Quick verification (typecheck + lint + unit tests)
./agent-harness/verify.sh ${AGENT_ID}

# Full verification (before declaring done)
./agent-harness/verify.sh ${AGENT_ID} --full
```

Verification stages run in order and stop on first failure:
1. **typecheck** — TypeScript compilation for common, backend, frontend (parallel)
2. **lint** — ESLint for common, backend, frontend (parallel)
3. **test-unit** — Jest/Vitest unit tests for changed files
4. **test-full** (--full only) — Complete test suite
5. **smoke** (--full only) — API health check

## Definition of Done

Your task is done when ALL of these are true:
- [ ] `./agent-harness/verify.sh ${AGENT_ID} --full` returns `"status": "pass"`
- [ ] The feature/fix works correctly in the browser at http://localhost:${FE_PORT}
- [ ] Tests cover the change (new tests for new features, updated tests for changes)
- [ ] No TypeScript errors, no lint warnings
- [ ] Changes are committed with a clear message

## What NOT To Do

- **Do NOT** modify test infrastructure or disable tests to make them pass
- **Do NOT** hardcode ports — your services use agent-specific ports
- **Do NOT** run raw `docker compose` commands — use `agent-cli.sh`
- **Do NOT** modify shared infrastructure (the PostgreSQL/MinIO/etc. containers)
- **Do NOT** touch other agents' databases, files, or PM2 processes
- **Do NOT** edit `.env.agent.${AGENT_ID}` or `ecosystem.agent.${AGENT_ID}.config.cjs` manually — they are auto-generated by `launch.sh`

## Package-Specific Commands

```bash
# Type checking (per-package, faster than full)
pnpm -F common typecheck
pnpm -F backend typecheck
pnpm -F frontend typecheck

# Linting
pnpm -F common lint
pnpm -F backend lint
pnpm -F frontend lint

# Testing
pnpm -F common test
pnpm -F backend test:dev:nowatch

# Generate API specs (after changing TSOA controllers)
pnpm generate-api
```

## Architecture Notes

- **Backend**: Express.js + Knex.js on port ${API_PORT}
- **Frontend**: React + Vite on port ${FE_PORT}
- **Common**: Shared types/utils (`@lightdash/common`)
- **Warehouses**: Data warehouse adapters
- Backend auto-restarts on crashes; frontend does not (restart manually if needed)
- TypeScript watchers (common-watch, warehouses-watch) rebuild shared packages on change
